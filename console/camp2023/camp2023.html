<!DOCTYPE html><html xml:lang="ja" lang="ja"><head>
  <title>校庭キャンプ2023</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <!-- link rel="stylesheet" type="text/css" href="../../component/szLib.css" -->
  <style type="text/css">html {
  font-size: 24pt;
  font:helvetica,arial,freesans,clean,sans-serif;
  line-height: 1.5rem;
  color: black;
  box-sizing: border-box;
  height: 100%;
  margin: 0;
  padding: 0;
}

body {
  min-height: 100vh;
  -webkit-text-size-adjust: none;
  -moz-text-size-adjust: none;
  text-size-adjust: none;
}

* {
  margin: 0;
  padding: 0;
  font-size: 1rem;
  overflow-wrap: anywhere;
}
.right, .num {
  text-align: right;
}
/*
  ヘッダ関係
*/
h1,h2,h3,h4,h5,h6 {
  border: 0;
}
h1 {
  font-size: 170%;
  border-top: 4px solid #aaa;
  padding-top: 0.5em;
  margin-top: 1.5em;
}
h2, h3 {
  margin: 1em 0;
}
h2 {
  font-size: 150%;
  margin-top: 1.5em;
  border-bottom: 1px solid #ddd;
  padding-bottom: 0.5em;
}
/*
  テーブル関係
*/
th, .th {
  padding: 0.3em;
  background-color: #888;
  color: white;
}
td, .td {
  padding: 0.3em;
  border-bottom: solid 1px #aaa;
  border-right: solid 1px #aaa;
}
/*
  リスト関係
*/
ul, ol {
  margin: 1em 0 1em 2em;
}
li {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}
/*
  ソース表示
*/
code {
  background-color: #f8f8ff;
  color: #444;
  padding: 0 0.2em;
  border: 1px solid #dedede;
}

pre {
  border: solid 5px #999;
}</style>
  <style type="text/css">/*
  ローディングアイコン集
  https://projects.lukehaas.me/css-loaders/

  ex. <div class="loading5">loading...</div>

  全画面表示で中央に配置する場合：
  <div name="loading">
    <div><div class="loading5">loading...</div></div>
  </div>

*/
div[name="loading"] {
  /* CSSで全画面オーバーレイを実装する方法＆コード例
     https://pisuke-code.com/css-fullscreen-overlay/ */
  display: block;
  position: absolute;
  left: 0; top: 0;
  width: 100%; height:100vh;
  background: #fff;
  z-index: 2147483647;
}

div[name="loading"] > div {
  display:flex;
  width:100%;
  height:100vh;
  background:#fff;
  justify-content:center;
  align-items:center;
}

.loading5 {
  --dot-size: 4rem;
  --R: 0;
  --G: 0;
  --B: 0;
  --back: rgba(var(--R),var(--G),var(--B),1);
  --pale: rgba(var(--R),var(--G),var(--B),0.2);
  --middle: rgba(var(--R),var(--G),var(--B),0.5);
  --dark: rgba(var(--R),var(--G),var(--B),0.7);
  --m0: calc(var(--dot-size) * 0.8); /* 軌道の大きさ */
  --m1: calc(var(--m0) * -2.6);
  --m2: calc(var(--m0) * -1.8);
  --m3: calc(var(--m0) * 1.75);
  --m4: calc(var(--m0) * 1.8);
  --m5: calc(var(--m0) * 2.5);

  margin: 100px auto;
  font-size: 25px;
  width: var(--dot-size);
  height: var(--dot-size);
  border-radius: 50%;
  position: relative;
  text-indent: -9999em;
  -webkit-animation: load5 1.1s infinite ease;
  animation: load5 1.1s infinite ease;
  -webkit-transform: translateZ(0);
  -ms-transform: translateZ(0);
  transform: translateZ(0);
}
@-webkit-keyframes load5 {
  0%,
  100% {box-shadow:
    0em var(--m1) 0em 0em var(--back),
    var(--m4) var(--m2) 0 0em var(--pale),
    var(--m5) 0em 0 0em var(--pale),
    var(--m3) var(--m3) 0 0em var(--pale),
    0em var(--m5) 0 0em var(--pale),
    var(--m2) var(--m4) 0 0em var(--pale),
    var(--m1) 0em 0 0em var(--middle),
    var(--m2) var(--m2) 0 0em var(--dark);
  }
  12.5% {
    box-shadow: 0em var(--m1) 0em 0em var(--dark), var(--m4) var(--m2) 0 0em var(--back), var(--m5) 0em 0 0em var(--pale), var(--m3) var(--m3) 0 0em var(--pale), 0em var(--m5) 0 0em var(--pale), var(--m2) var(--m4) 0 0em var(--pale), var(--m1) 0em 0 0em var(--pale), var(--m2) var(--m2) 0 0em var(--middle);
  }
  25% {
    box-shadow: 0em var(--m1) 0em 0em var(--middle), var(--m4) var(--m2) 0 0em var(--dark), var(--m5) 0em 0 0em var(--back), var(--m3) var(--m3) 0 0em var(--pale), 0em var(--m5) 0 0em var(--pale), var(--m2) var(--m4) 0 0em var(--pale), var(--m1) 0em 0 0em var(--pale), var(--m2) var(--m2) 0 0em var(--pale);
  }
  37.5% {
    box-shadow: 0em var(--m1) 0em 0em var(--pale), var(--m4) var(--m2) 0 0em var(--middle), var(--m5) 0em 0 0em var(--dark), var(--m3) var(--m3) 0 0em var(--back), 0em var(--m5) 0 0em var(--pale), var(--m2) var(--m4) 0 0em var(--pale), var(--m1) 0em 0 0em var(--pale), var(--m2) var(--m2) 0 0em var(--pale);
  }
  50% {
    box-shadow: 0em var(--m1) 0em 0em var(--pale), var(--m4) var(--m2) 0 0em var(--pale), var(--m5) 0em 0 0em var(--middle), var(--m3) var(--m3) 0 0em var(--dark), 0em var(--m5) 0 0em var(--back), var(--m2) var(--m4) 0 0em var(--pale), var(--m1) 0em 0 0em var(--pale), var(--m2) var(--m2) 0 0em var(--pale);
  }
  62.5% {
    box-shadow: 0em var(--m1) 0em 0em var(--pale), var(--m4) var(--m2) 0 0em var(--pale), var(--m5) 0em 0 0em var(--pale), var(--m3) var(--m3) 0 0em var(--middle), 0em var(--m5) 0 0em var(--dark), var(--m2) var(--m4) 0 0em var(--back), var(--m1) 0em 0 0em var(--pale), var(--m2) var(--m2) 0 0em var(--pale);
  }
  75% {
    box-shadow: 0em var(--m1) 0em 0em var(--pale), var(--m4) var(--m2) 0 0em var(--pale), var(--m5) 0em 0 0em var(--pale), var(--m3) var(--m3) 0 0em var(--pale), 0em var(--m5) 0 0em var(--middle), var(--m2) var(--m4) 0 0em var(--dark), var(--m1) 0em 0 0em var(--back), var(--m2) var(--m2) 0 0em var(--pale);
  }
  87.5% {
    box-shadow: 0em var(--m1) 0em 0em var(--pale), var(--m4) var(--m2) 0 0em var(--pale), var(--m5) 0em 0 0em var(--pale), var(--m3) var(--m3) 0 0em var(--pale), 0em var(--m5) 0 0em var(--pale), var(--m2) var(--m4) 0 0em var(--middle), var(--m1) 0em 0 0em var(--dark), var(--m2) var(--m2) 0 0em var(--back);
  }
}
@keyframes load5 {
  0%,
  100% {
    box-shadow: 0em var(--m1) 0em 0em var(--back), var(--m4) var(--m2) 0 0em var(--pale), var(--m5) 0em 0 0em var(--pale), var(--m3) var(--m3) 0 0em var(--pale), 0em var(--m5) 0 0em var(--pale), var(--m2) var(--m4) 0 0em var(--pale), var(--m1) 0em 0 0em var(--middle), var(--m2) var(--m2) 0 0em var(--dark);
  }
  12.5% {
    box-shadow: 0em var(--m1) 0em 0em var(--dark), var(--m4) var(--m2) 0 0em var(--back), var(--m5) 0em 0 0em var(--pale), var(--m3) var(--m3) 0 0em var(--pale), 0em var(--m5) 0 0em var(--pale), var(--m2) var(--m4) 0 0em var(--pale), var(--m1) 0em 0 0em var(--pale), var(--m2) var(--m2) 0 0em var(--middle);
  }
  25% {
    box-shadow: 0em var(--m1) 0em 0em var(--middle), var(--m4) var(--m2) 0 0em var(--dark), var(--m5) 0em 0 0em var(--back), var(--m3) var(--m3) 0 0em var(--pale), 0em var(--m5) 0 0em var(--pale), var(--m2) var(--m4) 0 0em var(--pale), var(--m1) 0em 0 0em var(--pale), var(--m2) var(--m2) 0 0em var(--pale);
  }
  37.5% {
    box-shadow: 0em var(--m1) 0em 0em var(--pale), var(--m4) var(--m2) 0 0em var(--middle), var(--m5) 0em 0 0em var(--dark), var(--m3) var(--m3) 0 0em var(--back), 0em var(--m5) 0 0em var(--pale), var(--m2) var(--m4) 0 0em var(--pale), var(--m1) 0em 0 0em var(--pale), var(--m2) var(--m2) 0 0em var(--pale);
  }
  50% {
    box-shadow: 0em var(--m1) 0em 0em var(--pale), var(--m4) var(--m2) 0 0em var(--pale), var(--m5) 0em 0 0em var(--middle), var(--m3) var(--m3) 0 0em var(--dark), 0em var(--m5) 0 0em var(--back), var(--m2) var(--m4) 0 0em var(--pale), var(--m1) 0em 0 0em var(--pale), var(--m2) var(--m2) 0 0em var(--pale);
  }
  62.5% {
    box-shadow: 0em var(--m1) 0em 0em var(--pale), var(--m4) var(--m2) 0 0em var(--pale), var(--m5) 0em 0 0em var(--pale), var(--m3) var(--m3) 0 0em var(--middle), 0em var(--m5) 0 0em var(--dark), var(--m2) var(--m4) 0 0em var(--back), var(--m1) 0em 0 0em var(--pale), var(--m2) var(--m2) 0 0em var(--pale);
  }
  75% {
    box-shadow: 0em var(--m1) 0em 0em var(--pale), var(--m4) var(--m2) 0 0em var(--pale), var(--m5) 0em 0 0em var(--pale), var(--m3) var(--m3) 0 0em var(--pale), 0em var(--m5) 0 0em var(--middle), var(--m2) var(--m4) 0 0em var(--dark), var(--m1) 0em 0 0em var(--back), var(--m2) var(--m2) 0 0em var(--pale);
  }
  87.5% {
    box-shadow: 0em var(--m1) 0em 0em var(--pale), var(--m4) var(--m2) 0 0em var(--pale), var(--m5) 0em 0 0em var(--pale), var(--m3) var(--m3) 0 0em var(--pale), 0em var(--m5) 0 0em var(--pale), var(--m2) var(--m4) 0 0em var(--middle), var(--m1) 0em 0 0em var(--dark), var(--m2) var(--m2) 0 0em var(--back);
  }
}</style>

  <style type="text/css">
    .img {
      width: 100%;
      overflow: scroll;
    }
    .PlantUML {
      overflow-x: auto;
    }
    .BurgerMenu[name="main"] {
      margin-top: 1rem; /* 最上位メニューの上に余白設定 */
    }
    .BurgerMenu .page {
      padding: 1rem;
      width: calc(100% - 2rem);
      height: calc(100% - 2rem);
    }
    [data-BurgerMenu] {
      padding: 1rem;
      width: calc(100% - 2rem);
    }
  </style>
</head>
<body>
  <div name="loading"><div><div class="loading5">loading...</div></div></div>

  <div data-burgermenu="label:'お知らせ'">
    <div data-burgermenu="label:'掲示板'">
      <div class="page">
        <div name="board"></div>
      </div>
    </div>
    <div data-burgermenu="label:'注意事項'" class="markdown">1. 【削除予定】去年はあったが今年は削除するつもりの項目
   - 受付で体温測定を行います。37.5℃以上の発熱がある場合、参加をお断りさせていただきます。
   - 飲食時以外はマスクをご着用ください。
   - 帰宅時は必ず保護者または成年の代理がお迎えください。

1. 応募時の注意
   - 【追加】イベント当日の申込は応募者数の多寡によらず承りかねます
   - 【追加】応募者多数の場合、申込締切時点の応募者を対象に抽選となります(締切以後の応募は抽選の対象外)
   - 【追加】テントの持ち込みは応募時にご連絡ください(抽選時点で持込無しで応募された方が当選後に持込に変更を希望しても、原則として承れません)
   - 【追加】抽選の結果、テント持込希望でも「テント持込無しなら当選」という結果になる場合があります。予めご了承ください

1. 参加者の加除、申込のキャンセル
   - 参加メンバの追加・削除・変更等、登録内容に修正があれば、参加登録内容の確認メールに記載された「回答を編集」から修正してください。
   - 参加をキャンセルする場合、以下のように対応お願いします
     1. 参加登録内容の確認メールに記載された「回答を編集」を選択
     1. 備考欄の内容を「キャンセル」に修正
     1. 登録されているメールアドレスからskt.oyaji@gmail.comへメールを送付
        - 題名：校庭キャンプ2023キャンセル
        - 本文：保護者氏名のみ記載

1. 参加当日
   - 台風等で中止せざるを得ない場合があります。その場合の対応は、本サイト等でご案内させていただきます。
   - 在学生の参加にはなるべく、未就学児の参加には必ず、<del>保護者</del>引率者が同伴ください。
   - 遊具は持ち込みいただけますが、ご使用の際は他の参加者のご迷惑とならないよう、保護者の方でご注意ください。
   - ごみ箱の用意はありません。食べ残し他のごみはお持ち帰りの上、各家庭で処理願います。
   - 参加者が多いため駐輪場は確保できません。荷物運搬を含め、自転車での来校はご遠慮ください。
   - 保護者の方は名札をご用意ください。
   - 参加費はお釣りの無いようにご用意ください。

1. キャンプ
   - テントの貸出はありません。テント・テーブル・タープ等を使用したい場合、申込時に事前申告の上、当日ご持参ください。
   - 火気を使用するキャンプ用品はご利用いただけません(例：グリル、コンロ、ガソリンを使用するランタン等)

1. 食事
   - 食事はカレールーのみ提供されます。ごはんや副菜、皿・スプーン・コップ等の食器は提供されませんので、各自ご持参ください。
   - 食品アレルギーのある方への個別対応は困難なので、申し訳ありませんが参加者側でカレールーまたは代替品をご持参いただけますようお願いします。
   - 食後の食器はそのまま持ち帰り、洗浄は各家庭でお願いします。
   - 校舎内の飲食は禁止されています。おやつの持ち込みはご遠慮ください。
   - コロナ対応等で当日校内での飲食ができなくなる可能性があります。対応は都度ご案内しますが、予めご了承ください。

1. <del>ゲーム、イベント</del>校内探検
   - 校内探検の際の懐中電灯はグループ毎に1つ運営で貸与します。明るくなり過ぎないよう、参加者各自の持参・使用はご遠慮ください。

1. その他
   - 本件に関する問合せは skt.oyaji@gmail.com にお願いします。</div>
    <div data-burgermenu="label:'持ち物'" class="markdown">1. キャンプ
  - テント・テーブル・タープ等のキャンプ用品(任意)
  - 敷物

1. 食事
  - ご飯・パン等の主食、おかず
  - 飲み物
  - 皿、スプーン、箸、コップ等の食器
  - ナプキン、ウェットティッシュ等
  - 持ち帰り用ゴミ袋

1. <del>ゲーム・イベント</del>校内探検

1. その他
  - 参加費(お釣りの無いように)
  - 保護者用名札
  - マスク
  - 水筒</div>
  </div>
  <div data-burgermenu="label:'パスポート'"></div>




<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js"></script>

<!-- MarkDownテキストをHTML化するCDN -->
<script src="https://taisukef.github.io/marked_md/marked.min.js"></script>

<!-- 共通鍵暗号化：cryptoJS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/enc-base64.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/cipher-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/sha256.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/sha1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/aes.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/hmac.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/pbkdf2.min.js"></script>

<!-- cryptico -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/cryptico/0.0.1343522940/cryptico.min.js" integrity="sha512-C7GGRhFRn7F7hsLH1oCH2kX9ls61kx33wAgTZ6xJDwGvvgULcIZpwKqxG1+Kj/KOD2jWPxjNQYHi4BopPJPxVA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- mermaid -->
<script src="https://cdn.jsdelivr.net/npm/mermaid@10.2.4/dist/mermaid.min.js"></script>
<!-- QRコード検出/生成 -->
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

<!-- =====================================================
  自作ライブラリ
===================================================== -->
<script type="text/javascript">/* コアScript */
/**
 * @typedef {Object} AuthProp - AuthOpt以外のAuthクラスプロパティ
 * @prop {number} constructorStart - constructor開始時刻(UNIX時間)
 * @prop {string} parentSelector - 親画面のCSSセレクタ
 * @prop {HTMLElement} parentWindow - 親画面のHTML要素
 * @prop {HTMLElement} AuthWindow - Auth関係画面のwrapper
 * @prop {HTMLElement} loading - ローディング画面のHTML要素
 */

/**
 * @typedef {Object} AuthOpt
 * @prop {string} [entryNo] - 受付番号(ID)
 * @prop {string} [passWord] - パスワード
 * @prop {string} [header=''] - 受付番号入力画面に表示するheaderのinnerHTML
 * @prop {string} [entryNoMessage='受付番号を入力してください'] - 受付番号入力画面に表示するメッセージ
 * @prop {string} [entryNoButton='送信'] - 受付番号入力画面のボタンのラベル
 * @prop {RegExp} [entryNoRegExp=/^[0-9]{1,4}$/] - 受付番号チェック用正規表現
 */

/**
 * @classdesc 入力されたID/PWと登録情報を突合し、IDに紐づく各種情報を返す
 *
 * - パスコード(passCode) : 受付番号入力後受信したメールに記載された番号
 * - パスワード(passWord) : 鍵ペア生成の際、秘密鍵の基となる文字列
 */
class Auth {
  /**
   * @constructor
   * @param {string} gatewayUrl - 認証局APIのURL
   * @param {AuthOpt} [opt={}] - 生成時オプション
   * @returns {void} なし
   * 
   * ## 処理概要
   * 
   * ```mermaid
   * sequenceDiagram
   *   autonumber
   *   actor mailer as メーラ
   *   actor browser as ブラウザ
   *   participant gateway as 認証局
   *   participant master as 管理局
   *   participant httpd as httpd
   * 
   *   %% 受付番号入力
   *   mailer ->> httpd : 事前に送信された案内メールのリンクをクリック
   *   httpd ->> browser : ページファイル(index.html)
   *   activate browser
   *   Note right of browser: constructor()
   *   Note right of browser: getEntryNo()
   * 
   *   browser ->> gateway : 受付番号、CP(平文)
   *   activate gateway
   *   Note right of gateway : auth1A()
   * 
   *   gateway ->> master : 受付番号、CP(GS/MP)
   *   activate master
   *   Note right of master : auth1B()
   *   master ->> mailer : パスコード
   *   activate mailer
   * 
   *   master ->> gateway : 申請登録結果
   *   deactivate master
   * 
   *   gateway ->> browser : 申請登録結果
   *   deactivate gateway
   *   browser ->> browser : GP格納、パスコード入力画面表示
   *   deactivate browser
   * 
   * 
   *   %% パスコード入力
   *   mailer ->> browser : パスコード入力
   *   deactivate mailer
   *   activate browser
   *   Note right of browser : getPassCode()
   *   browser ->> gateway : 受付番号、パスコード(CS/GP)
   *   activate gateway
   *   Note right of gateway : auth2A
   *   gateway ->> master : 受付番号、パスコード、CP(GS/MP)
   *   activate master
   *   Note right of master : auth2B
   *   master ->> gateway : 利用者情報
   *   deactivate master
   *   gateway ->> browser : 利用者情報,CK
   *   deactivate gateway
   *   browser ->> browser : 初期画面表示
   *   deactivate browser
   * 
   * ```
   * 
   * - 文中の記号は以下の通り
   *   - CK:共通鍵(Common Key)
   *   - CP:利用者公開鍵(Client Public key)、CS:利用者秘密鍵(Client Secret key)
   *   - GP:認証局公開鍵(Gateway Public key)、GS:認証局秘密鍵(Gateway Secret key)
   *   - FP:配信局公開鍵(Front Public key)、FS:配信局秘密鍵(Front Secret key)
   *   - MP:管理局公開鍵(Master Public key)、MS:管理局秘密鍵(Master Secret key)
   *   - (xS/yP) = XX局秘密鍵で署名、YY局公開鍵で暗号化した、XX->YY宛の通信<br>
   *     例：(GS/MP) ⇒ GS(認証局秘密鍵)で署名、MP(管理局公開鍵)で暗号化
   * - (02) constructor() : DOMContentLoaded時、以下の処理を実行
   *   1. 利用者の秘密鍵(以下CSkey)・公開鍵(以下CPkey)を生成
   *   1. getEntryNo()を呼び出し
   * - (02) getEntryNo() : 受付番号入力
   *   1. 受付番号入力画面を表示(z-indexを最大にして他の画面を触らせない)
   *   1. 入力後待機画面表示、レスポンスがあったらgetPassCode()を呼び出し
   * - (03) auth1A() : 認証申請の受付
   *   1. 受付番号とCPをauth1Bに送信
   *   1. auth1Bの申請結果を受けたらブラウザに結果を送信<br>
   *      申請OKの場合はGPも併せて送信
   * - (04) auth1B() : 認証申請の登録
   *   1. 受付番号とCPをシートに書き込み
   *   1. 正当性を検証
   *      - パスコードが一致
   *      - パスコード発行日時から1時間以内
   *      - 3回連続失敗後1時間以上経過
   *   1. 正当だった場合はパスコードを生成、シートに書き込み
   *   1. 申請者にパスコードを通知(05)
   *   1. 申請登録の結果をauth1Aに返す
   * - (09) getPassCode() : パスコード入力
   *   1. パスコード入力画面を表示<br>
   *      ※パスコードは数値6桁を想定。変更する場合、auth2Bのパスコード正当性ロジック見直しのこと。
   *   1. パスコードが入力されたらauth2Aに送信
   *   1. auth2Aからレスポンスがあったらthisに保存、初期画面を表示
   * - (10) auth2A
   *   1. 受付番号・パスコード・CPkeyを管理局に送信
   *   1. 利用者情報をauth2Bから受けたらFPを追加して利用者に返す
   * - (12) auth2B
   *   1. 送信された受付番号・パスコード・CPkeyが有効か、シートの申請登録と突合
   *   1. OKなら利用者情報をauth2Aに返す
   * 
   * ## 使用方法
   * 
   * ```
   * let config;
   * window.addEventListener('DOMContentLoaded',async () => {
   *   const v = {};
   *   console.log('DOMContentLoaded start.');
   *   v.auth = new Auth('https://script.google.com/macros/s/〜/exec');
   *   await v.auth.build();
   *   // ローディング画面解除
   *   document.querySelector('div[name="loading"]').style.display = 'none';
   * 
   *   console.log(v.auth);
   *   console.log('DOMContentLoaded end.');
   * });
   * ```
   * 
   * - `new Auth()`実行後、必ず`.build()`を実行する
   * 
   */
  constructor(gatewayUrl,opt={}){
    const v = {whois:'Auth.constructor'};
    console.log(v.whois+' start.');
    try {

      v.step = '1'; // オプション未定義項目の既定値をプロパティにセット
      this.#setProperties(this,null,opt);

      v.step = '2'; // 必須項目をプロパティに保存
      this.gateway.url = gatewayUrl;  // 認証局のURL

      v.step = '3'; // 各種画面を用意する
      //   ※鍵ペア生成で時間がかかるので、先に待機画面を表示
      this.#setWindows();

      v.step = '4'; // 秘密鍵・公開鍵を作成し、プロパティに格納する
      this.#setupKeys();

      console.log(v.whois+' normal end.');
    } catch(e){
      v.msg = v.whois + ' abnormal end(step.'+v.step+').' + e.message;
      console.error(v.msg);
      alert(v.msg);
    }
  }

  /** 初期化時に必要な一連の非同期処理を実施
   * @param {void} - 無し
   * @returns {void} 無し
   */
  async build(){
    const v = {whois:'Auth.build',rv:null};
    console.log(v.whois+' start.');
    try {
      v.step = '1.1'; do  // 受付番号をダイアログから取得
        this.entryNo.value = await this.#getEntryNo();
      while( this.entryNo.value.match(/^[0-9]{1,4}$/) === null );

      v.step = '1.2'; v.arg = { // auth1Aに渡す引数をセット
        entryNo: this.entryNo.value,
        publicKey: this.RSA.pKey,
      }
      console.log('arg',v.arg);

      v.step = '1.3'; // fetch
      v.rv = await this.fetch('auth1A',v.arg,0);
      if( v.rv.isErr ){
        alert(v.rv.message);
        return null;
      } else {
        this.gateway.pKey = v.rv.result;
      }

      v.step = '2.1'; do  // 受付番号が指定形式になるまでループ
        this.passCode.value = await this.#getPassCode();
      while( this.passCode.value.match(/^[0-9]{6}$/) === null );

      // 入力フォームから値を取得
      //this.#changeScreen('loading');
      v.step = '2.2'; v.arg = { // auth1Bに渡す引数
        entryNo: this.entryNo.value,
        passCode: this.passCode.value,
      }
      console.log('arg',v.arg);

      v.step = '2.3'; // fetch
      v.rv = await this.fetch('auth2A',v.arg,3);
      if( v.rv.isErr ){
        console.error(v.rv);
      } else {
        // 申請者情報と共通鍵を格納
        this.commonKey = v.rv.result.common;
        this.info = v.rv.result.info;
        console.log('commonKey='+this.commonKey,'info',this.info);
      }

      console.log(v.whois+' normal end.');
      return v.rv;
    } catch(e){
      console.error(v.whois+' abnormal end.\n',e);
    }
  }

  /** 設定先のオブジェクトに起動時パラメータを優先して既定値を設定する
   * @param {Object} dest - 設定先のオブジェクト。初回呼出時はthis
   * @param {def} def - 既定値のオブジェクト。初回呼出時はnull(内部定義を使用)
   * @param {AuthOpt} opt - 起動時にオプションとして渡されたオブジェクト
   * @returns {void}
   */
  #setProperties(dest,def,opt){
    const v = {whois:'Auth.#setProperties',rv:true,def:{
      parentSelector: "body", // {string} - 親要素のCSSセレクタ
      RSA:{  // 自局のRSAキー関係情報
        bits: 1024,     // {number} - RSAキー長
        passWord: null, // {string} - パスワード
        pwLength: 32,   // {number} - 自動生成する場合のパスワード文字数
        sKey: null,     // {RSAKey} - 秘密鍵
        pKey: null,     // {string} - 公開鍵
      },
      commonKey: null,  // {string} - 共通鍵
      info: null, // {Object.<string, any>} - 管理局.masterシートの参加者情報
      gateway:{ // 認証局関連情報
        url: null,  // {string} - APIのURL
        pKey: null, // {string} - 公開鍵
      },
      front: {  // 配信局関連情報
        url: null,  // {string} - APIのURL
        pKey: null, // {string} - 公開鍵
      },
      entryNo:{ // 受付番号関係
        element: null, // {HTMLElement} - 受付番号入力画面の要素。setWindowsで設定。
        value: '',  // {string} - 受付番号
        css: [
          {sel:'dialog.Auth',prop:{
            'margin':'auto',
            'padding':'1rem',
            'box-shadow':'0 0 1rem black',
          }},
          {sel:'dialog.Auth::backdrop',prop:{
            'background-color':'#ddd',
          }},
          {sel:'dialog.Auth p',prop:{
            'font-size':'1.5rem',
            'margin':'0.5rem 0',  
          }},
          {sel:'dialog.Auth li',prop:{
            'font-size':'1rem',
            'margin':'0.5rem 0',  
          }},
          {sel:'dialog.Auth > input[type="text"]',prop:{
            'font-size':'1.5rem',
            'border':'solid 2px #888',
            'height':'2rem',
            'width':'6rem',    
          }},
          {sel:'dialog.Auth > input[type="button"]',prop:{
            'font-size':'1rem',
            'padding':'0.25rem 1rem',
            'margin-left':'1rem',
          }},
        ],
        dialog: `<p>受付番号を入力してください</p>`,
        /*
        header:'',    // {string} - 受付番号入力画面に表示するheaderのinnerHTML
        msg1:'受付番号を入力してください', // {string} - 入力欄の前に表示するメッセージ
        button:'送信',  // {string} - 受付番号入力画面のボタンのラベル
        msg2:'',      // {string} - 入力欄の後に表示するメッセージ
        */
        rex:/^[0-9]{1,4}$/, // {RegExp} - 受付番号チェック用正規表現
      },
      loading: {
        element: null,
        zIndex: 2147483647,  // z-indexの最大値
      },
      passCode:{
        element: null, // {HTMLElement} - パスコード入力画面の要素。setWindowsで設定。
        value: null,  // {string} - パスコード
        dialog: `<p>確認のメールを送信しました。<br>
          記載されているパスコード(数字6桁)を入力してください。</p>
          <ol>
            <li>パスコードの有効期限は1時間です</li>
            <li>まれに迷惑メールと判定される場合があります。<br>メールが来ない場合、そちらもご確認ください。</li>
            <li>3回連続誤入力で1時間ロックアウトされます。</li>
          </ol>`,
        rex:/^[0-9]{6}$/, // {RegExp} - パスコードチェック用正規表現
      },
    }};
    console.log(v.whois+' start.');
    try {
      if( def !== null ){ // 2回目以降の呼出(再起呼出)
        // 再起呼出の場合、呼出元から渡された定義Objを使用
        v.def = def;
      }

      for( let key in v.def ){
        if( whichType(v.def[key]) !== 'Object' ){
          dest[key] = opt[key] || v.def[key]; // 配列はマージしない
        } else {
          if( !dest.hasOwnProperty(key) ) dest[key] = {};
          this.#setProperties(dest[key],v.def[key],opt[key]||{});
        }
      }

      if( def === null ){ // 初回呼出(非再帰)
        // 親画面のHTML要素を保存
        this.parentWindow = document.querySelector(this.parentSelector);
      }

      console.log(v.whois+' normal end.');
      return v.rv;
    } catch(e){
      v.msg = v.whois + ' abnormal end(step.'+v.step+').' + e.message;
      console.error(v.msg);
      return e;
    }
  }

  /** 秘密鍵・公開鍵を作成し、プロパティに格納する
   * @param {void}
   * @returns {void}
   */
  #setupKeys(){
    const v = {whois:'Auth.#setupKeys',rv:null};
    console.log(v.whois+' start.');
    try {
      // パスワード未指定なら作成
      if( this.RSA.passWord === null ){
        this.RSA.passWord = createPassword(this.RSA.pwLength);
      }

      // 鍵ペアの生成
      this.RSA.sKey = cryptico.generateRSAKey(this.RSA.passWord, this.RSA.bits);
      this.RSA.pKey = cryptico.publicKeyString(this.RSA.sKey);
      //console.log(this.RSA);

      console.log(v.whois+' normal end.');
      return v.rv;
    } catch(e){
      v.msg = v.whois + ' abnormal end(step.'+v.step+').' + e.message;
      console.error(v.msg);
      return e;
    }
  }

  /** Auth関係画面をセットする
   * @param {void} - 無し
   * @returns {void} 無し
   */
  #setWindows(){
    const v = {whois:'Auth.#setWindows',rv:null};
    console.log(v.whois+' start.');
    try {

      // dialog用のCSS定義を追加(getPassCodeと共通)
      v.style = createElement('style');
      document.head.appendChild(v.style);
      for( v.i=0 ; v.i<this.entryNo.css.length ; v.i++ ){
        v.x = this.entryNo.css[v.i];
        for( v.y in v.x.prop ){
          v.prop = v.x.sel+' { '+v.y+' : '+v.x.prop[v.y]+'; }\n';
          console.log(v.prop);
          v.style.sheet.insertRule(v.prop,
            v.style.sheet.cssRules.length,
          );
        }
      }

      // 受付番号入力画面
      this.entryNo.element = createElement({
        tag:'dialog',
        attr:{name:'entryNo',class:'Auth'},
        children:[
          {tag:'div',html:this.entryNo.dialog},
          {tag:'input',attr:{type:'text'}},
          {tag:'input',attr:{type:'button',value:'送信'}},
        ],
      });
      document.querySelector('body').prepend(this.entryNo.element);

      // パスコード入力画面
      this.passCode.element = createElement({
        tag:'dialog',
        attr:{name:'passCode',class:'Auth'},
        children:[
          {tag:'div',html:this.passCode.dialog},
          {tag:'input',attr:{type:'text'}},
          {tag:'input',attr:{type:'button',value:'送信'}},
        ],
      });
      document.querySelector('body').prepend(this.passCode.element);

      //console.log('v.rv='+JSON.stringify(v.rv));
      console.log(v.whois+' normal end.');
      return v.rv;
    } catch(e){
      console.error(v.whois+' abnormal end.',e,v);
      return (e);
    }

  }

  /** entryNo(ID)をダイアログに入力
   * @param {void}
   * @returns {void}
   * 
   * - Qiita [非同期な自作 confirm を作ってみた](https://qiita.com/naoki-funawatari/items/4de792bfefe5eab909cc)
   */
  #getEntryNo(){
    const v = {whois:'Auth.#getEntryNo'};
    console.log(v.whois+' start.');
    try {

      this.entryNo.element.showModal();

      return new Promise(resolve => {
        document.querySelector('dialog[name="entryNo"] input[type="button"]')
        .addEventListener('click',() => {
          this.entryNo.element.close();
          let rv = event.target.parentElement.querySelector('input[type="text"]').value;
          console.log('Auth.#getEntryNo normal end.',rv);
          resolve(rv);
        });
      });

    } catch(e){
      console.error(v.whois+' abnormal end.\n',e,v);
      return(e);
    }
  }

  /** メールから入力したpassCodeをダイアログに入力
   * @param {void}
   * @returns {void}
   */
  #getPassCode(){
    const v = {whois:'Auth.#getPassCode'};
    console.log(v.whois+' start.');
    try {
      this.passCode.element.showModal();

      return new Promise(resolve => {
        document.querySelector('dialog[name="passCode"] input[type="button"]')
        .addEventListener('click',() => {
          this.passCode.element.close();
          let rv = event.target.parentElement.querySelector('input[type="text"]').value;
          console.log('Auth.#getPassCode normal end.',rv);
          resolve(rv);
        });
      });
    } catch(e){
      console.error(v.whois+' abnormal end.\n',e,v);
      return(e);
    }
  }

  /** GASのAPI(doPost)を呼び出す
   * @param {string} to - 呼び先(gateway or front)
   * @param {string} func - 呼び先関数名(auth1A等)
   * @param {Object} data - 呼び先関数に渡すデータオブジェクト
   * @returns {Object} 呼び先からの戻り値
   * 
   * - JS: [Async/await](https://ja.javascript.info/async-await)
   * - MDN: [フェッチが成功したかの確認](https://developer.mozilla.org/ja/docs/Web/API/Fetch_API/Using_Fetch#%E3%83%95%E3%82%A7%E3%83%83%E3%83%81%E3%81%8C%E6%88%90%E5%8A%9F%E3%81%97%E3%81%9F%E3%81%8B%E3%81%AE%E7%A2%BA%E8%AA%8D)
   * - MDN: [fetch()](https://developer.mozilla.org/ja/docs/Web/API/fetch)
   * - MDN: [Response Object](https://developer.mozilla.org/ja/docs/Web/API/Response)
   * - Qiita: [Fetch APIでネットワークエラーも含めてエラーハンドリングする](https://qiita.com/IzumiSy/items/031df1df4f4541e536b4)
   */
  async fetch(fc,arg,md=0){
    const v = {whois:'Auth.fetch',rv:null,data:{cp:this.RSA.pKey}};
    console.log(v.whois+' start.');
    try {

      v.step = '1'; // 送信するトークンを生成
      v.token = {
        fm: this.entryNo.value,
        to: 'gateway',
        md: md,
        ts: Date.now(),
        dt: {
          fc: fc,
          arg: arg,
        }
      };

      v.step = '2'; // 暗号化・署名
      if( md === 1 ){ // 共通鍵で暗号化
        v.token.dt = encryptAES(
          JSON.stringify(v.token.dt),this.commonKey);
      } else if( md === 2 || md === 3 ){
        v.plaintext = JSON.stringify(v.token.dt);
        v.encode = encodeURI(v.plaintext);
        v.encrypt = md === 2  // 2:署名無し暗号化、3:署名付き暗号化
        ? cryptico.encrypt(v.encode,this.gateway.pKey)
        : cryptico.encrypt(v.encode,this.gateway.pKey,this.RSA.sKey);
        console.log('encrypt',v.encrypt);
        if( v.encrypt.status !== 'success' )
          throw new Error(JSON.stringify(v.encrypt));
        v.token.dt = v.encrypt.cipher;
      }

      v.step = '3'; // fetch
      v.fetch = await fetch(this.gateway.url,{
        "method": "POST",
        "body": JSON.stringify(v.token),
        "Accept": "application/json",
        "Content-Type": "application/json",
      });
      v.rv = await v.fetch.json();
      console.log(v.rv);
      if( v.rv instanceof Error ) throw v.rv;
      if( v.rv.isErr ){
        console.error(
          v.whois+' abnormal end.'
          + '\n' + v.rv.message
          + '\n' + v.rv.stack
        );
        alert(v.rv.message);
      }

      console.log(v.whois+' normal end.');
      return v.rv;
    } catch(e){
      console.error(v.whois+' abnormal end.',e,v);
      return e;
    }
  }

}
</script>
<script type="text/javascript">
/**
 * Array型の変数に2次元配列からHTMLの表を作成してtable要素として返すメソッドを追加する。
 * 
 * 使用前`Array.prototype.tabulize = Array.tabulize;`実行のこと。
 * 
 * @param {Object} [opt]
 * @param {string} opt.dateFormat {string} - 配列内のDateを表示する日時形式指定文字列(yMdhms.n)
 * @returns {HTMLTableObject}
 */

function Array_tabulize(opt){
 console.log('tabulize start.');
  const v = {
    table: document.createElement('table'),
    thead: document.createElement('thead'),
    tbody: document.createElement('tbody'),
    createElement: (tag,text='',opt={}) => {
      let rv = document.createElement(tag);
      rv.innerHTML = text;
      for( let x in opt ){
        rv.setAttribute(x,opt[x]);
      }
      return rv;
    },
  };
  console.log('tabulize end.');

  v.tr = v.createElement('tr');
  console.log(this[0]);
  for( v.i=0 ; v.i<this[0].length ; v.i++ ){
    v.tr.appendChild(v.createElement('th',this[0][v.i]));
  }
  v.thead.appendChild(v.tr);

  for( v.r=1 ; v.r<this.length ; v.r++ ){
    v.tr = v.createElement('tr');
    console.log(this[v.r]);
    for( v.c=0 ; v.c<this[v.r].length ; v.c++ ){
      v.raw = this[v.r][v.c];
      v.opt = {};
      switch( whichType(v.raw) ){
        case 'BigInt':
        case 'Number':
          v.text = Number(v.raw).toLocaleString();
          v.opt.style = 'text-align:right';
          break;
        case 'Date':
          v.text = v.raw.toLocale(opt.dateFormat);
        default:
          v.text = String(v.raw);
      }
      v.tr.appendChild(v.createElement('td',v.text,v.opt));
    }
    v.tbody.appendChild(v.tr);
  }

  v.table.appendChild(v.thead);
  v.table.appendChild(v.tbody);
  console.log(v.table)
  return v.table;
}
Array.prototype.tabulize = Array_tabulize;
</script>
<script type="text/javascript">/**
 * @classdesc 掲示板
 */
class BulletinBoard {
  /**
   * @constructor
   * @param {Object} opt - オプション
   * @returns {void}
   */
  constructor(opt){
    const v = {whois:'BulletinBoard.constructor',step:'0',rv:null};
    console.log(v.whois+' start.');
    try {

      v.step = '1'; // オプション未定義項目の既定値をプロパティにセット
      this.#setProperties(this,null,opt);
      this.parent.element = document.querySelector(this.parent.selector);

      v.step = '2'; // CSS定義を追加(getPassCodeと共通)
      v.style = createElement('style');
      document.head.appendChild(v.style);
      for( v.i=0 ; v.i<this.css.length ; v.i++ ){
        v.x = this.css[v.i];
        for( v.y in v.x.prop ){
          v.prop = this.parent.selector + ' ' + v.x.sel
            + ' { ' + v.y + ' : ' + v.x.prop[v.y] + '; }\n';
          v.style.sheet.insertRule(v.prop,
            v.style.sheet.cssRules.length,
          );
        }
      }

      v.step = '3'; // 新規のお知らせが来たら末尾を表示するよう設定
      // https://at.sachi-web.com/blog-entry-1516.html
      this.mo = new MutationObserver(() => {
        console.log('mutation detected');
        this.parent.element.scrollTop = this.parent.element.scrollHeight;
      });
      this.mo.observe(this.parent.element,{
        childList: true,
        attributes: true,
        characterData: true,
        subtree: true,//孫以降のノードの変化も検出
        attributeOldValue: true,//変化前の属性データを記録する
        characterDataOldValue: true,//変化前のテキストノードを記録する
        attributeFilter: [],//配列で記述した属性だけを見張る
      });

      v.step = '4'; // インターバルをセット
      this.start();

      console.log(v.whois+' normal end.',v.rv);
      return v.rv;
    } catch(e){
      console.error(v.whois+' abnormal end.',e,v);
      return e;
    }
  }

  /** 設定先のオブジェクトに起動時パラメータを優先して既定値を設定する
   * @param {Object} dest - 設定先のオブジェクト。初回呼出時はthis
   * @param {def} def - 既定値のオブジェクト。初回呼出時はnull(内部定義を使用)
   * @param {AuthOpt} opt - 起動時にオプションとして渡されたオブジェクト
   * @returns {void}
   */
  #setProperties(dest,def,opt){
    const v = {whois:'Reception.#setProperties',rv:true,def:{
      auth: null, // {Auth} 認証局他のAuthインスタンス
      parent: {
        selector: '',
        element: null,
      },
      interval: 60000,
      intervalId: null, // インターバルID
      posts: [],  // 投稿メッセージ一覧
      css: [
        {sel:'.date',prop:{
          'margin-top':'1rem',
          'padding-left': '1rem',
          'font-family': 'fantasy',
          'font-size': '1.5rem',
          'border-bottom': 'solid 4px #ddd'
        }},
        {sel:'.header',prop:{
          'margin-top': '1rem',
          'display': 'grid',
          'grid-template-columns': '3rem 1fr',
          'grid-gap': '0.5rem',
          'background-color': '#ddd',
          'padding-left': '0.5rem',
        }},
        {sel:'.fromto',prop:{
          'font-size': '0.8rem',
        }},
        {sel:'.time',prop:{
          'font-size': '0.8rem',
          'font-family': 'cursive',
        }},
        {sel:'.message',prop:{}},
      ],
    }};

    console.log(v.whois+' start.');
    try {
      if( def !== null ){ // 2回目以降の呼出(再起呼出)
        // 再起呼出の場合、呼出元から渡された定義Objを使用
        v.def = def;
      }

      for( let key in v.def ){
        if( whichType(v.def[key]) !== 'Object' ){
          dest[key] = opt[key] || v.def[key]; // 配列はマージしない
        } else {
          if( !dest.hasOwnProperty(key) ) dest[key] = {};
          this.#setProperties(dest[key],v.def[key],opt[key]||{});
        }
      }

      if( def === null ){ // 初回呼出(非再帰)
        // 親画面のHTML要素を保存
        this.parentWindow = document.querySelector(this.parentSelector);
      }

      //console.log(v.whois+' normal end.');
      return v.rv;
    } catch(e){
      v.msg = v.whois + ' abnormal end(step.'+v.step+').' + e.message;
      console.error(v.msg);
      return e;
    }
  }

  post(){
    const v = {whois:'BulletinBoard.constructor',step:'0',rv:null};
    console.log(v.whois+' start.');
    try {


      console.log(v.whois+' normal end.',v.rv);
      return v.rv;
    } catch(e){
      console.error(v.whois+' abnormal end.',e,v);
      return e;        
    }
  }

  /**
   * @param {void}
   * @returns 
   */
  delivery = async() => {
    const v = {whois:'BulletinBoard.delivery',step:'0',rv:null};
    console.log(v.whois+' start.');
    try {

      // Auth.fetchで認証局に問い合わせ
      console.log(this.auth);
      v.rv = await this.auth.fetch('delivery',{
        entryNo: this.auth.info.entryNo,
        publicKey: this.auth.RSA.pKey,
      },3);
      if( v.rv.isErr ){
        alert(v.rv.message);
        return null;
      }

      // 親領域に描画
      this.parent.element.innerHTML = '';
      // timestamp順にソート
      this.posts = v.rv.result;
      this.posts.sort((a,b) => a.timestamp < b.timestamp ? -1 : 1);
      console.log(this.posts);
      // 日付型に変更
      this.posts.forEach(x => x.timestamp = new Date(x.timestamp));

      v.lastDate = new Date('1900/1/1');
      this.posts.forEach(post => {
        if( post.timestamp.getFullYear() !== v.lastDate.getFullYear()
         || post.timestamp.getMonth()    !== v.lastDate.getMonth()
         || post.timestamp.getDate()     !== v.lastDate.getDate()
        ){
          // 投稿日が変わったら日付を表示
          this.parent.element.appendChild(createElement({
            attr: {class:'date'},
            text: new Intl.DateTimeFormat('en', { month: 'long'}).format(post.timestamp)
              + ' ' + ('00'+post.timestamp.getDate()).slice(-2)
              + ', ' + post.timestamp.getFullYear(),
          }));
          // 前行の日付を書き換え
          v.lastDate = post.timestamp;
        }
        // From / To
        this.parent.element.appendChild(createElement({
          attr: {class:'header'},
          children: [{
            attr: {class:'time'},
            text: ('0'+post.timestamp.getHours()).slice(-2) + ':' +
                  ('0'+post.timestamp.getMinutes()).slice(-2)
          },{
            attr: {class:'fromto'},
            text: post.from + ' ▶️ ' + post.to
          }],
        }));
        // メッセージ
        this.parent.element.appendChild(createElement({
          attr: {class:'message'},
          text: post.message,
        }));
      });
      console.log(v.whois+' normal end.',v.rv);
      return v.rv;
    } catch(e){
      console.error(v.whois+' abnormal end.',e,v);
      this.stop();
      return e;        
    }
  }

  start = () => {
    if( this.intervalId !== null ){
      this.stop();
    }
    this.intervalId = setInterval(this.delivery, this.interval);
  }

  stop = () => {
    clearInterval(this.intervalId);
    this.intervalId = null;
  }

  /** 設定内容の変更(主に時間間隔の修正を想定)
   * @param {Object} opt 
   * @returns {void}
   */
  change = (opt) => {
    this.#setProperties(this,null,opt);
    // 変更された内容でリスタート
    if( this.intervalId !== null ){
      this.stop();
      this.start();
    }
  }

}</script>
<script type="text/javascript">class BurgerMenu {

  constructor(opt={}){
    const v = {whois:'BurgerMenu.constructor',step:0,rv:null};
    console.log(v.whois+' start.');
    try {

      v.step = 1; // メンバの設定
      setupInstance(this,opt,{
        parent: 'body',   // 親要素のCSSセレクタ
        menu: null,       // メニュー全体のラッパー
        map: {},          // funcで指定された名称と実関数の紐付けマップ
        navi: null,       // ナビゲーション要素
        home: null,       // ホーム画面のID
        authority: 4294967295,  // 実行権限。既定値2^32-1
        css: [
          // 親要素(ラッパー) ---------------------
          {
            sel:'.BurgerMenu',
            prop: {
              '--text' : '#000',  // テキストおよびハンバーガーアイコンの線の色
              '--fore' : '#fff',
              '--back' : '#ddd',
              '--debug' : 'rgba(255,0,0,1)',
              '--height' : '50px',
              '--zIndex' : '2147483647',
              '--navWidth' : '0.7',
              'position' : 'absolute',
              'top' : '0',
              'right' : '0',
              'width' : '100vw',
              'height' : '100vh',
              'z-index' : 'var(--zIndex)',
            },
          },
          // ハンバーガーアイコン --------------------
          {
            sel:'.BurgerMenu .icon',
            prop: {
              'display' : 'flex',
              'justify-content' : 'flex-end',
              'place-items' : 'center',
            },
          },
          {
            sel:'.BurgerMenu .icon > button',
            prop: {
              'place-content' : 'center center',
              'display' : 'block',
              'margin' : 'calc(var(--height) * 0.4)',
              'padding' : '0px',
              'box-sizing' : 'border-box',
              'width' : 'calc(var(--height) * 0.7)',
              'height' : 'calc(var(--height) * 0.7)',
              'border' : 'none',
              'background' : 'rgba(0,0,0,0)',  // 透明
              'z-index' : '4', // navより上に
              'position' : 'relative', // 横棒の位置をtop/left指定可能に
              // 以下button標準無効化用
              'box-shadow' : 'none',
            },
          },
          {
            sel:'.BurgerMenu .icon button span',
            prop: {
              'display' : 'block',
              'width' : '100%',
              'height' : 'calc(var(--height) * 0.12)',
              'border-radius' : 'calc(var(--height) * 0.06)',
              'position' : 'absolute',
              'left' : '0',
              'background' : 'var(--text)',
              'transition' : 'top 0.24s, transform 0.24s, opacity 0.24s',
            },
          },
          {
            sel:'.BurgerMenu .icon button span:nth-child(1)',
            prop: {
            'top' : '0',
            },
          },
          {
            sel:'.BurgerMenu .icon button span:nth-child(2)',
            prop: {
              'top' : '50%',
              'transform' : 'translateY(-50%)',
            },
          },
          {
            sel:'.BurgerMenu .icon button span:nth-child(3)',
            prop: {
              'top' : '100%',
              'transform' : 'translateY(-100%)',
            },
          },
          {
            sel:'.BurgerMenu .icon button span.is_active:nth-child(1)',
            prop: {
              'top' : '50%',
              'transform' : 'translateY(-50%) rotate(135deg)',
            },
          },
          {
            sel:'.BurgerMenu .icon button span.is_active:nth-child(2)',
            prop: {
              'transform' : 'translate(50%, -50%)',
              'opacity' : '0',
            },
          },
          {
            sel:'.BurgerMenu .icon button span.is_active:nth-child(3)',
            prop: {
              'top' : '50%',
              'transform' : 'translateY(-50%) rotate(-135deg)',
            },
          },
          // ナビゲーション領域 ---------------------
          {
            sel:'.BurgerMenu nav',
            prop: {
              'display' : 'none',
            },
          },
          {
            sel:'.BurgerMenu nav.is_active',
            prop: {
              'display' : 'block',
              'margin' : '0 0 0 auto',
              'font-size' : '1rem',
              'width' : 'calc(100% * var(--navWidth))',
            },
          },
          {
            sel:'.BurgerMenu nav ul',
            prop: {
              'margin' : '0rem 0rem 1rem 0rem',
              'padding' : '0rem 0rem 0rem 0rem',
              'background-color' : 'var(--back)',
            },
          },
          { // 2階層以降のulにのみ適用
            sel:'.BurgerMenu nav ul ul',
            prop: {
              'display' : 'none',
            },
          },
          { // 2階層以降のulにのみ適用
            sel:'.BurgerMenu nav ul ul.is_open',
            prop: {
              'display' : 'block',
              'border-top' : 'solid 0.2rem var(--fore)',
              'border-left' : 'solid 0.7rem var(--fore)',
            },
          },
          {
            sel:'.BurgerMenu nav li',
            prop: {
              'margin' : '0.3rem 0rem 0.3rem 0.5rem',
              'padding' : '0.2rem 0rem 0rem 0rem',
              'list-style' : 'none',
              'background-color' : 'var(--back)',
            },
          },
          {
            sel:'.BurgerMenu nav li a',
            prop: {
              'color' : 'var(--text)',
              'text-decoration' : 'none',
            },
          },
        ],
      });

      v.step = 2; // ラッパーおよび必須要素の作成
      this.menu = createElement({
        attr:{class:'BurgerMenu'},
        children:[{
          attr:{class:'icon'},
          event:{click:this.toggle},
          children:[{
            tag:'button',
            children:[
              {tag:'span'},{tag:'span'},{tag:'span'}
            ]
          }]
        }]
      });
      this.navi = createElement({tag:'nav'}); // nav
      this.menu.appendChild(this.navi);
      this.parent.element.appendChild(this.menu);

      v.step = 3; // 親要素を走査してナビゲーションを作成
      this.#genNavi();

      v.step = 4; // ホーム画面表示
      this.change(this.home);

      console.log(v.whois+' normal end.',v.rv);
      return v.rv;

    } catch(e){
      console.error(v.whois+' abnormal end(step.'+v.step+').',e,v);
      return e;
    }
  }

  /** 親要素を走査してナビゲーションを作成
   * @param {*} parent
   * @param {*} navi
   * @returns
   */
  #genNavi = (parent=this.parent.element,navi=this.navi) => {
    const v = {whois:'BurgerMenu.#genNavi',step:0,rv:null,idnum:1000,
      tree:(parent,navi) => { // メニューのツリーを作成
        for( let i=0 ; i<parent.childElementCount ; i++ ){
          v.step = 1; // 子要素を順次走査
          let d = parent.children[i];
          let attr = d.getAttribute('data-BurgerMenu');
          if( attr ){
            // data-BurgerMenuをもつ要素のみ以下の処理を実施

            v.step = 2; // IDを採番、クラスに保存
            v.id = 'c'+String(++v.idnum);
            d.classList.add(v.id);

            v.step = 3; // data-BurgerMenuの文字列をオブジェクト化
            let obj = (new Function('return {'+attr+'}'))();

            v.step = 4; // 実行権限がない機能・画面はナビに追加しない
            if( obj.hasOwnProperty('authority')
             && (this.authority & Number(obj.authority)) === 0 ){
              continue;
            }

            v.step = 5; // 1階層上のliタグがまだulを持っていなければ追加しておく
            let ul = navi.querySelector('ul');
            if( ul === null ){
              ul = createElement('ul');
              navi.appendChild(ul);
            }

            v.step = 6; // 1階層上のliが持つulに追加登録
            let li = null;
            if( obj.hasOwnProperty('href') ){
              v.step = 6.1;
              // 他サイトへの遷移指定の場合
              li = createElement({tag:'li',children:[{
                tag:'a',
                text: obj.label,
                attr:{name:obj.func,href:obj.href,target:'_blank'},
                event:{click:this.toggle},  // 遷移後メニューを閉じる
              }]});
            } else if( obj.hasOwnProperty('func') ){
              v.step = 6.2;
              // 指定関数実行の場合
              li = createElement({tag:'li',children:[{
                tag:'a',
                text: obj.label,
                attr: {name:obj.func},
                event:{click:this.dispatch}
              }]});
            } else {
              v.step = 6.3;
              // 指定画面表示のリーフ or 子階層を持つブランチ
              // 暫定的に前者とみなし、全部作成後に子階層有無で修正
              v.step = 2.6;
              li = createElement({tag:'li',children:[{
                tag:'a',
                text: obj.label,
                // 暫定とわかるよう、nameには'_'をつける
                attr: {name:'_'+v.id},
                //event:{click:this.change},
              }]});
            }

            v.step = 7; // ulに自分を追加後、自分を親として再帰呼出
            ul.appendChild(li);
            v.tree(d,li);
          }
        }
      },
      branch: (li) => {  // tree内のブランチはshowChildrenに変更
        v.step = 10; // 自分自身がブランチかを判定
        // 「子要素としてul(下位階層)を持つ ⇒ ブランチ」
        // 尚「自分はulを持たないが子孫はulを持つ」は有り得ない。
        // ∵子はulが無いと保持できない
        let ul = li.querySelector(':scope > ul');
        let a = li.querySelector(':scope > a');

        if( ul ){
          v.step = 11;
          // ulを持つ ⇒ 子孫あり ⇒ ブランチ
          a.innerText = '▶︎' + a.innerText;
          a.addEventListener('click',this.showChildren);
          // 子要素にもブランチがないか再帰呼出
          // ※直下の要素のみ対象なので':scope >'を付加
          ul.querySelectorAll(':scope > li').forEach(x => v.branch(x));
        } else {
          v.step = 12;
          console.log(a);
          let m = a.getAttribute('name').match(/^_(.+)$/);
          if( m ){
            v.step = 13;
            // getNavi.treeで「暫定」と判別されていたリーフの場合。
            // ※暫定では無い場合は処理不要(=遷移指定/指定関数実行)

            // ulを持たない ⇒ 子孫なし ⇒ リーフ
            a.addEventListener('click',this.change);
            a.setAttribute('name',m[1]);
            if( this.home === null ){
              v.step = 14;
              // ホーム画面未定の場合、最初のリーフとする
              this.home = a.getAttribute('name');
            }
          }
        }
      },
    };
    console.log(v.whois+'start.');
    try {

      // とりあえずツリー全体を作成
      v.tree(parent,navi);

      // ブランチを検出し、イベントを設定
      this.menu.querySelectorAll('nav > ul > li')
      .forEach(x => v.branch(x));

      console.log(v.whois+' normal end.',v.rv);
      return v.rv;

    } catch(e){
      console.error(v.whois+' abnormal end(step.'+v.step+').',e,v);
      return e;
    }
  }

  /** 表示画面の変更 */
  change = (event) => {
    const v = {whois:'BurgerMenu.change',step:0,rv:null,
      showElement: (d) => { // 対象領域を表示
        d.style.display = '';
        if( d.parentElement.tagName.toLowerCase() !== 'body' )
          v.showElement(d.parentElement);
      },
    };
    console.log(v.whois+' start.');
    try {
      console.log(event,typeof event);

      // data-BurgerMenu属性を持つ要素を全て非表示に
      v.selector = '[data-BurgerMenu]';
      this.parent.element.querySelectorAll(v.selector)
      .forEach(x => x.style.display = 'none');

      // 対象領域を特定
      v.selector = '.'
      + (typeof event === 'string' ? event : event.target.name)
      + v.selector;
      v.target = this.parent.element.querySelector(v.selector);
      // 対象領域〜body迄を表示
      v.showElement(v.target);

      // ナビゲーションを非表示
      if( typeof event !== 'string' ){
        this.toggle();
      }

      console.log(v.whois+' normal end.',v.rv);
      return v.rv;

    } catch(e){
      console.error(v.whois+' abnormal end(step.'+v.step+').',e,v);
      return e;
    }
  }

  /** 選択された関数の実行
   * @param {PointerEvent} event - ナビ領域で発生したイベントオブジェクト
   */
  dispatch = (event) => {
    const v = {whois:'BurgerMenu.dispatch',step:0,rv:null};
    console.log(v.whois+' start.');
    try {
      console.log(event);

      // 選択された関数名を取得
      v.funcName = event.target.getAttribute('name');
      console.log('v.funcName='+v.funcName);

      // 選択された関数を実行
      console.log(this.map);
      this.map[v.funcName]();

      // ナビゲーションを非表示
      this.toggle();

      console.log(v.whois+' normal end.',v.rv);
      return v.rv;

    } catch(e){
      console.error(v.whois+' abnormal end(step.'+v.step+').',e,v);
      return e;
    }
  }

  /** ナビゲーション領域の表示/非表示切り替え
   * @param {void}
   * @returns {void}
   */
  toggle = () => {
    const v = {whois:'BurgerMenu.toggle',step:0,rv:null};
    console.log(v.whois+' start.');
    try {
      document.querySelector('.BurgerMenu nav').classList.toggle('is_active');
      document.querySelectorAll('.BurgerMenu button span')
      .forEach(x => x.classList.toggle('is_active'));

      console.log(v.whois+' normal end.',v.rv);
      return v.rv;

    } catch(e){
      console.error(v.whois+' abnormal end(step.'+v.step+').',e,v);
      return e;
    }
  }

  /** ブランチの下位階層メニュー表示/非表示切り替え */
  showChildren = (event) => {
    const v = {whois:'BurgerMenu.showChildren',step:0,rv:null};
    console.log(v.whois+' start.');
    try {
      console.log(event.target);
      event.target.parentNode.querySelector('ul').classList.toggle('is_open');
      let m = event.target.innerText.match(/^([▶️▼])(.+)/);
      console.log(m);
      const text = ((m[1] === '▼') ? '▶️' : '▼') + m[2];
      console.log(m[1],m[1] === '▼',text);
      event.target.innerText = text;

      console.log(v.whois+' normal end.',v.rv);
      return v.rv;

    } catch(e){
      console.error(v.whois+' abnormal end(step.'+v.step+').',e,v);
      return e;
    }
  }
}</script>
<script type="text/javascript">/* コアスクリプト */
/**
 * @typedef {Object} createElementDef
 * @prop {string} tag='div' - タグ名
 * @prop {Object.<string,string>} [attr] - タグに設定する属性。ex.attr:{name:'hoge'}
 * @prop {Object.<string,boolean>} [logical] - 論理属性(ex.disabled)。trueなら追加
 * @prop {Object.<string,string>} [style] - 〃スタイル。ex.style:{display:'none'}
 * @prop {Object.<string,string>} [event] - 〃イベント。ex.event:{onclick:()=>{〜}}
 * @prop {string} [text] - タグ内にセットする文字列
 * @prop {string} [html] - タグ内にセットするhtml文字列
 * @prop {createElementDef[]} [children] - 子要素の配列
 */

/**
 * HTMLの要素を生成
 * @param {createElementDef|string} arg - 生成する要素の定義
 * @returns {HTMLElement} 生成された要素
 */
function createElement(arg={}){
  const v = {rv:null,arg:{}};
  //console.log('createElement start.');

  // 既定値の設定
  v.arg = mergeDeeply(
    {tag: 'div',attr: {},style:{},event:{},text: '',html:'',children:[]},
    (typeof arg === 'string' ? {tag:arg} : arg));
  //console.log(v.arg);

  v.rv = document.createElement(v.arg.tag);
  for( v.i in v.arg.attr ){ // 属性の設定
    v.rv.setAttribute(v.i,v.x = v.arg.attr[v.i]);
  }
  for( v.i in v.arg.logical ){  // 論理属性の設定
    if( v.arg.logical[v.i] ){
      v.rv.setAttribute(v.i,true);
    }
  }
  for( v.i in v.arg.style ){ // スタイルの設定
    if( v.i.match(/^\-\-/) ){ // CSS変数の場合
      v.rv.style.setProperty(v.i,v.arg.style[v.i]);
    } else {
      v.rv.style[v.i] = v.arg.style[v.i];
    }
    //console.log(v.i,v.arg.style[v.i],v.rv.style);
  }
  for( v.i in v.arg.event ){ // イベントの設定
    v.rv.addEventListener(v.i,v.arg.event[v.i]);
    //console.log(v.i,v.arg.event[v.i],v.rv);
  }
  if( v.arg.html.length > 0 ){
    v.rv.innerHTML = v.arg.html;
  } else {
    v.rv.innerText = v.arg.text;  // 内部文字列
  }
  for( v.i=0 ; v.i<v.arg.children.length ; v.i++ ){
    // 子要素の追加
    v.rv.appendChild(createElement(v.arg.children[v.i]));
  }
  //console.log('createElement end.',v.rv);
  return v.rv;
}
</script>
<script type="text/javascript">/* コアスクリプト */
/** createPassword: パスワード文字列の生成
 * @desc シングル/ダブルクォーテーションはJavaScript上文字列として扱う際にエスケープが必要になるので除外
 * @param {number} [len=16] - パスワードの文字長
 * @param {boolean} [opt.lower=true] - 小文字を使用するならtrue 
 * @param {boolean} [opt.upper=true] - 大文字を使用するならtrue 
 * @param {boolean} [opt.symbol=true] - 記号を使用するならtrue 
 * @param {boolean} [opt.numeric=true] - 数字を使用するならtrue 
 * @returns {string} 生成されたパスワード文字列
 */
 function createPassword(len=16,opt={lower:true,upper:true,symbol:true,numeric:true}){
  const v = {
    whois: 'createPassword',
    lower: 'abcdefghijklmnopqrstuvwxyz',
    upper: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
    symbol: '!#$%&()=~|@[];:+-*<>?_>.,', // クォーテーションは除外
    numeric: '0123456789',
    base: '',
    rv: '',
  }
  try {
    Object.keys(opt).forEach(x => {
      if( opt[x] ) v.base += v[x];
    });
    for( v.i=0 ; v.i<len ; v.i++ ){
      v.rv += v.base.charAt(Math.floor(Math.random() * v.base.length));
    }
  } catch(e) {
    console.error(v.whois+' abnormal end.\n'+e.stack+'\n'+JSON.stringify(v));
    v.rv = e;
  } finally {
    return v.rv;
  }
}
</script>
<script type="text/javascript">/* コアScript */
/**
 * @typedef {Object} encryptAES
 * @prop {string} salt - ソルト
 * @prop {string} iv - 初期ベクトル
 * @prop {string} encrypted - 暗号化された文字列
 */

/** 共通鍵(AES)による暗号化処理
 * @param {string} text - 暗号化対象の文字列
 * @param {string} pass - パスワード
 * @returns {encryptAES}
 * 
 * - [JavaScript AES暗号・復号](https://chigusa-web.com/blog/js-aes/)
 */
function encryptAES(text, pass) {
  // ソルト
  const salt = CryptoJS.lib.WordArray.random(128 / 8);

  // 初期ベクトル
  const iv = CryptoJS.lib.WordArray.random(128 / 8);

  // AESキーの生成(128bit、5万回)
  const key = CryptoJS.PBKDF2(pass, salt, {
    keySize: 128 / 32,
    iterations: 50000,
    hasher: CryptoJS.algo.SHA256,
  });

  // AESキーで暗号化
  const encrypted = CryptoJS.AES.encrypt(text, key, {
    iv: iv,
  });

  return {
    salt: salt,
    iv: iv,
    encrypted: encrypted,
  };
}

/** 共通鍵(AES)による復号化処理
 * @param {encryptAES} encryptedData - 暗号化の際の出力結果
 * @param {string} pass - パスワード
 * @returns {string} 復号された文字列
 */
function decryptAES(encryptedData, pass) {
  // AESキーの生成(128bit、5万回)
  const key = CryptoJS.PBKDF2(pass, encryptedData.salt, {
    keySize: 128 / 32,
    iterations: 50000,
    hasher: CryptoJS.algo.SHA256,
  });

  // AESキーで復号
  const decrypted = CryptoJS.AES.decrypt(encryptedData.encrypted, key, {
    iv: encryptedData.iv,
  });

  return decrypted.toString(CryptoJS.enc.Utf8);
}
</script>
<script type="text/javascript">
/** 日時を指定形式の文字列にして返す"toLocale()"メソッドをDate型に追加する。
 * @param {string} [format='yyyy/MM/dd'] - 日時を指定する文字列。年:y,月:M,日:d,時:h,分:m,秒:s,ミリ秒:n
 * @returns {string} 指定形式に変換された文字列。無効な日付なら長さ0の文字列
 * 
 * @example
 * ```
 * "1965/9/5"[yy/MM/dd hh:mm:ss.nnn] ⇒ "65/09/05 00:00:00.000"
 * "1965/9/5"[yyyy-MM-dd] ⇒ "1965-09-05"
 * "1965/9/5"[hh:mm] ⇒ "00:00"
 * "1977-03-04"[yy/MM/dd hh:mm:ss.nnn] ⇒ "77/03/04 09:00:00.000"
 * "1977-03-04"[yyyy-MM-dd] ⇒ "1977-03-04"
 * "1977-03-04"[hh:mm] ⇒ "09:00"
 * 1688189258262[yy/MM/dd hh:mm:ss.nnn] ⇒ "23/07/01 14:27:38.262"
 * 1688189258262[yyyy-MM-dd] ⇒ "2023-07-01"
 * 1688189258262[hh:mm] ⇒ "14:27"
 * "Sat Jul 01 2023 14:16:30 GMT+0900"[yy/MM/dd hh:mm:ss.nnn] ⇒ "23/07/01 14:16:30.000"
 * "Sat Jul 01 2023 14:16:30 GMT+0900"[yyyy-MM-dd] ⇒ "2023-07-01"
 * "Sat Jul 01 2023 14:16:30 GMT+0900"[hh:mm] ⇒ "14:16"
 * "12:34"[yy/MM/dd hh:mm:ss.nnn] ⇒ ""
 * "12:34"[yyyy-MM-dd] ⇒ ""
 * "12:34"[hh:mm] ⇒ ""
 * ```
 */

function Date_toLocale(format='yyyy/MM/dd'){
  //console.log('===== Date.toLocale start.');
  const v = {rv:format};
  try {

    // 無効な日付なら空文字列を返して終了
    if( isNaN(this.getTime()) ) return '';

    v.l = { // 地方時ベース
      y: this.getFullYear(),
      M: this.getMonth()+1,
      d: this.getDate(),
      h: this.getHours(),
      m: this.getMinutes(),
      s: this.getSeconds(),
      n: this.getMilliseconds()
    };

    //v.rv = typeof format === 'undefined' ? 'yyyy/MM/dd' : format;
    for( v.x in v.l ){
      v.m = v.rv.match(new RegExp(v.x+'+'));
      if( v.m ){
        v.str = v.m[0].length > 1
          ? ('000'+v.l[v.x]).slice(-v.m[0].length)
          : String(v.l[v.x]);
        v.rv = v.rv.replace(v.m[0],v.str);
      }
    }

    //console.log('v.rv='+JSON.stringify(v.rv));
    //console.log('===== Date.toLocale end.');
    return v.rv;
  } catch(e){
    // ブラウザで実行する場合はアラート表示
    if( typeof window !== 'undefined' ) alert(e.stack); 
    //throw e; //以降の処理を全て停止
    v.rv.stack = e.stack; return v.rv; // 処理継続
  }
}
Date.prototype.toLocale = Date_toLocale;
</script>
<script type="text/javascript">
/**
 * @desc オブジェクトのプロパティを再帰的にマージ
 * - Qiita [JavaScriptでオブジェクトをマージ（結合）する方法、JSONのマージをする方法](https://qiita.com/riversun/items/60307d58f9b2f461082a)
 * 
 * @param {Object} target - 結合対象のオブジェクト1
 * @param {Object} source - 結合対象のオブジェクト2。同名のプロパティはこちらで上書き
 * @param {Object} opts - オプション
 * @param {boolean} [opts.concatArray=false] - プロパティの値が配列だった場合、結合するならtrue
 * @returns {Object} 結合されたオブジェクト
 */

function mergeDeeply(target, source, opts) {
  const isObject = obj => obj && typeof obj === 'object' && !Array.isArray(obj);
  const isConcatArray = opts && opts.concatArray;
  let result = Object.assign({}, target);
  if (isObject(target) && isObject(source)) {
    for (const [sourceKey, sourceValue] of Object.entries(source)) {
      const targetValue = target[sourceKey];
      if (isConcatArray && Array.isArray(sourceValue) && Array.isArray(targetValue)) {
        result[sourceKey] = targetValue.concat(...sourceValue);
      }
      else if (isObject(sourceValue) && target.hasOwnProperty(sourceKey)) {
        result[sourceKey] = mergeDeeply(targetValue, sourceValue, opts);
      }
      else {
        Object.assign(result, {[sourceKey]: sourceValue});
      }
    }
  }
  return result;
}
</script>
<script type="text/javascript">/** QRコードをスキャン
 * @param {string} parent - 親要素のCSSセレクタ
 * @param {Object} [opt={}] - オプション
 * @param {number} opt.size - ファインダ領域のサイズ
 * @param {number} opt.interval=300 - 撮像間隔。ミリ秒
 * @param {number} opt.max=90000 - 最大待機時間。単位：ミリ秒
 * @returns {string} スキャンしたQRコードの文字列
 * 
 * - Qiita [html＋javascriptだけで実装したシンプルなQRコードリーダー](https://qiita.com/murasuke/items/c16e4f15ac4436ed2744)
 * - [Promiseでsleep機能を作る](https://www.sejuku.net/blog/24629#index_id5)
 * 
 * @typedef scanQRopt
 * @prop {number} [size=500] - ファインダのサイズ
 */
async function scanQR(parent,opt={}){
  const v = {whois:'scanQR',rv:null,
    constraints:{
      audio: false,
      video: {
        facingMode: 'environment',
        //width: opt.size || 500,
        //height: opt.size || 500,
      },
    },
    max: opt.max || 90000, // 最大待機時間。単位：ミリ秒
    interval: opt.interval || 300, // 撮像間隔。ミリ秒
    minSize : opt.minSize || 640, // 最小撮像サイズ。px
    sleep: (sec) =>  // 指定時間待機
      {return new Promise(resolve => setTimeout(resolve,sec))},
  };
  console.log(v.whois+' start.');
  try {

    // ファインダ領域の作成
    v.step = '1.1'; // 親要素の高さを最大に
    v.parent = document.querySelector(parent);
    v.parent.style.width = v.parent.style.height = '100%';
    v.step = '1.2'; // 撮像領域を親要素の幅・高さ、いずれか小さい方の正方形に設定
    if( opt.hasOwnProperty('size') ){
      v.ps = opt.size;
    } else {
      v.pw = v.parent.clientWidth;
      v.ph = v.parent.clientHeight;
      if( v.pw < v.ph ){
        v.ps = v.pw < v.minSize ? v.minSize : v.pw;
        v.parent.style.height = v.ps + 'px';
      } else {
        v.ps = v.ph < v.minSize ? v.minSize : v.ph;
        v.parent.style.width = v.ps + 'px';
      }
    }
    v.constraints.video.width = v.constraints.video.height = v.ps;
    v.step = '1.3'; // video要素の生成
    v.video = createElement({tag:'video',style:{margin:'auto'}});
    v.parent.append(v.video);

    v.step = '2';
    const stream = await navigator.mediaDevices.getUserMedia(v.constraints);
    v.video.srcObject = stream;
    v.video.play();

    v.step = '3';
    const { width, height } = v.constraints.video;
    v.canvas = new OffscreenCanvas(width, height);
    const context = v.canvas.getContext('2d');

    v.step = '4'; // 定期的にスキャン実行
    v.cnt = 0;
    do {
      context.drawImage(v.video, 0, 0, width, height);
      const imageData = context.getImageData(0, 0, width, height);
      const code = jsQR(imageData.data, imageData.width, imageData.height);
      if (code) {
        console.log(code);
        v.rv = code.data;
      }
      await v.sleep(v.interval);
      console.log(v.cnt);
      v.cnt += v.interval;
    } while( v.rv === null && v.cnt < v.max );

    // 終了処理
    v.video.srcObject.getVideoTracks().forEach((track) => {
      track.stop();
    });
    v.parent.innerHTML = ''; // 作業用DIVを除去

    console.log(v.whois+' normal end.\n'+v.rv);
    return v.rv;

  } catch(error) {
    console.error(v.whois+' abnormal end.',error,v);
    return error;
  }
};</script>
<script type="text/javascript">/** constructor共通の初期処理として①オプション・既定値をメンバに設定、②wrapper(parent)要素取得、③スタイルシート作成を行う
 * @param {Object} dest - 設定先のオブジェクト。初回呼出時はthis
 * @param {Object} opt - 起動時にオプションとして渡されたオブジェクト
 * @param {Object} def - 既定値のオブジェクト。初回呼出時はnull(内部定義を使用)
 * @param {number} [depth=0] - 再起呼出時の階層。開始・終了メッセージ制御用なので指定不要
 * @returns {void}
 * 
 * ## 使用方法
 * 
 * 1. 主にclass内constructorで冒頭に使用することを想定。
 * 1. 第一階層にメンバ"css"が存在すると、新規styleを生成
 * 1. 第一階層にメンバ"parent"が存在する場合、
 *    - 文字列型ならCSSセレクタと解して`parent:{selector:(string),element:(HTMLElement)}`を生成
 *    - HTMLElement型ならそのまま`parent:(HTMLElement)}`として設定
 * 
 * ### 入力例
 * 
 * ```
 * const menu = new BurgerMenu({parent:'body',auth:confObj,fuga:{a:10}})
 * 
 * class BurgerMenu {
 *   constructor(opt){
 *     setupInstance(
 *       this,  // 第一引数はthis(固定)
 *       opt,   // 第二引数はconstructorに渡されたオプション
 *       {      // 第三引数は既定値のオブジェクト
 *         css: [  // このクラスに適用するCSS定義の配列
 *           {
 *             sel:'.date', // CSSセレクタ
 *             prop:{       // 設定する値。ラベル・値ともクォーテーションで囲む
 *               'margin-top':'1rem',
 *               'padding-left': '1rem',
 *             }
 *           },
 *         ],
 *         parent: '',  // 親要素のCSSセレクタ or HTMLElementの既定値
 *         auth: null,
 *         hoge: 'Hello World',
 *         fuga: {
 *           a: null,
 *           b: 20,
 *         },
 *       });
 *     // 以降、constructorの処理
 * ```
 * 
 * ### 出力例
 * 
 * ```
 * this = {
 *   parent: {
 *     selector: 'body',  // optより導出
 *     element : (body element),  // optより導出
 *   },
 *   auth: confObj, // optの値を設定
 *   hoge: 'Hello World',  // 既定値を設定
 *   fuga: {
 *     a:10,  // optの値を設定
 *     b:20,  // 既定値を設定
 *   },
 * }
 * ```
 * 
 * ```
 * <style type="text/css">
 * .date {
 *   margin-top: 1rem;
 *   padding-left: 1rem;
 * }
 * </style>
 * ```
 * 
 */
const setupInstance = (dest,opt,def) => {
  const v = {whois:'setupInstance',rv:true,step:0};

  console.log(v.whois+' start.');
  try {

    v.step = 1; // ディープコピー。但し配列は置換
    v.merged = mergeDeeply(def,opt);
    for( let key in v.merged ){
      dest[key] = v.merged[key];
    }

    v.step = 2; // parentの処理
    if( dest.hasOwnProperty('parent') ){
      if( typeof dest.parent === 'string' ){
        // CSSセレクタだった場合
        v.parent = dest.parent;
        dest.parent = {
          selector: v.parent,
          element : document.querySelector(v.parent),
        };
      }
    }

    v.step = 3; // CSS定義に基づき新たなstyleを生成
    if( dest.hasOwnProperty('css') ){
      v.style = document.createElement('style');
      document.head.appendChild(v.style);
      for( v.i=0 ; v.i<dest.css.length ; v.i++ ){
        v.x = dest.css[v.i];
        for( v.y in v.x.prop ){
          v.prop = dest.parent.selector + ' ' + v.x.sel
            + ' { ' + v.y + ' : ' + v.x.prop[v.y] + '; }\n';
          v.style.sheet.insertRule(v.prop,
            v.style.sheet.cssRules.length,
          );
        }
      }
    }

    console.log(v.whois+' normal end.');
    return v.rv;
  } catch(e){
    console.error(v.whois+' abnormal end(step.'+v.step+').',e,v);
    return e;
  }
}</script>
<script type="text/javascript">/**
 * @classdesc タブ切り替えのHTMLページを作成する
 */
class Reception {
  /**
   * @constructor
   * @param {Auth} auth - 認証局他のAuthインスタンス
   * @param {Object} area - 表示領域に関する定義
   * @param {string} area.selector - CSSセレクタ
   * @param {Object} boot - スキャナ起動のトリガーとなる要素に関する定義
   * @param {string} boot.selector - CSSセレクタ
   * @param {Object} loading - 待機画面
   * @param {string} loading.selector - CSSセレクタ
   * @returns {void}
   */
  constructor(opt){
    const v = {whois:'Reception.constructor',step:'0',rv:null};
    console.log(v.whois+' start.');
    try {

      v.step = '1'; // オプション未定義項目の既定値をプロパティにセット
      this.#setProperties(this,null,opt);
      this.area.element = document.querySelector(this.area.selector);
      this.boot.element = document.querySelector(this.boot.selector);
      this.loading.element = document.querySelector(this.loading.selector);
      console.log('step.'+v.step+' : ',this.area,this.boot,this.loading);

      v.step = '2'; // 入力・検索・編集画面の生成
      this.#setWindows();
      console.log('step.'+v.step+' : ',this.area.element);

      v.step = '3'; // スキャナ起動イベントの定義(「受付」タグのクリック)
      this.boot.element.addEventListener('click',this.bootScanner);

      console.log(v.whois+' normal end.',v.rv);
      return v.rv;
    } catch(e){
      console.error(v.whois+' abnormal end.',e,v);
      return e;        
    }
  }

  /** 設定先のオブジェクトに起動時パラメータを優先して既定値を設定する
   * @param {Object} dest - 設定先のオブジェクト。初回呼出時はthis
   * @param {def} def - 既定値のオブジェクト。初回呼出時はnull(内部定義を使用)
   * @param {AuthOpt} opt - 起動時にオプションとして渡されたオブジェクト
   * @returns {void}
   */
  #setProperties(dest,def,opt){
    const v = {whois:'Reception.#setProperties',rv:true,def:{
      auth: null, // {Auth} 認証局他のAuthインスタンス
      area:{  // 表示領域となる要素
        selector: '',     // {string} CSSセレクタ
        element : null,   // {HTMLElement} 要素本体
        design  : {},     // {Object} createElementに渡す定義
      },
      boot:{  // 受付タグ等、スキャナ起動のトリガーとなる要素
        selector: '',     // {string} CSSセレクタ
        element : null,   // {HTMLElement} 要素本体
      },
      loading:{  // 待機画面
        selector: '',     // {string} CSSセレクタ
        element : null,   // {HTMLElement} 要素本体
      },
      entry: {  // 入力画面(スキャナ＋氏名)
        element: null,   // {HTMLElement} 要素本体
      },
      list: {   // 複数候補選択画面
        element: null,   // {HTMLElement} 要素本体
        table: null,     // {HTMLElement} 選択画面のテーブル部
        candidates: [],  // {Object[]} 候補となった参加者情報の配列
      },
      edit: {   // 編集画面(ダイアログ)
        element: null,   // {HTMLElement} 要素本体
        table: null,     // {HTMLElement} 編集画面のテーブル部
        details: null,   // {HTMLElement} 編集画面の詳細情報部
        css: [
          {sel:'dialog.Reception',prop:{
            'margin':'auto',
            'padding': '1rem',
          }},
          {sel:'dialog.Reception::backdrop',prop:{
            'background-color': 'rgba(127,127,127,0.8)',
          }},
          {sel:'dialog.Reception [name="table"]',prop:{
            'display': 'grid',
            'grid-template-columns': '2fr 10fr 8fr 6fr',
            'grid-gap': '0.2rem',
          }},
          {sel:'dialog.Reception input[type="button"]',prop:{
            'margin': '0.5rem 1rem',
            'font-size': '1.5rem',
            'padding': '0.2rem 1rem',
          }},
          {sel:'dialog.Reception ruby rt',prop:{
            'font-size': '0.6rem',
          }},
          {sel:'dialog.Reception [name="details"]',prop:{
            'display': 'grid',
            'grid-template-columns': '1fr 3fr',
            'grid-gap': '0.2rem',
            'overflow-wrap': 'anywhere',
          }},
          {sel:'dialog.Reception sub',prop:{
            'font-size': '0.7rem',
          }},
          {sel:'dialog.Reception [name="details"] [name="memo"]',prop:{
            'width': '95%',
            'height': '5rem',
          }},
          // 複数候補者一覧(list)用
          {sel:'dialog.Reception[name="list"] [name="table"]',prop:{
            'display': 'grid',
            'grid-template-columns': '8rem 1fr',
            'grid-gap': '0.2rem',
          }},
        ],    
      },
    }};

    console.log(v.whois+' start.');
    try {
      if( def !== null ){ // 2回目以降の呼出(再起呼出)
        // 再起呼出の場合、呼出元から渡された定義Objを使用
        v.def = def;
      }

      for( let key in v.def ){
        if( whichType(v.def[key]) !== 'Object' ){
          dest[key] = opt[key] || v.def[key]; // 配列はマージしない
        } else {
          if( !dest.hasOwnProperty(key) ) dest[key] = {};
          this.#setProperties(dest[key],v.def[key],opt[key]||{});
        }
      }

      if( def === null ){ // 初回呼出(非再帰)
        // 親画面のHTML要素を保存
        this.parentWindow = document.querySelector(this.parentSelector);
      }

      //console.log(v.whois+' normal end.');
      return v.rv;
    } catch(e){
      v.msg = v.whois + ' abnormal end(step.'+v.step+').' + e.message;
      console.error(v.msg);
      return e;
    }
  }

  /** Reception関係画面をセットする
   * @param {void} - 無し
   * @returns {void} 無し
   */
  #setWindows(){
    const v = {whois:'Reception.#setWindows',rv:null,step:'0'};
    console.log(v.whois+' start.');
    try {
  
      v.step = 1; // dialog用のCSS定義を追加(getPassCodeと共通)
      v.style = createElement('style');
      document.head.appendChild(v.style);
      for( v.i=0 ; v.i<this.edit.css.length ; v.i++ ){
        v.x = this.edit.css[v.i];
        for( v.y in v.x.prop ){
          v.prop = v.x.sel+' { '+v.y+' : '+v.x.prop[v.y]+'; }\n';
          console.log(v.prop);
          v.style.sheet.insertRule(v.prop,
            v.style.sheet.cssRules.length,
          );
        }
      }

      v.step = 2; // 検索キー文字列入力画面
      this.entry.element = createElement({
        attr:{name:'entry'},children:[
          {attr:{class:'webScanner'}},  // スキャン画像表示領域
          {tag:'input',attr:{type:'text'}},
          {
            tag:'input',
            attr:{type:'button',value:'検索'},
            event:{click: this.main},
          },
        ],
      });
      this.area.element.appendChild(this.entry.element);

      v.step = 3; // 一覧用ダイアログを定義
      this.list.element = createElement({
        tag:'dialog',
        attr:{class:'Reception',name:'list'},
        html: `<p>複数の候補が見つかりました。該当者名をクリックしてください。</p>
        <div name="table">
          <div class="th">申込者名</div>
          <div class="th">e-mail</div>
        </div>`,
      });
      document.querySelector('body').prepend(this.list.element);
      this.list.table = this.list.element.querySelector('[name="table"]');

      v.step = 4; // 編集用ダイアログを定義
      this.edit.element = createElement({
        tag:'dialog',
        attr:{class:'Reception',name:'edit'},
        html: `<div name="table">
          <div class="th">No</div>
          <div class="th">氏名</div>
          <div class="th">所属</div>
          <div class="th">参加費</div>
        </div>
        <input type="button" name="cancel" value="キャンセル" />
        <input type="button" name="submit" value="送信" />
        <div name="details">
          <div class="th">申込</div><div class="td">
            No.<span name="entryNo"></span>
            &emsp;
            <ruby>
              <span name="申込者氏名"></span>
              <rt name="申込者カナ"></rt>
            </ruby>
            &emsp;(<span name="申込者の参加"></span>)
          </div>
          <div class="th">宿泊、テント</div><div class="td" name="宿泊、テント"></div>
          <div class="th">引取者</div><div class="td" name="引取者氏名"></div>
          <div class="th">e-mail</div><div class="td" name="メールアドレス"></div>
          <div class="th">緊急連絡先</div><div class="td" name="緊急連絡先"></div>
          <div class="th">ボランティア</div><div class="td" name="ボランティア募集"></div>
          <div class="th">備考</div><div class="td" name="備考"></div>
          <div class="th">キャンセル</div><div class="td" name="キャンセル"></div>
          <div class="th">申込URL</div><div class="td" name="editURL"></div>
          <div class="th">メモ<br><sub>※スタッフ記入欄</sub></div>
          <div class="td"><textarea name="memo"></textarea></div>
        </div>`,
      });
      document.querySelector('body').prepend(this.edit.element);
      this.edit.table = this.edit.element.querySelector('[name="table"]');
      this.edit.details = this.edit.element.querySelector('[name="details"]');
  
      console.log(v.whois+' normal end.',v.rv);
      return v.rv;
  
    } catch(e){
      console.error(v.whois+' abnormal end(step.'+v.step+')\n',e,v);
      return e;
    }
  }

  /** search, list, editを順次呼び出す(全体制御)
   * @param {string|Event} arg - 受付番号(スキャン結果文字列) or clickイベント
   * @returns {void}
   */
  main = async (arg) => {
    const v = {whois:'Reception.main',step:'0',rv:null};
    console.log(v.whois+' start.');
    try {

      v.step = '1'; // スキャン結果でない場合、入力文字列を取得
      v.keyword = whichType(arg) === 'String' ? arg
      : arg.target.parentElement.querySelector('input[type="text"]').value;
      console.log('step.'+v.step+': keyword='+v.keyword);

      // 認証局経由で管理局に該当者情報を問合せ
      v.rv = await this.#search(v.keyword);
      console.log(v.rv);
      console.log(JSON.stringify(v.rv.result));

      if( v.rv.isErr || v.rv.result.length === 0 ){
        // 検索画面でメッセージをポップアップ
        alert( v.rv.message );
      } else {
        v.target = v.rv.result[0];
        if( v.rv.result.length > 1 ){
          console.log(JSON.stringify(v.rv));
          // 該当者一覧画面に遷移、編集対象者を特定
          this.list.candidates = v.rv.result; // 候補者リストに格納
          v.target = await this.#list(v.rv.result);
        }
        // 編集画面を表示し、変更箇所を取得
        v.data = await this.#edit(v.target);
        // auth.fetchで変更箇所を管理局に送信
        if( v.data !== null ){
          v.rv = await this.#update(v.data);
          // 編集結果のメッセージを表示
          alert(v.rv.message);
        }
      }
      // 検索画面を再表示(bootScanner)
      this.bootScanner();

      console.log(v.whois+' normal end.',v.rv);
      return v.rv;
    } catch(e){
      console.error(v.whois+' abnormal end(step.'+v.step+').',e,v);
      return e;        
    }
  }

  /** スキャナを起動、読み込んだQRデータをsearchに渡す
   * @param {void}
   * @returns 
   */
  bootScanner = async () => {
    const v = {whois:'Reception.bootScanner',step:'0',rv:null};
    console.log(v.whois+' start.');
    try {

      const sel = this.area.selector+' [name="entry"] .webScanner';
      document.querySelector(sel).innerHTML = '';
      const code = await scanQR(sel);
      if( code !== null ){
        v.rv = this.main(code); // 後続のmainにスキャン文字列を渡す
        // 文字入力された⇒スキャン結果無しでタイムアウト(code=null)の場合
        // mainを呼び出さずに終了する
      }

      console.log(v.whois+' normal end.',v.rv);
      return v.rv;
    } catch(e){
      console.error(v.whois+' abnormal end.',e,v);
      return e;        
    }
  }

  /** 認証局経由で管理局に該当者情報を問合せ
   * @param {string} keyword - 参加者の検索キー
   * @returns {Object[]} 検索キーに該当する参加者情報の配列
   */
  #search = async (keyword) => {
    const v = {whois:'Reception.#search',step:'0',rv:null};
    console.log(v.whois+' start.');
    try {

      // entry画面を閉じてloading表示
      this.loading.element.style.display = 'block';

      // Auth.fetchで認証局に問い合わせ
      console.log(this.auth);
      v.rv = await this.auth.fetch('recept1A',keyword,3);

      // loading画面を閉じる
      this.loading.element.style.display = 'none';

      console.log(v.whois+' normal end.',v.rv);
      return v.rv;
    } catch(e){
      console.error(v.whois+' abnormal end.',e,v);
      return e;        
    }
  }

  /** 該当者リストの表示、対象者の選択
   * @param {Object[]} data - 検索キーに該当する参加者情報の配列
   * @returns {Object} 選択された対象者情報
   */
  #list(data){
    const v = {whois:'Reception.#list',step:'0',rv:null};
    console.log(v.whois+' start.');
    try {

      v.step = 1; // 前回候補者一覧の削除
      this.list.table.querySelectorAll('div.td').forEach(x => x.remove());

      v.step = 2; // 候補者の表示
      data.forEach(d => {
        v.step = 2.1; // 氏名＋カナ
        this.list.table.appendChild(createElement({
          attr:{class:'td'},
          children:[{
            tag:'a',  // 氏名＋カナはaタグで囲む
            attr:{name:d.entryNo}, // 受付番号をname属性で持たせる
            children:[{
              tag: 'ruby',
              html: d['申込者氏名'], 
              children: [{
                tag: 'rt',
                text: d['申込者カナ'],
              }],
            }],
          }],
        }));

        v.step = 2.2; // e-mail
        this.list.table.appendChild(createElement({
          attr:{class:'td'},
          text: d['メールアドレス'],
        }));
      });

      v.step = 3.1; // 一覧用ダイアログの表示
      this.list.element.showModal();

      v.step = 3.2; // 戻り値を設定
      return new Promise(resolve => {
        document.querySelectorAll('dialog.Reception[name="list"] a').forEach(x => {
          // 一覧表の氏名(aタグ)全てにclickイベントリスナを付与
          x.addEventListener('click',(element) => {
            this.list.element.close();  // ダイアログを閉じる
            // aタグから受付番号を取得
            let entryNo = element.target.parentElement.getAttribute('name');
            for( let i=0 ; i<this.list.candidates.length ; i++ ){
              // 事前に保存しておいた候補者配列から該当者を選択して返す
              if( this.list.candidates[i].entryNo === entryNo ){
                console.log('Reception.#list normal end.',entryNo);
                resolve(this.list.candidates[i]);
              }
            }
          });
        });
      });

    } catch(e){
      console.error(v.whois+' abnormal end.',e,v);
      return e;        
    }
  }

  /** 対象となる参加者情報の表示と編集、結果を管理局に反映
   * @param {Object} participant - 対象者情報
   * @returns {Object} 管理局からの戻り値
   */
  #edit = async (data) => {
    const v = {whois:'Reception.#edit',rv:null,step:'0'};
    console.log(v.whois+' start.\n'+JSON.stringify(data));
    try {
  
      v.step = 1; // データクレンジング
      data['申込者所属'] = '申込者';  // 未定義なので追加しておく
      for( v.i=0 ; v.i<6 ; v.i++ ){
        if( data['fee0'+v.i].length === 0 ){
          data['fee0'+v.i] = (data['参加者0'+v.i+'所属'] === '未就学児') ? '無し' : '未収';
        }
      }
  
      v.step = 2; // 参加者一覧の表示
      // 前回参加者一覧の削除
      this.edit.table.querySelectorAll('div.td').forEach(x => x.remove());
      for( v.i=0 ; v.i<6 ; v.i++ ){
        v.step = 2.1; // 項目名の接頭辞
        v.pre = v.i === 0 ? '申込者' : ('参加者0' + v.i);
  
        v.step = 2.2; // 申込者が不参加、または氏名・所属とも未登録の参加者は表示しない
        if( v.i === 0 && data['申込者の参加'] === '不参加'
        || data[v.pre+'氏名'].length === 0 && data[v.pre+'所属'].length === 0 ){
          continue;
        }
  
        v.step = 2.3; // No
        this.edit.table.appendChild(createElement({attr:{class:'td'},text: ('0'+v.i)}));
  
        v.step = 2.4; // 氏名＋カナ
        this.edit.table.appendChild(createElement({attr:{class:'td'},children:[{
          tag: 'ruby',
          html: data[v.pre+'氏名'], 
          children: [{
            tag: 'rt',
            text: data[v.pre+'カナ']
          }]
        }]}));
  
        v.step = 2.5; // 所属
        this.edit.table.appendChild(createElement({attr:{class:'td'},text: data[v.pre+'所属']}));
  
        v.step = 2.6; // 参加費
        v.options = [];
        ['無し','未収','既収'].forEach(x => {
          v.options.push({
            tag:'option',
            value:x,
            text:x,
            logical:{selected:(data['fee0'+v.i] === x)},
          });
        });
        this.edit.table.appendChild(createElement({attr:{class:'td'},children:[{
          tag: 'select',
          attr: {class:'fee',name:'fee0'+v.i},
          children:v.options,
        }]}));
      }
  
      v.step = 3.1; // 詳細情報のセット
      ['メールアドレス', '申込者氏名', '申込者カナ', '申込者の参加',
      '宿泊、テント', '引取者氏名', '緊急連絡先',
      'ボランティア募集', '備考', 'キャンセル',
      'entryNo','memo'].forEach(x => {
        console.log(x,data[x]);
        let e = this.edit.details.querySelector('[name="'+x+'"]');
        console.log(e);
        e.innerText = data[x];
      });
      v.step = 3.2; // 申込フォーム修正URL(QRコード)
      v.qrDiv = this.edit.details.querySelector('[name="editURL"]');
      v.qrDiv.innerHTML = '';
      v.qr = new QRCode(v.qrDiv,{
        text: data.editURL,
        width: 300, height: 300,
        colorDark: "#000000",
        colorLight: "#ffffff",
        correctLevel: QRCode.CorrectLevel.H
      });
      
  
      v.step = 4.1; // 編集用ダイアログの表示
      this.edit.element.showModal();
  
      v.step = 4.2; // 戻り値を設定
      return new Promise(resolve => {
        v.step = 5.1; // 「キャンセル」クリック時はnullを返す
        document.querySelector('dialog[name="edit"] input[name="cancel"]')
        .addEventListener('click',() => {
          this.edit.element.close();
          console.log('Reception.edit normal end.');
          resolve(null);
        });
        v.step = 5.2; // 「送信」クリック時に値を返すよう定義
        document.querySelector('dialog[name="edit"] input[name="submit"]')
        .addEventListener('click',() => {
          this.edit.element.close();
          const rv = {};
          // 受付番号
          rv.entryNo = this.edit.element.querySelector('[name="entryNo"]').innerText;
          // 参加費
          this.edit.element.querySelectorAll('select.fee').forEach(x => {
            rv[x.getAttribute('name')] = x.value;
          });
          // スタッフメモ欄
          rv.memo = this.edit.element.querySelector('[name="memo"]').value;
          console.log('Reception.edit normal end.',rv);
          resolve(rv);
        });
      });
  
    } catch(e){
      console.error(v.whois+' abnormal end(step.'+v.step+')\n',e,v);
      return e;
    }
  }

  /** 認証局経由で管理局の参加者情報を更新
   * @param {Object} data - 参加者情報
   * @returns {Object} 更新結果
   */
  #update = async (data) => {
    const v = {whois:'Reception.#update',step:'0',rv:null};
    console.log(v.whois+' start.');
    try {

      // loading表示
      this.loading.element.style.display = 'block';

      // Auth.fetchで認証局に問い合わせ
      //console.log(this.auth);
      v.rv = await this.auth.fetch('recept2A',data,3);

      // loading画面を閉じる
      this.loading.element.style.display = 'none';

      console.log(v.whois+' normal end.',v.rv);
      return v.rv;
    } catch(e){
      console.error(v.whois+' abnormal end.',e,v);
      return e;        
    }
  }

}</script>
<style type="text/css">/* コアCSS */
.right {text-align: right;}
.image, .TimeTable {
  max-width: 100%;
}
.TimeTable, .TimeTable div {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  display: grid;
  --color: #ccc;
  --boldLine : solid 2px var(--color);
  --thinLine : dotted 1px var(--color);
}
.TimeTable span {
  padding-left: 0.3rem;
  white-space: nowrap;
}
/*.TimeTable .controller {}*/
.TimeTable .main {
  grid-template-rows: 2rem 1fr;
  grid-template-columns: 1fr;
  overflow: auto;
}
.TimeTable .main .header {
  grid-row: 1/2;
  grid-column: 1/2;
  grid-template-columns: repeat(3, 1fr);
  border: var(--boldLine);
}
.TimeTable .main .header div:nth-child(2n) {
  background-color: var(--color);
}
.TimeTable .main .timeline {
  grid-row: 2/3;
  grid-column: 1/2;
  grid-template-columns: repeat(12, 1fr);
  border-bottom: var(--boldLine);
}
.TimeTable .main .timeline div {
  min-width: 1rem;
  min-height: 1rem;
}
.TimeTable .main .timeline div:nth-child(2n+1) {
  border-left: var(--boldLine);
}
.TimeTable .main .timeline div:nth-child(2n) {
  border-left: var(--thinLine);
}
.TimeTable .main .timeline div:last-child {
  border-right: var(--boldLine);
}
.TimeTable .main .tasks {
  grid-row: 2/3;
  grid-column: 1/2;
  z-index: 1;
}
.TimeTable .main .tasks > div {
  max-height: 1.6rem;
  grid-column: 1/37;
  margin-bottom: 0.5rem;
}
.TimeTable .main .tasks > div:first-child {
  margin-top: 0.5rem;
}
.TimeTable .main .tasks .bar {
  grid-template-columns: repeat(36, 1fr);
}
.TimeTable .main .tasks .bar [name="1.1"]{
  grid-column: 4/12;
  background-color: var(--color);
}
.TimeTable .main .tasks .bar [name="1.2"]{
  grid-column: 15/20;
  background-color: var(--color);
}

.TimeTable .detail {
  margin-top: 1rem;
  display: none;
}
.TimeTable .detail div {
  padding: 0.5rem;
}
.TimeTable .detail > div {
  grid-template-columns: 5rem 1fr;
}
.TimeTable .detail .button {
  height: 3rem;
  margin-bottom: 1rem;
  display: flex;
}
.TimeTable .detail .button button {
  margin-left: 2rem;
  height: 2rem;
}
/*
  テーブル関係
*/
.TimeTable th {
  padding: 0.3em;
  background-color: #888;
  color: white;
}
.TimeTable td {
  padding: 0.3em;
  border-bottom: solid 1px #aaa;
  border-right: solid 1px #aaa;
}
</style>
<script type="text/javascript">/* コアスクリプト */
/**
 * @typedef {Object} opt
 * @prop {string} datatype - データのタイプ。sheet:シートデータ
 */

/**
 * @classdesc HTMLにタイムテーブルを描画する
 */

class TimeTable {
  
  /**
   * @constructor
   * @param {string} selector - タイムテーブルを描画する要素のCSSセレクタ
   * @param {Object} data - タイムテーブル用のデータ
   * @param {Object} opt - オプションを指定するオブジェクト
   * @returns {void}
   * 
   * @desc 既定値の設定、タスクデータ他のデータ加工を行い、タイムテーブルを描画する
   * 
   * <details><summary>入力シートイメージ</summary>
   * 
   * - start/endが赤字：マイルストーン(非導出項目、要手動設定)
   * - 背景色群青：セクション・タスク共通の必須項目
   * - 薄青：同任意項目
   * - 濃緑：タスクのみの必須項目
   * - 薄緑：同任意項目
   * - 赤：算式が設定された項目
   * 
   * <h3>TimeTable</h3>
   * <table calss="tt"><tr>
   * <th style="background:#ff0000;color:white">id</th>
   * <th style="background:#0000ff;color:white;">pId</th>
   * <th style="background:#0000ff;color:white;">name</th>
   * <th style="background:#cfe2f3;">summary</th>
   * <th style="background:#cfe2f3;">pending</th>
   * <th style="background:#cfe2f3;">note</th>
   * <th style="background:#38761d;color:white;">start</th>
   * <th style="background:#d9ead3;">lasts</th>
   * <th style="background:#38761d;color:white;">end</th>
   * <th style="background:#d9ead3;">location</th>
   * <th style="background:#d9ead3;">ideal</th>
   * <th style="background:#d9ead3;">fixed</th>
   * <th style="background:#d9ead3;">output</th>
   * <th style="background:#d9ead3;">style</th>
   * </tr><tr>
   * <td>2</td><td>0</td><td>イベント(大線表)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td>
   * </tr><tr>
   * <td>3</td><td>2</td><td>受付</td><td></td><td></td><td></td><td style="color:#f00;">9/30 13:30</td><td>30</td><td>9/30 14:00</td><td>正門</td><td></td><td></td><td></td><td></td>
   * </tr><tr>
   * <td>4</td><td>2</td><td>テント設営</td><td></td><td></td><td>子供達は体育館で遊ぶ</td><td>9/30 14:00</td><td></td><td>9/30 17:00</td><td>校庭</td><td></td><td></td><td></td><td></td>
   * </tr><tr>
   * <td>5</td><td>2</td><td>夕食</td><td></td><td></td><td></td><td style="color:#f00;">9/30 17:00</td><td>90</td><td>9/30 18:30</td><td>テントor喫食コーナ</td><td></td><td></td><td></td><td></td>
   * </tr><tr>
   * <td>6</td><td>2</td><td>肝試し</td><td></td><td></td><td></td><td>9/30 18:30</td><td>120</td><td>9/30 20:30</td><td>校内</td><td></td><td></td><td></td><td></td>
   * </tr><tr>
   * <td>7</td><td>2</td><td>宿泊</td><td></td><td></td><td></td><td>9/30 20:30</td><td></td><td style="color:#f00;">10/01 07:30</td><td>テントor体育館</td><td></td><td></td><td></td><td></td>
   * </tr><tr>
   * <td>8</td><td>2</td><td>朝食</td><td>素麺提供</td><td></td><td></td><td>10/01 07:30</td><td>30</td><td>10/01 08:00</td><td>テントor体育館</td><td></td><td></td><td></td><td></td>
   * </tr><tr>
   * <td>9</td><td>2</td><td>テント撤去</td><td></td><td></td><td></td><td>10/01 08:00</td><td>60</td><td>10/01 09:00</td><td>校庭</td><td></td><td></td><td></td><td></td>
   * </tr></table>
   * 
   * <h3>resources</h3>
   * <table><tr>
   * <th style="background:#0000ff;color:white;">tId</th>
   * <th style="background:#ff0000;color:white;">tName</th>
   * <th style="background:#ff0000;color:white;">id</th>
   * <th style="background:#0000ff;color:white;">name</th>
   * <th style="background:#cfe2f3;">quantity</th>
   * <th style="background:#cfe2f3;">unit</th>
   * <th style="background:#cfe2f3;">procure</th>
   * <th style="background:#cfe2f3;">budget</th>
   * <th style="background:#cfe2f3;">note</th>
   * </tr>
   * <tr><td>17</td><td>参加者受付</td><td>2</td><td>参加者名簿</td><td>3</td><td>冊</td><td>嶋津作成</td><td>0</td><td></td></tr>
   * <tr><td>17</td><td>参加者受付</td><td>3</td><td>文鎮</td><td>3</td><td>個</td><td></td><td></td><td></td></tr>
   * <tr><td>17</td><td>参加者受付</td><td>4</td><td>貯金箱</td><td>1</td><td>個</td><td></td><td></td><td></td></tr>
   * <tr><td>17</td><td>参加者受付</td><td>5</td><td>トレイ</td><td>3</td><td>個</td><td></td><td></td><td></td></tr>
   * <tr><td>17</td><td>参加者受付</td><td>6</td><td>ガムテープ</td><td>2</td><td>個</td><td></td><td></td><td>テントの有無で色を変える</td></tr>
   * <tr><td>17</td><td>参加者受付</td><td>7</td><td>おやじの会入会申込書</td><td>20</td><td>枚</td><td></td><td></td><td></td></tr>
   * </table>
   * </details>
   * 
   */

  constructor(selector,data,opt){
    this.rootElement = document.querySelector(selector);
    this.rootElement.innerHTML = `
      <div class="controller"></div>
      <div class="main">
        <div class="header"></div>
        <div class="timeline"></div>
        <div class="tasks"></div>
      </div>
      <div class="detail">
        <div class="button">
          <button name="close">閉じる</button>
          <button name="edit">編集</button>
        </div>
        <table>
          <thead>
            <tr><th>項目</th><th>値</th><th>備考</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    `;
    // オプションの既定値設定
    this.opt = mergeDeeply({
      datatype: null, // dataが加工済ならnull
      unit: 5,
      design: {
        default: {
          color: "#000",
          backgroundColor: "rgba(196,196,196,0.6)",
          border: "solid 1px #aaa",
        },
        critical: {
          color: "#fff",
          backgroundColor: "rgba(255,96,96,0.6)",
          border: "solid 1px #f00",
        },
      },
      detailDateFormat: 'M/dd hh:mm', // 詳細画面に表示する日時の形式
      dataSheet: null,  // 元データを格納したGoogle SpreadのURL
    },opt);
    console.log(this.opt);

    // シート形式のデータだった場合、加工してthis.tasksにセット
    this.tasks = this.opt.datatype === null ? data : this.#process(data);
    console.log(this.tasks);

    // map(id->タスク)の作成
    this.map = {};
    this.#makeMap(this.tasks);

    // タイムテーブルを描画
    this.draw();
  }

  /** div.tasks領域にタスク(単体)を追加する
   * (本関数はdrawから呼ばれるプライベート関数)
   */
  #appendTask(task,pId=''){ // ガントチャートの作成
    const v = {
      tasksElement: this.rootElement.querySelector('.main .tasks'),
    };
    /*
    // taskのIDを採番、マップに追加
    task.id = pId + (seq+1) + '.';
    this.data.map[task.id] = task;
    */

    if( 'children' in task ){
      // childrenが存在⇒セクション(ラベル)行
      v.labelElement = this.createElement({class:'label'});
      //v.labelSpan = this.createElement({tag:'span',text:task.name});
      //v.labelSpan.onclick = () => this.showDetail(task.id);
      v.labelSpan = this.createElement('span');
      v.labelSpan.innerText = '▼'+task.name;
      v.labelSpan.onclick = () => this.toggleChildren(task.id,v.labelSpan);
      v.labelElement.appendChild(v.labelSpan);
      v.tasksElement.appendChild(v.labelElement);
      for( let i=0 ; i<task.children.length ; i++ ){
        this.#appendTask(task.children[i],task.id);
      }
    } else {
      // childrenが不存在⇒タスク行
      v.barElement = this.createElement({class:'bar pId'+pId});
      v.barElement.style.gridTemplateColumns
        = 'repeat('+(this.numHour*12)+', 1fr)';
      // barSpan: 棒状の部分
      v.barSpan = this.createElement(
        {tag:'span',name:task.id,text:task.name});
      v.barStart = ((new Date(task.start).getTime())
        - this.startHour) / (this.opt.unit*60000) + 1;
      v.barEnd = ((new Date(task.end).getTime())
        - this.startHour) / (this.opt.unit*60000) + 1;
      this.applyStyle({
        element: v.barSpan,
        apply: task.style,
        addition: {gridColumn:v.barStart + '/' + v.barEnd},
      });
      v.barSpan.onclick = () => this.showDetail(task.id);
      v.barElement.appendChild(v.barSpan);
      v.tasksElement.appendChild(v.barElement);
    }
  }

  /** 要素にスタイルを設定する
   * @param {Object} arg
   * @param {string} arg.apply - 適用するスタイル名
   * @param {Object.<string, string>} arg.addition - 追加適用する属性名：属性値
   * @returns {void}
   */
  applyStyle(arg){
    // apply,additionの既定値設定
    if( arg.apply.length === 0 ) arg.apply = 'default';
    const v = Object.assign({apply:'default',addition:{}},arg);
    // 適用するスタイルのオブジェクトを作成
    v.style = Object.assign(this.opt.design[v.apply],v.addition);
    for( let a in v.style ){
      arg.element.style[a] = v.style[a];
    }
  }

  /** DIV要素を生成、属性を指定する
   * @param {string} tag='div' - タグ名
   * @param {string} [text] - 生成された要素のinnerHTML
   * @param {Object.<string, string>} xxx - 生成された要素に設定するスタイルシート属性名：属性値
   */
  createElement(arg='div'){
    const v = {tag:'div',opt:arg};
    if( typeof arg === 'string' ){
      v.tag = arg;
      v.opt = {};
    } else {
      if( 'tag' in arg ){
        v.tag = arg.tag;
      } 
    }
    let rv = document.createElement(v.tag);
    for( let x in v.opt ){
      switch(x) {
        case 'tag': break;
        case 'text': rv.innerHTML = arg.text; break;
        default: rv.setAttribute(x,arg[x]);
      }
    }
    return rv;
  }

  /** タイムテーブルを(再)描画する */
  draw(){
    console.log("draw start.");

    const v = {};
    this.minTime = Infinity; // task.startの最小値。UNIX時刻
    this.maxTime = -Infinity;
    this.startHour = Infinity; // minTime以下の正時となるUNIX時刻。表示領域の左端
    this.endHour = -Infinity;  // maxTime以上の正時となるUNIX時刻。表示領域の右端
    this.numHour = 0;          // startHour〜endHourまでの時間数    console.log(this.data);

    // 描画範囲を計算
    this.timeRange(this.tasks);  // minTime, v.maxTimeの取得
    this.startHour = Math.floor(this.minTime / 3600000) * 3600000;
    this.endHour = Math.ceil(this.maxTime / 3600000) * 3600000;

    // 1.controllerの要素を作成

    // 2.mainの要素を作成

    // 2.1.main.headerの要素を作成
    v.headerElement = this.rootElement.querySelector('.main .header');
    v.headerElement.innerHTML = '';
    for( v.i=this.startHour ; v.i<=this.endHour ; v.i+=3600000 ){
      v.o = this.createElement();
      v.o.innerText = new Date(v.i).getHours() + ':00';
      v.headerElement.appendChild(v.o);
      this.numHour++;
    }
    v.headerElement.style.gridTemplateColumns = 'repeat('+this.numHour+', 1fr)';

    // 2.2.main.timelineの要素を作成
    v.timelineElement = this.rootElement.querySelector('.main .timeline');
    v.timelineElement.innerHTML = '';
    v.timelineElement.innerHTML = '<div></div>'.repeat(this.numHour*4);
    v.timelineElement.style.gridTemplateColumns = 'repeat('+(this.numHour*4)+', 1fr)';

    // 2.2.main.tasksの要素を作成
    v.tasksElement = this.rootElement.querySelector('.main .tasks');
    v.tasksElement.innerHTML = '';
    for( let i=0 ; i<this.tasks.length ; i++ ){
      this.#appendTask(this.tasks[i],'');
    }

    // 3.detailの要素を作成


    console.log("draw end.");
  }

  /** タスクID->タスク取得用のthis.mapを作成 */
  #makeMap(tasks){
    console.log('makeMap start.');
    const v = {};
    for( v.i=0 ; v.i<tasks.length ; v.i++ ){
      this.map[tasks[v.i].id] = tasks[v.i];
      if( 'children' in tasks[v.i] ){
        this.#makeMap(tasks[v.i].children );
      }
    }
    console.log('makeMap end.');
  }

  #process(raw){
    const v = {sheet:[{children:[]}],idmap:{0:0}};
    console.log('process start.');

    this.tasks = [];
    // 01.configシート
    this.opt.sheetDef = {};
    v.header = raw.config[0]; // ヘッダ行
    for( v.i=1 ; v.i<raw.config.length ; v.i++ ){
      v.l = raw.config[v.i];
      if( String(v.l[0]).length > 0 ){ // 空白行スキップ
        v.o = {};
        for( v.j=1 ; v.j<v.l.length ; v.j++ ){
          v.o[v.header[v.j]] = v.l[v.j];
        }
        if( !(v.l[0] in this.opt.sheetDef) ){
          // シートのオブジェクトが未定義なら追加
          this.opt.sheetDef[v.l[0]] = {};
        }
        this.opt.sheetDef[v.l[0]][v.l[1]] = v.o;
      }
    }
    console.log(this.opt.sheetDef);

    // 02.TimeTableシート
    v.header = raw.TimeTable[0]; // ヘッダ行
    v.idmapIndex = 0; // v.idmapの添字
    console.log(v.header)
    // 02.1. v.sheetにリニアに追加する
    for( v.i=1 ; v.i<raw.TimeTable.length ; v.i++ ){
      v.l = raw.TimeTable[v.i];
      // 有効な行データをオブジェクト化する
      if( Number(v.l[0]) > 0 ){ // 空白行スキップ
        v.o = {resources:[]}; // 必要資機材のみTimeTableシート上にないので足しておく
        for( v.j=0 ; v.j<v.l.length ; v.j++ ){
          v.colType = this.opt.sheetDef.TimeTable[v.header[v.j]].type.toLowerCase();
          switch( v.colType ){
            case 'Date':
              v.o[v.header[v.j]] = new Date(v.l[v.j]).getTime();
              break;
            default:
              v.o[v.header[v.j]] = v.l[v.j];
          }
        }
        // 戻り値用のデータをセット
        v.idmapIndex++;
        v.idmap[v.o.id] = v.idmapIndex;
        v.sheet.push(v.o);
      }
    }
    console.log(v.sheet);
    console.log(v.idmap);

    // 02.2.親子関係を設定
    for( v.i=1 ; v.i<v.sheet.length ; v.i++ ){ // 0はrootなので飛ばす
      //console.log('v.sheet[v.i]=',v.sheet[v.i])
      //console.log('v.sheet[v.i].pId='+v.sheet[v.i].pId);
      //console.log('v.idmap[v.sheet[v.i].pId]='+v.idmap[v.sheet[v.i].pId]);
      //console.log('v.sheet['+v.idmap[v.sheet[v.i].pId]+']=',v.sheet[v.idmap[v.sheet[v.i].pId]]);
      v.parent = v.sheet[v.idmap[v.sheet[v.i].pId]];
      if( !('children' in v.parent) ) v.parent.children = [];
      v.parent.children.push(v.sheet[v.i]);
      console.log('v.sheet['+v.i+']=',v.sheet[v.i],'\nv.parent=',v.parent);
    }
    console.log(v.sheet);

    // [03] resourcesシート
    v.header = raw.resources[0];  // ヘッダ行
    for( v.i=1 ; v.i<raw.resources.length ; v.i++ ){
      v.o = {};
      for( v.j=0 ; v.j<v.header.length ; v.j++ ){
        v.o[v.header[v.j]] = raw.resources[v.i][v.j];
      }
      console.log('v.o=',v.o);
      console.log('v.idmap[v.o.tId]=',v.idmap[v.o.tId]);
      console.log('v.sheet[v.idmap[v.o.tId]]=',v.sheet[v.idmap[v.o.tId]]);
      v.parent = v.sheet[v.idmap[v.o.tId]];
      if( !('resources' in v.parent) ) v.parent.resources = [];
      v.parent.resources.push(v.o);
    }

    console.log('process end.');
    return v.sheet[0].children;
  }

  /** ダイアログに詳細情報を表示
   * @prop {string} id - 表示するタスクのID
   */
  showDetail(id){
    console.log('showDetail start. id='+id);
    const v = {
      task:this.map[id],  // 表示するタスクのオブジェクト
      detail: this.rootElement.querySelector('.detail'),  // 詳細領域の要素
      /** 非表示項目を排除しながら表示順に項目をソート
       * - [オブジェクトをdateでソートする例](https://keizokuma.com/js-array-object-sort/)
       * @param {Object} columnDef - 欄名:{column,label,type,memo,must,display,note}をメンバとするオブジェクト
       */
      listColumns: (columnDef) => { // 
        const list = [];
        Object.keys(columnDef).forEach(x => {
          if( columnDef[x].display > 0 ) list.push(columnDef[x]);
        });
        list.sort((a,b) => a.display < b.display ? -1 : 1);
        return list;
      },
    };

    // 前回の表示結果をクリア
    v.detail.querySelector('tbody').innerHTML = '';

    // 非表示項目を排除しながら表示順に項目をソート
    v.list = v.listColumns(this.opt.sheetDef.TimeTable);
    console.log(v.list);

    // 表示順にタスクの項目をtbodyに追加
    for( v.i=0 ; v.i<v.list.length ; v.i++ ){
      v.tr = this.createElement('tr');

      // 項目ラベル欄
      v.o = {tag:'td',text:v.list[v.i].label};
      v.tr.appendChild(this.createElement(v.o));
      // 値・備考欄
      v.value =  v.task[v.list[v.i].column] || '';
      if( v.list[v.i].type !== 'Resource'){
        // Resource(表内表)以外
        switch( v.list[v.i].type ){
          case 'Number':  // number : toLocaleして右寄せ
            v.o.class = 'right';
            v.o.text = v.value.toLocaleString();
            break;
          case 'Date':  // 表示形式を整形
            console.log(new Date(v.value));
            v.o.text = new Date(v.value).toLocale(this.opt.detailDateFormat);
            break;
          default:
            v.o.text = String(v.value);
        }
        v.tr.appendChild(this.createElement(v.o));
        // 備考欄
        v.o.text = v.task[v.list[v.i].memo] || '';
        v.tr.appendChild(this.createElement(v.o));
      } else {
        // Resource
        v.rList = v.listColumns(this.opt.sheetDef.resources);
        console.log(v.rList)
        v.rData = [v.rList.map(x => x.label)];
        for( v.r=0 ; v.r<v.task.resources.length ; v.r++ ){
          v.a = [];
          v.l = v.task.resources[v.r];
          console.log(v.l);
          for( v.c=0 ; v.c<v.rList.length ; v.c++ ){
            v.a.push(v.rList[v.c].type === 'Date'
            ? new Date(v.l[v.rList[v.c].column])
            : v.l[v.rList[v.c].column]);
          }
          v.rData.push(v.a);
        }
        console.log(v.rData);
        v.td = this.createElement({tag:'td',colspan:"2"});
        v.td.appendChild(v.rData.tabulize({dateFormat:this.opt.detailDateFormat}));
        v.tr.appendChild(v.td);
      }
      console.log(v.tr);

      v.detail.querySelector('tbody').appendChild(v.tr);
    }
    
    // 詳細画面の「閉じる」ボタン動作設定
    v.detail.querySelector('button[name="close"]').onclick
    = () => v.detail.style.display = 'none';
    // 「編集」ボタン動作設定
    if( this.opt.dataSheet !== null ){
      v.detail.querySelector('button[name="edit"]').onclick
      = () => window.open(this.opt.dataSheet,'_blank');
    }

    // 詳細画面表示
    v.detail.style.display = 'block';
    console.log('showDetail end.');

  }

  /** v.minTime, v.maxTimeの取得 */
  timeRange(tasks){
    const v = {};
    for( let task of tasks ){
      if( 'children' in task ){
        this.timeRange(task.children);
      } else {
        v.st = new Date(task.start).getTime();
        v.ed = new Date(task.end).getTime();
        if( this.minTime > v.st ) this.minTime = v.st;
        if( this.maxTime < v.ed ) this.maxTime = v.ed;
      }
    }
  }

  /** セクション名クリックで配下のタスクの表示/非表示切り替え */
  toggleChildren(id,label){
    this.rootElement.querySelectorAll('.pId'+id).forEach(x => 
      x.style.display = x.style.display === 'none' ? '' : 'none');
    // ラベルの前の三角を交換
    let m = label.innerText.match(/^([▶️|▼])(.+)$/);
    console.log(m)
    label.innerText = (( m[1] === '▼' ) ? '▶️' : '▼') + m[2];
  }

}
</script>
<script type="text/javascript">

/**
 * @typedef {Object} webScannerOpt
 * @prop {number} interval - 動画状態で撮像、読み込めなかった場合の間隔。ミリ秒
 * @prop {object} RegExp - QRコードスキャン時、内容が適切か判断
 * @prop {number} lifeTime - 一定時間操作がない場合の停止までのミリ秒。既定値60000
 * @prop {boolean} alert - 読み込み完了時に内容をalert表示するか
 */

/**
 * @classdesc 指定セレクタ以下にcanvas他の必要な要素を作成し、QRコードや文書をスキャン
 * 
 * **残課題**
 * 
 * 1. scanDoc稼働未確認
 * 
 * @example
 * 
 * ```
 * <div class="webScanner"></div>
 * 〜
 * const ws = new webScanner('.webScanner');
 * ws.scanQR(r=>console.log('scanned QR Code = '+r));   // QRコードの読み込み
 * ws.scanDoc();  // 文書の撮影
 * ```
 */

class webScanner {
  /**
   * 指定セレクタ以下にcanvas他の必要な要素を作成してスキャン実行、指定の後続処理を呼び出す。
   * 
   * - [jsQRであっさりQRコードリーダ/メーカ](https://zenn.dev/sdkfz181tiger/articles/096dfb74d485db)
   * - [PCにおける内蔵/webカメラの切り替え](webScanner.html#switchCamera)
   * 
   * @constructor
   * @param {string|HTMLElement} parent - 親要素(ラッパー)。文字列ならCSSセレクタと解釈
   * @param {webScannerOpt} [opt={}] - オプション
   * @returns {void} なし
   */
  constructor(parent,opt){
    const v = {opt:{}};
    console.log('webScanner.constructor start.');

    // 親要素(ラッパー。HTMLElement)をthis.parentにセット
    this.parent = typeof parent !== 'string' ? parent
      : document.querySelector(parent);
    console.log(this.parent); 

    // デバイスがサポートされているか確認
    if (!('mediaDevices' in navigator) || !('getUserMedia' in navigator.mediaDevices)) {
      const msg = 'デバイス(カメラ)がサポートされていません';
      console.error('webScanner.constructor: '+msg);
      alert(msg);
      return;
    } else {
      console.log('device is supported.');
    }

    // メンバ(既定値)の設定
    v.opt = Object.assign({
      interval: 250,    // 動画状態で撮像、読み込めなかった場合の間隔。ミリ秒
      lifeTime: 60000,  // 一定時間操作がない場合の停止までのミリ秒。既定値60000
      lastGoing: 0,     // 前回カメラ起動したUNIX時刻。onGoingで状態制御に使用(一定時間操作無しなら停止)
    },opt);
    for( v.x in v.opt ){
      this[v.x] = v.opt[v.x];
      console.log(v.x+' = '+this[v.x]);
    }

    console.log('webScanner.constructor end.');
  }

  /** scanQR: QRコードスキャン
   * @param {Function} callback - 後続処理
   * @param {object} [opt={}] - オプション
   * @param {RegExp} [opt.RegExp=/.+/] - スキャン結果が適切か判断
   * @param {boolean} [opt.alert=false] - true:読み込み完了時に内容をalert表示
   * @returns {void} なし
   * callbackにはQRコードの文字列が渡される。
   */
  scanQR(callback,opt={}){
    console.log('webScanner.scanQR start. opt='+JSON.stringify(opt)+'\n',callback);

    // 1.既定値の設定
    this.RegExp = opt.RegExp || /.+/;
    this.alert = opt.alert || false;
    this.callback = callback; // 後続処理をメンバとして保存

    // 2.カメラやファインダ等の作業用DIVを追加
    this.parent.innerHTML = '';
    this.canvas = createElement({tag:'canvas'});
    this.parent.appendChild(this.canvas);
    this.video = createElement('video');
    this.ctx = this.canvas.getContext('2d');

    // 3.カメラ操作ボタン関係の定義
    // QRコードスキャンでは操作ボタンは無いので定義不要

    // 4.動画を1フレーム読み込んだ際の処理を定義
    this.scanned = this.#drawFrame;

    // 5.動画撮影用Webカメラを起動
    this.#start();
  }

  /** start: カメラを起動する(private関数)
   * @param {void} - なし
   * @returns {void} なし
   */
  #start(){
    console.log('webScanner.start start.');

    // 動画撮影用Webカメラを起動
    navigator.mediaDevices.getUserMedia({
      video: true,
      /*video: {  PCだと内蔵カメラではなくwebカメラを呼び出してしまう
        facingMode: "environment",
        //facingMode: "user",
        //facingMode: {exact:"environment"},
      },*/
      audio: false
    }).then((stream) => {
      this.video.srcObject = stream;
      this.video.setAttribute("playsinline", true);
      this.video.play();
      this.#onGoing(true);  // カメラ動作中フラグを立てる
      this.#drawFinder();  // キャンパスへの描画をスタート
    }).catch(e => {
      alert('カメラを使用できません\n'+e.message);
    });
  }

  /** onGoing: カメラの起動・停止の制御と状態参照
   * @param {boolean} - true:起動、false:停止、undefind:状態参照
   * @returns {boolean} true:起動中、false:停止中
   */
  #onGoing(arg){
    console.log('webScanner.onGoing: typeof arg='+(typeof arg)+', arg='+arg);
    let rv = null;
    const now = Date.now();
    if( typeof arg === 'boolean' ){  // 引数あり ⇒ 状態制御
      this.lastGoing = arg ? now : 0;
      rv = arg;
    } else {    // 引数無し ⇒ 状態参照
      if( (now - this.lastGoing) < this.lifeTime ){
        // 指定時間(lifeTime)内ならtrue
        rv = true;
      } else {
        // 指定時間を超えていたらfalse
        rv = false;
        // 一定時間以上操作がなかった場合(システムで停止された場合を除く)
        if( this.lastGoing > 0 ){
          alert((this.lifeTime/1000)+'秒以上操作がなかったためカメラを停止しました');
          this.#stop();
        }
      }
    }
    return rv;
  }

  /** stop: カメラを停止する(private関数)
   * @param {void} - なし
   * @returns {void} なし
   */
  #stop(){
    console.log('webScanner.stop',this.video);
    this.video.srcObject.getVideoTracks().forEach((track) => {
      track.stop();
    });
    this.parent.innerHTML = ''; // 作業用DIVを除去
    this.lastGoing = 0;
  }

  /** drawFinder: 動画をキャンバスに描画する
   * @param {void} - 無し
   * @returns {void} 無し
   * 1フレーム読み込むごとにthis.scannedに読み込んだイメージを渡す。
  */
  #drawFinder(){
    console.log('webScanner.drawFinder start.',this.video);

    // スキャン実行フラグが立っていなかったら終了
    if( !this.#onGoing() ) return;

    if(this.video.readyState === this.video.HAVE_ENOUGH_DATA){

      // 親要素の横幅に合わせて表示する
      const ratio = this.parent.clientWidth / this.video.videoWidth;
      //console.log('l.196 this.parent.clientWidth='+this.parent.clientWidth+', this.video.videoWidth='+this.video.videoWidth+' -> ratio='+ratio);
      const w = this.video.videoWidth * ratio;
      const h = this.video.videoHeight * ratio;
      //console.log('l.199 w ='+w+', h='+h);
      this.video.width = this.canvas.width = w;
      this.video.height = this.canvas.height = h;

      this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
      let img;
      try { // canvasを含む要素が削除済の場合にエラーとなるので回避
        img = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      } catch(e) {
        console.error(e.message);
        this.#stop();
        return;
      }
      // 1フレーム読み込み時の処理
      // 　※scanQRならdrawFrame, scanDocならなにもしない
      this.scanned(img);
    }
    setTimeout(()=>this.#drawFinder(), this.interval);
  }

  /** drawFrame: 動画の1フレームからQRコードを抽出、後続処理に渡す
   * @param {object} img - 読み込んだ画像
   * @returns {void} なし
   */
  #drawFrame(img){
    console.log('webScanner.drawFrame start. img=',img);
    try {
      // スキャン実行フラグが立っていなかったら終了
      if( !this.#onGoing() ) return;

      // このタイミングでQRコードを判定
      let code = jsQR(img.data, img.width, img.height, {inversionAttempts: "dontInvert"});
			if(code){
        //console.log('drawFinder: code='+JSON.stringify(code));
        // QRコード読み取り成功
				this.#drawRect(code.location);// ファインダ上のQRコードに枠を表示
        if( this.alert ) alert(code.data);  // alert出力指定があれば出力
        if( code.data.match(this.RegExp) ){  // 正しい内容が読み込まれた場合
          this.#stop();
          this.callback(code.data); // 読み込んだQRコードを引数にコールバック
        } else {
          // 不適切な、別のQRコードが読み込まれた場合
          alert('不適切なQRコードです。再読込してください。');
          console.error('webScanner.drawFinder: not match pattern. code='+code.data);
          // 再読込。drawFinderはクラス内のメソッドなのでアロー関数で呼び出す
          // MDN setTimeout() thisの問題
          // https://developer.mozilla.org/ja/docs/Web/API/setTimeout#this_%E3%81%AE%E5%95%8F%E9%A1%8C
        }
      }
    } catch(e) {
      console.error('webScanner.drawFrame: '+e.message);
    }
  }

  /** drawRect: ファインダ上のQRコードに枠を表示
   * @param {object} location - QRコード位置情報
   * @returns {void} なし
   */
  #drawRect(location){
    console.log('webScanner.drawRect location='+JSON.stringifylocation);
    this.#drawLine(location.topLeftCorner,     location.topRightCorner);
		this.#drawLine(location.topRightCorner,    location.bottomRightCorner);
		this.#drawLine(location.bottomRightCorner, location.bottomLeftCorner);
		this.#drawLine(location.bottomLeftCorner,  location.topLeftCorner);
  }

  /** drawLine: ファインダ上に線を描画
   * @param {object} begin - 始点の位置
   * @param {object} end - 終点の位置
   * @returns {void} なし
   */
  #drawLine(begin, end){
    console.log('webScanner.drawLine begin='
      + JSON.stringify(begin) + ', end=' + JSON.stringify(end));
		this.ctx.lineWidth = 4;
		this.ctx.strokeStyle = "#FF3B58";
		this.ctx.beginPath();
		this.ctx.moveTo(begin.x, begin.y);
		this.ctx.lineTo(end.x, end.y);
		this.ctx.stroke();
	}

  /** scanDoc: 文書のスキャン
   * @param {function} callback - 後続処理
   * @param {object} opt - オプション指定
   * @param {number} opt.maxImageSize - 画像をbase64化した後の最大文字長。既定値500K
   * @returns {void} 無し
   * callbackにはbase64化したpng(文字列)が渡される。
  */
  scanDoc(callback,opt={maxImageSize:500000}){

    // 1.既定値の設定
    this.callback = callback; // 後続処理をメンバとして保存

    // 2.カメラやファインダ等の作業用DIVを追加
    this.parent.innerHTML
    = '<video autoplay class="hide"></video>'
    + '<canvas></canvas>'  // 撮影結果
    + '<div class="buttons hide">'  // カメラ操作ボタン
    + '<div><input type="button" name="undo" value="◀" /></div>'
    + '<div><input type="button" name="shutter" value="[ ● ]" /></div>'
    + '<div><input type="button" name="adopt" value="▶" /></div>'
    + '</div>';
    this.video = this.parent.querySelector('video');
    this.canvas = this.parent.querySelector('canvas');
    this.ctx = this.canvas.getContext('2d');

    // 3.カメラ操作ボタン関係の定義
    this.buttons = this.parent.querySelector('div.buttons');
    this.undo = this.buttons.querySelector('input[name="undo"]');
    this.undo.disabled = true;  // 再撮影
    this.shutter = this.buttons.querySelector('input[name="shutter"]');
    this.shutter.disabled = false;  // シャッター
    this.adopt = this.buttons.querySelector('input[name="adopt"]');
    this.adopt.disabled = true;  // 採用

    // (1) 再撮影ボタンクリック時
    this.undo.addEventListener('click',() => {
      console.log('webScanner.scanDoc undo clicked.');
      this.#onGoing(true);  // カメラ動作中フラグを立てる
      this.drawFinder();  // キャンパスへの描画をスタート
      this.undo.disabled = true;
      this.shutter.disabled = false;
      this.adopt.disabled = true;
    });
    // (2) シャッタークリック時
    this.shutter.addEventListener('click',() => {
      console.log('webScanner.scanDoc shutter clicked.');
      this.#onGoing(false);  // カメラを一時停止
      this.undo.disabled = false;
      this.shutter.disabled = true;
      this.adopt.disabled = false;
    });
    // (3) 採用ボタンクリック時
    this.adopt.addEventListener('click',() => {
      console.log('webScanner.scanDoc adopt clicked.');
      // canvasからイメージをBASE64で取得
      // なお圧縮はpng不可なので、jpegとする
      let imageData = '';
      for( let i=0.9 ; i>0 ; i -= 0.1 ){
        imageData = this.canvas.toDataURL('image/jpeg',i);
        if( imageData.length < opt.maxImageSize ){
          i = -1;
        }
      }
      //console.log('l.181\n'+imageData);
      this.callback(imageData);  // base64化したpngを後続処理に渡す
      this.stop();  // スキャナを停止
    })

    // 4.動画を1フレーム読み込んだ際の処理を指定
    this.scanned = () => {};  // フレームごとの処理は無し

    // 5.カメラ操作ボタンを表示してカメラを起動
    this.buttons.classList.remove('hide');
    this.#start();
  }
}
</script>
<script type="text/javascript">
/** 
 * 変数の型を判定し、型名を文字列で返す。なお引数"is"が指定された場合、判定対象が"is"と等しいかの真偽値を返す。
 * 
 * @param {any} arg - 判定対象の変数
 * @param {string} [is] - 想定される型(型名の大文字小文字は意識不要)
 * @returns {string|boolean} - 型の名前。is指定有りなら判定対象が想定型かの真偽値
 * 
 * @example
 * ```
 * let a = 10;
 * whichType(a);  // 'Number'
 * whichType(a,'string'); // false
 * ```
 * 
 * <b>確認済戻り値一覧</b>
 * 
 * オブジェクトは型名が返るので、限定列挙は困難。以下は確認済みの戻り値のみ記載。
 * 
 * | 型名 | 戻り値 | 備考 |
 * | :-- | :-- | :-- |
 * | 文字列 | String |  |
 * | 数値 | Number |  |
 * | NaN | NaN |  |
 * | 長整数 | BigInt |  |
 * | 論理値 | Boolean |  |
 * | シンボル | Symbol |  |
 * | undefined | Undefined | 先頭大文字 |
 * | Null | Null |  |
 * | オブジェクト | Object |  |
 * | 配列 | Array |  |
 * | 関数 | Function |  |
 * | アロー関数 | Arrow |  |
 * | エラー | Error | RangeError等も'Error' |
 * | Date型 | Date |  |
 * | Promise型 | Promise |  |
 *  
 * - Qiita [JavaScriptの型などの判定いろいろ](https://qiita.com/amamamaou/items/ef0b797156b324bb4ef3)
 * 
 */

function whichType(arg,is){
  let rv = String(Object.prototype.toString.call(arg).slice(8,-1));
  switch(rv){
    case 'Number': if(Number.isNaN(arg)) rv = 'NaN'; break;
    case 'Function': if(!('prototype' in arg)) rv = 'Arrow'; break;
  }
  if( typeof is === 'string' ){
    return rv.toLowerCase() === is.toLowerCase();
  } else {
    return rv;
  }
}
</script>

<script type="text/javascript">/** camp2023でパスポート画面を作成する
 * @param {string} parent - 親要素のCSSセレクタ
 * @param {Object} config - Authから返された参加者情報
 * @returns {void}
 */
const drawPassport = (parent,config) => {
  const v = {whois:'drawPassport',step:0,rv:null,css:[
    /*
    { // 親要素
      sel : '',
      prop: {
        'width' : 'calc(100% - 2rem)',
        'height': '100%',
      }
    },
    */
    { // QRコード＋受付番号＋申込者名
      sel : '[name="entry"]',
      prop: {
        'width':'100%',
        'display'    : 'grid',
        'grid-template-columns': '300px 1fr',
        'grid-gap'   : '1rem',
      }
    },
    { // QRコード
      sel: '[name="qrcode"]',
      prop: {
        'grid-column': '1 / 2',
        'grid-row'   : '1 / 3',
      }
    },
    { // 受付番号
      sel : '[name="entryNo"]',
      prop: {
        'font-size'  : '2rem',
        'grid-column': '2 / 3',
        'grid-row'   : '1 / 2',
      }
    },
    { // 申込者氏名＋カナ
      sel : '[name="applicant"]',
      prop: {
        'grid-column': '2 / 3',
        'grid-row'   : '2 / 3',
      }
    },
    { // 申込者氏名
      sel : '[name="applicant"] ruby',
      prop: {
        'font-size'  : '2rem',
      }
    },
    { // 申込者カナ
      sel : '[name="applicant"] rt',
      prop: {
        'font-size'  : '0.8rem'
      }
    },
    { // 参加者一覧
      sel : '[name="list"]',
      prop: {
        'width':'100%',
        'margin' : '1rem 0rem',
        'display'    : 'grid',
        'grid-template-columns' : '3fr 2fr',
      }
    },
    { // 参加者名カナ
      sel : '[name="list"] rt',
      prop: {
        'font-size'  : '0.7rem',
      }
    },
    { // 詳細情報
      sel : '[name="detail"]',
      prop: {
        'margin' : '1rem 0rem',
        'display'    : 'grid',
        'grid-template-columns' : '8rem 1fr',
      }
    },
    { // editURL(申込フォーム修正)ボタン
      sel : '[name="button"] a',
      prop: {/*
        'text-decoration' : 'none',
        'margin' : '1rem',
        'display'       : 'inline-block',
        'font-size'     : '18pt',
        'text-align'    : 'center',
        'cursor'        : 'pointer',
        'padding'       : '12px 12px',
        'background'    : '#000066',
        'color'         : '#ffffff',
        'line-height'   : '1em',
        'transition'    : '.3s',
        'box-shadow'    : '3px 3px 3px #666666',
        'border'        : '2px solid #000066',
    */}
    },
    { // 
      sel : '',
      prop: {

      }
    },

  ]};
  console.log(v.whois+' start.');
  try {

    // 前準備
    v.step = 1.1; // 親要素を取得、内容を消去
    v.parent = document.querySelector(parent);
    v.parent.innerHTML = '';

    v.step = 1.2; // CSS定義
    v.style = document.createElement('style');
    document.head.appendChild(v.style);
    for( v.i=0 ; v.i<v.css.length ; v.i++ ){
      v.x = v.css[v.i];
      for( v.y in v.x.prop ){
        v.prop = parent + ' ' + v.x.sel
          + ' { ' + v.y + ' : ' + v.x.prop[v.y] + '; }\n';
        v.style.sheet.insertRule(v.prop,
          v.style.sheet.cssRules.length,
        );
      }
    }

    v.step = 2; // 受付番号(QR付)＋申込者氏名＋カナ
    v.div = createElement({
      attr:{name:'entry'},
      children: [
        {attr:{name:'qrcode'}}, // QRコード
        { // 受付番号
          attr:{name:'entryNo'},
          text: 'No.' + String(config.entryNo.value).slice(-4),
        },
        { // 申込者氏名＋カナ
          attr:{name:'applicant'},
          children:[{
            tag:'ruby',
            text: config.info['申込者氏名'],
            children:[{tag:'rt',text:config.info['申込者カナ']}]
          }]
        },
      ],
    });
    new QRCode(v.div.querySelector('[name="qrcode"]'),{
      text: String(config.entryNo.value).slice(-4),
      width: 300,
      height: 300,
      colorDark: "#000",
      colorLight: "#fff",
      correctLevel : QRCode.CorrectLevel.H,
    });
    v.parent.appendChild(v.div);

    v.step = 3; // 参加者一覧
    v.list = createElement({attr:{name:'list'}});
    v.step = 3.1; // 参加者一覧ヘッダ
    ['参加者氏名','所属'].forEach(x => {
      v.list.appendChild(createElement({
        attr:{class:'th'},text: x
      }));
    });
    v.step = 3.2; // データ(参加者氏名・所属)
    for( v.i=1 ; v.i<6 ; v.i++ ){
      v.name = '参加者0'+v.i;
      if( config.info[v.name+'氏名'].length > 0 ){
        v.list.appendChild(createElement({
          attr: {class:'td'},
          text: config.info[v.name+'氏名']
          + ' (' + config.info[v.name+'カナ'] + ')',
          /*
          children:[{
            tag:'ruby',
            text:config.info[v.name+'氏名'],
            children:[{
              tag:'rt',
              text:config.info[v.name+'カナ'],
            }]
          }]
          */
        }));
        v.list.appendChild(createElement({children:[
          {attr:{class:'td'},text:config.info[v.name+'所属']}
        ]}));
      }
    }
    v.parent.appendChild(v.list);

    v.step = 4; // その他参加者情報
    v.detail = createElement({attr:{name:'detail'}});
    ['申込者の参加','宿泊、テント','引取者氏名','緊急連絡先','ボランティア募集','備考','キャンセル'].forEach(x => {
      v.detail.appendChild(createElement({
        attr:{class:'th'},text:x
      }));
      v.detail.appendChild(createElement({
        attr:{class:'td'},text:config.info[x]
      }));
    });
    v.parent.appendChild(v.detail);

    v.step = 5; // editURL(申込フォーム修正)ボタン
    v.parent.appendChild(createElement({
      attr:{name:'button'},
      children:[
        {tag:'p',text:'上記内容に誤りがあれば下のボタンから修正してください。'},
        {
          tag:'a',
          attr:{href:config.info.editURL,target:'_blank'},
          text: '申込フォームの編集',
        }
      ]}
    ));

    console.log(v.whois+' normal end.',v.rv);
    return v.rv;

  } catch(e){
    console.error(v.whois+' abnormal end(step.'+v.step+').',e,v);
    return e;
  }

}</script>

<script type="text/javascript" class="main">
window.addEventListener('DOMContentLoaded',async () => {
  const v = {whois:'DOMContentLoaded',opt:{},debug:true,
    // 認証局
    gwURL:'https://script.google.com/macros/s/AKfycbwSvy450w3Bu3GhbBlNFGS5bJAHWi91_gEC42tTtWScAkJUjdZ35SncfXi2slktGH9h/exec',
    // 資料集
    docURL:'https://script.google.com/macros/s/AKfycbxtxS_u1BVahosczLxtt9yFS8Lh97lXEj4t7xmzCp4v1qgDft4RaSZUrbv-cMR0k03I/exec',
    docSheet: 'https://tinyurl.com/2ahyly3l',
    searchParams: new URLSearchParams(window.location.search),
  };
  console.log(v.whois+' start.');

  v.step = '1'; // 認証
  v.ls = localStorage.getItem('conf');
  // クエリ文字列のデバッグモード指定を確認
  if( v.searchParams.has('debug') ){
    v.debug = v.searchParams.get('debug').toLowerCase() === 'true';
  }
  if( v.debug && v.ls !== null ){
    v.step = '1.1';
    // デバッグ用：リリース時はlocalStorage.setItemと併せて削除
    v.opt = JSON.parse(v.ls);
    v.config = new Auth(v.gwURL,v.opt);
  } else {
    v.step = '1.2';
    // クエリ文字列で受付番号が与えられた場合、受付番号欄にセット
    if( v.searchParams.has('id') ){
      v.opt.entryNo = {value:v.searchParams.get('id')};
    }
    v.config = new Auth(v.gwURL,v.opt);
    await v.config.build();
    localStorage.setItem('conf',JSON.stringify(v.config));
  }
  console.log(v.whois+'.'+v.step+':',v.config);

  v.step = '2'; // メニューを定義
  v.menu = new BurgerMenu({
    authority: v.config.info.authority,
    home: 'c1005',  // パスポート画面
  });
  console.log(v.whois+'.'+v.step+':',v);

  v.step = '3'; // MarkDownで記述された部分をHTML化して表示
  document.querySelectorAll('div.markdown').forEach(x => {
    x.innerHTML = marked(x.innerHTML);
  });

  v.step = '4'; // PlantUMLで記述された部分をHTML化して表示
  document.querySelectorAll('div.PlantUML').forEach(x => {
    let src = x.querySelector('div').innerHTML;
    x.querySelector('img').src = "http://www.plantuml.com/plantuml/svg/"
      + plantumlEncoder.encode(src);
  });

  v.step = '5'; // Mermaidで記述された部分をHTML化して表示
  mermaid.initialize({startOnLoad: true});

  v.step = '6'; // パスポートの内容描画
  drawPassport('div[data-BurgerMenu="label:\'パスポート\'"]',v.config);
  /*
  const passportDiv = document.querySelector('div[name="パスポート"] div');
  v.entryNo = ('000'+v.config.entryNo.value).slice(-4);
  passportDiv.appendChild(createElement({
    tag:'p',
    text:'No.'+v.entryNo,
    style: {margin:"1rem 0",fontSize:"2rem"}
  }));
  qrcodeDiv = document.createElement('div');
  const qr = new QRCode(qrcodeDiv,{
    text: v.entryNo,
    width: 400,
    height: 400,
    colorDark: "#000",
    colorLight: "#fff",
    correctLevel : QRCode.CorrectLevel.H,
  });
  passportDiv.appendChild(qrcodeDiv);

  v.step = '7'; // Google Spreadからデータを取得してタイムテーブル表示
  v.res = await fetch(v.docURL);
  v.res = await v.res.json();
  v.TimeTable = new TimeTable(
    'div.TimeTable',
    v.res,
    {datatype:'sheet',dataSheet:v.docSheet}
  );

  v.step = '8'; // 受付画面を準備
  v.reception = new Reception({
    auth: v.config, // 認証局他のAuthインスタンス
    area:{selector:'[name="受付"] .page'},  // 受付画面表示エリアのCSSセレクタ
    boot:{selector:'[name="受付"]'}, // スキャナ起動のトリガーとなる要素のCSSセレクタ
    loading: {selector:'div[name="loading"]'},  // ローディング画面のCSSセレクタ
  });

  v.step = '9'; // 掲示板の表示
  v.board = new BulletinBoard({
    auth: v.config, // 認証局他のAuthインスタンス
    parent: {selector:'[name="お知らせ"] [name="掲示板"] [name="board"]'},
  });
  await v.board.delivery();
  console.log(v.whois+'.'+v.step,v.board);
 
  v.step = '10'; // 最終処理：権限により表示画面制御
  // 最終段階以前で不要な要素を削除すると「要素が見つからない」エラーが発生
  // ⇒ 最終段階で実行する
  v.authority = Number(v.config.info.authority)
  if( (v.authority & 3) === 0 ){
    v.step = '9.1'; // 1(参加者)、2(スタッフ)、3(管理者)いずれでもない
    alert('参加資格を確認してください');
    document.querySelectorAll('body > div').forEach(x => x.remove());
    return;
  } else {
    if( (v.authority & 2) === 0 ){
      v.step = '9.2'; // スタッフではない ⇒ スタッフ画面を削除
      document.querySelectorAll('div[name="スタッフ"]')
      .forEach(x => x.remove());
      // タブの数を減らす
      document.querySelector('.BurgerMenu[name="main"] .tabs')
      .style.gridTemplateColumns = 'repeat(4, 1fr)';
    }
    // ローディング画面解除
    document.querySelector('div[name="loading"]').style.display = 'none';
  } 
  */
  // ローディング画面解除
  document.querySelector('div[name="loading"]').style.display = 'none';

  console.log(v.whois+' end.');
});
</script>
</body><!-- =====================================================
  CDN
===================================================== --><!-- UML: PlantUML
  参考：JavaScriptを用いてPlantUMLを呼び出す
  https://168iroha.net/blog/topic/?id=202206081036&sorting=post_date
--></html>