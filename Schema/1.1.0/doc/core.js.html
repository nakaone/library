<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * DB構造定義オブジェクト (引数用)
 * @typedef {Object} schemaDef
 * @property {string} [dbName] - データベース名(IndexedDB上ではストア名)
 * @property {string} [note] - 備考
 * @property {Object.&lt;string, tableDef>} tableDef - テーブル構造定義名をメンバ名とするテーブル構造定義
 * @property {Object} tables - 実テーブル名をメンバ名とする実テーブルの定義
 * @property {string} [tables.def] - 使用するテーブル定義名。実テーブル名と定義名が一致する場合は省略可。
 * @property {string|Object[]} [tables.data] - テーブルに格納される初期データ
 *   - string: CSV/TSV形式。先頭行は項目名(labelの配列=header)。
 *   - Object[]: 行オブジェクトの配列
 * @property {Object.&lt;string, string>} [custom] - AlaSQLのカスタム関数。{関数名: toString()で文字列化した関数}
 */

/**
 * Schemaの戻り値となる拡張済DB構造定義オブジェクト
 * 引数用のschemaDefに以下を追加・変更したもの
 * @typedef {Object} schemaDefEx
 * @property {string} original - インスタンス化前の引数(schemaDef)をJSON文字列化したもの  
 *   (一部文字列を関数化しているため、保存時はプリミティブ変数のみ)
 * @property {string} [created] - 作成日時。export時に使用
 * @property {Function} expand - expandSchemaメソッド(公開API)。schemaDefExを再作成
 */

// =====================================================================

/**
 * テーブル構造定義オブジェクト (引数用)
 * @typedef {Object} tableDef
 * @property {string} [note] - テーブルに関する備考
 * @property {string|string[]} [primaryKey] - 主キーとなる項目名。複合キーの場合は配列で指定
 * @property {columnDef[]} colDef - 項目定義(順序を考慮するためオブジェクトでは無く配列で定義)
 * @property {number} [top=1] - シート・CSVイメージ上のヘッダ行番号
 * @property {number} [left=1] - シート・CSVイメージ上の開始列番号
 * @property {number} [startingRowNumber=2] - シート上の行番号"RowNumber"を追加する場合の開始行番号。&lt;0なら追加しない。
 */

/**
 * Schemaの戻り値となる拡張済テーブル構造定義オブジェクト
 * 引数用のtableDefに以下の項目を追加・変更したもの
 * @typedef {Object} tableDefEx
 * @property {string} name - 実テーブル名
 * @property {string[]} header - columnDef.labelの配列
 * @property {Object.&lt;string, columnObj>} cols - {columnDef.name: columnObj}
 */

// =====================================================================

/**
 * 項目定義オブジェクト (引数用)
 * @typedef {Object} columnDef
 * @property {string} name - 項目名。原則英数字で構成(システム用)
 * @property {string} [note] - 備考
 * @property {string} [label] - テーブル・シート表示時の項目名。省略時はnameを流用
 * @property {string} [type='string'] - データ型。string / number / boolean
 * @property {string[]} [alias] - 複数タイプのCSVを統一フォーマットで読み込む際の別名リスト
 * @property {any} [default=null] - 既定値。関数の場合は引数を行オブジェクトとするtoString()化された文字列
 * @property {string} [printf=null] - 表示整形用関数。引数を行オブジェクトとするtoString()化された文字列
 */

/**
 * Schemaの戻り値となる拡張済項目定義オブジェクト
 * 引数用のcolumnDefに以下の項目を追加・変更したもの
 * @typedef {Object} columnDefEx
 * @property {number} seq - 左端を0とする列番号
 */

// =====================================================================

/** Schema: シート・RDB・IndexedDB・CSV/TSVで扱うデータベース構造定義のユーティリティ集
 * - schema変更時には変更点のみexpandに渡す運用を想定(都度全体を渡さない)、クロージャ関数とする
 * @param {schemaDef} schema - DB構造定義オブジェクト(引数用)
 * @returns {schemaDefEx} DB構造定義オブジェクト(戻り値用)
 */
function Schema(schema) {
  const pv = { whois: 'Schema', schema: {},
    schemaDef: { // schemaDefEx形式の既定値。但しoriginal,created,expandはメソッド内で追加
      dbName: '',
      note: '',
      tableDef: {},
      tables: {},
      custom: {},
    },
    tableDef: { // tableDefEx形式の既定値
      def: '',
      data: [],
      note: '',
      primaryKey: [],
      colDef: [],
      top: 1,
      left: 1,
      startingRowNumber: 2,
      name: '',
      header: [],
      cols: {},
    },
    columnDef: {
      name: '',
      seq: 0,
      note: '',
      label: '',
      type: 'string',
      alias: [],
      default: null,
      printf: null,
    }
  };

  /**
   * - pv.schemaを変更前、引数schemaを修正点、v.schemaを作業用とし、最後にpv.schema=v.schemaとする
   * @param {schemaDef} schema 
   * @returns {schemaDefEx}
   */
  function expand(schema) {
    const v = { whois: `${pv.whois}.expand`, rv: null, schema:{}};
    dev.start(v.whois, [...arguments]);
    try {

      // -------------------------------------------------------------
      dev.step(1); // schema全体の処理
      // -------------------------------------------------------------

      dev.step(1.1);  // 「引数 > pv.schema > 既定値」の優先順位で値を設定
      v.schema = mergeDeeply(schema,mergeDeeply(pv.schema,pv.schemaDef));
      if( v.schema instanceof Error ) throw v.schema;

      dev.step(1.2);  // 過去のoriginalが存在していればマージして再設定
      v.schema.original = JSON.stringify(typeof pv.schema.original !== 'undefined'
      ? mergeDeeply(JSON.parse(pv.schema.original),schema) : schema);

      dev.step(1.3);  // 引数にもpv.schemaにも依存しない項目の設定
      v.schema.created = toLocale(new Date());
      v.schema.expand = expand;

      dev.step(1.4);  // customを関数化
      // 既に関数化されていた場合(再作成の場合)、何もしない
      for( v.fn in v.schema.custom ){
        if( typeof v.schema.custom[v.fn] !== 'function' )
          v.schema.custom[v.fn] = new Function('return '+v.schema.custom[v.fn])();
      }

      // -------------------------------------------------------------
      dev.step(2); // table毎の処理
      // -------------------------------------------------------------
      for( [v.name,v.table] of Object.entries(v.schema.tables) ){

        dev.step(2.1);  // テーブル構造定義名・テーブル名が省略されていた場合は設定
        if( !v.table.def ) v.table.def = v.name;
        if( !v.table.name ) v.table.name = v.name;

        dev.step(2.2);  // 「引数 > pv.schema > 既定値」の優先順位で値を設定
        v.table = mergeDeeply(v.table,mergeDeeply(v.schema.tableDef[v.table.def],pv.tableDef));

        dev.step(2.3);  // 初期データの行オブジェクト化
        if( typeof v.table.data === 'string' &amp;&amp; v.table.data !== '' ){
          // CSV/TSVを行オブジェクトに変換
          v.table.data = parseCSVorTSV(v.table.data);
          // データ型に従って値変換
          v.table.data.forEach(x => {
            for( v.i=0 ; v.i&lt;v.table.colDef.length ; v.i++ ){
              switch( v.table.colDef[v.i].type ){
                case 'number':
                  x[v.table.colDef[v.i].name] = Number(x[v.table.colDef[v.i].name]);
                  break;
                case 'boolean':
                  x[v.table.colDef[v.i].name] = x[v.table.colDef[v.i].name] === '' ? ''
                  : (String(x[v.table.colDef[v.i].name]).toLowerCase() === 'true' ? true : false);
                  break;
                default:
                  break;
              }
            }
          });
          // RowNumber不在ならRowNumberを追加
          if( v.table.startingRowNumber > 0 &amp;&amp; typeof v.table.data[0].RowNumber === 'undefined' ){
            for( v.i=0 ; v.i&lt;v.table.data.length ; v.i++ ){
              v.table.data[v.i].RowNumber = v.i + v.table.startingRowNumber;
            }
          }
        }

        // -------------------------------------------------------------
        dev.step(3); // column毎の処理
        // -------------------------------------------------------------
        for( v.c=0 ; v.c&lt;v.table.colDef.length ; v.c++ ){

          dev.step(3.1);  // 未定義項目に既定値設定
          v.colObj = Object.assign({},pv.columnDef,v.table.colDef[v.c]);

          dev.step(3.2);  // default,printfを関数化
          ['default','printf'].forEach(x => {
            if( v.colObj[x] !== null &amp;&amp; typeof v.colObj[x] !== 'function' )
              v.colObj[x] = new Function('return '+v.colObj[x])();
          });

          dev.step(3.3);  // seq,labelの設定、tables.headerへの登録
          v.colObj.seq = v.c;
          if( !v.colObj.label ) v.colObj.label = v.colObj.name;
          v.table.header.push(v.colObj.label);

          dev.step(3.4);  // 項目マップに登録
          dev.dump(v.colObj,194);
          // キーは①項目名(name)、②ラベル(label)、③別名(alias)、④出現順(数字)
          v.keys = Array.from(new Set([
            v.colObj.name,
            v.colObj.label,
            ...v.colObj.alias,
            v.c
          ]));
          dev.dump(v.keys,v.table.cols,202);
          // a = Array.from(new Set([1,2]));
          v.keys.forEach(x => v.table.cols[x] = v.colObj);

        }

        dev.step(2.4);  // table毎の処理：作成したtableをschemaに登録して終了
        v.schema.tables[v.name] = v.table;
      }
      
      dev.end(); // 終了処理
      pv.schema = v.schema;
      return pv.schema;

    } catch (e) { dev.error(e); return e; }
  }

  /**
   * CSV/TSV 文字列をオブジェクトの配列に変換する
   * - 区切り文字を自動判定（カンマ or タブ）
   * - ダブルクォートあり/なし両対応
   * - RFC4180 準拠（"" は "）
   *
   * @param {string} text - CSV/TSV 文字列
   * @param {object} [options]
   * @param {boolean} [options.headers=true] 1行目をヘッダ行として使うか
   * @param {boolean} [options.trim=true] フィールドの前後空白を削除するか
   * @returns {Object[] | string[][]}
   */
  function parseCSVorTSV(text, options = {}) {
    const { headers = true, trim = true } = options;

    if (typeof text !== "string") throw new TypeError("text must be a string");
    if (text.charCodeAt(0) === 0xfeff) text = text.slice(1); // BOM 除去

    // --- 区切り文字を自動判定 ---
    const firstLine = text.split(/\r?\n/)[0];
    const commaCount = (firstLine.match(/,/g) || []).length;
    const tabCount = (firstLine.match(/\t/g) || []).length;
    const delimiter = tabCount > commaCount ? "\t" : ",";

    const rows = [];
    let cur = "";
    let row = [];
    let inQuotes = false;
    let i = 0;

    while (i &lt; text.length) {
      const ch = text[i];

      if (ch === '"') {
        if (!inQuotes) {
          inQuotes = true;
          i++;
          continue;
        } else {
          if (i + 1 &lt; text.length &amp;&amp; text[i + 1] === '"') {
            cur += '"'; // エスケープされた "
            i += 2;
            continue;
          } else {
            inQuotes = false;
            i++;
            continue;
          }
        }
      }

      if (!inQuotes &amp;&amp; ch === delimiter) {
        row.push(trim ? cur.trim() : cur);
        cur = "";
        i++;
        continue;
      }

      if (!inQuotes &amp;&amp; (ch === "\n" || ch === "\r")) {
        row.push(trim ? cur.trim() : cur);
        rows.push(row);
        row = [];
        cur = "";

        if (ch === "\r" &amp;&amp; text[i + 1] === "\n") i++;
        i++;
        continue;
      }

      cur += ch;
      i++;
    }

    row.push(trim ? cur.trim() : cur);
    rows.push(row);

    if (!headers) return rows;

    const headerRow = rows.shift() || [];
    return rows.map(r => {
      const obj = {};
      for (let j = 0; j &lt; headerRow.length; j++) {
        const key = headerRow[j] || `col${j}`;
        obj[key] = r[j] !== undefined ? r[j] : "";
      }
      return obj;
    });
  }

  // -------------------------------------------------------------
  // メイン処理
  // -------------------------------------------------------------
  dev.start(pv.whois, [...arguments]);
  try {

    dev.step(1);
    pv.rv = expand(schema);
    if( pv.rv instanceof Error ) throw pv.rv;

    dev.end(); // 終了処理
    return pv.rv;

  } catch (e) { dev.error(e); return e; }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#Schema">Schema</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Sep 16 2025 11:56:59 GMT+0900 (日本標準時)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
