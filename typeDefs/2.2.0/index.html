<!DOCTYPE html><html xml:lang="ja" lang="ja"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css"></style>
<script src="https://cdn.jsdelivr.net/npm/alasql@4.4.0/dist/alasql.min.js"></script>
</head>
<body>
  <div class="TypeDefs">
    <div name="pId" style="display:none"><?= pId ?></div>
    <div name="data" style="display:none"><?= data ?></div>
  </div>
</body>
<script type="text/javascript">
/** HTMLElementを生成する
 * @param {CEDefObj|CEDefObj[]} arg - 生成するHTMLElementの定義
 * @param {HTMLElement|string} [parent=null] - 本関数内部で親要素への追加まで行う場合に指定
 * @returns {HTMLElement|Error}
 */
function createElement(arg,parent=null){
  const v = {whois:'createElement',rv:[],step:0};
  console.log(`${v.whois} start.\narg=${JSON.stringify(arg)}\nparent`,parent);
  console.log(v.whois+' start.',arg);
  try {
    v.step = 1.1; // 引数を強制的に配列化
    v.isArr = Array.isArray(arg); // 引数が配列ならtrue。戻り値にも使用するので保存
    if( !v.isArr ) arg = [arg];
    v.step = 1.2; // 親要素の特定
    if( parent !== null ){
      v.parent = typeof parent === 'string' ? document.querySelector(parent) : parent;
    }


    for( v.i = 0 ; v.i<arg.length ; v.i++ ){
      v.step = 2; // 既定値の設定
      v.def = {tag:'div',attr:{},logical:{},style:{},event:{},text:'',html:'',children:[],name:''};
      Object.assign(v.def,(typeof arg[v.i] === 'string' ? {tag:arg} : arg[v.i]))

      v.step = 3; // HTMLElementを生成、v.nodeとする
      v.node = document.createElement(v.def.tag);

      v.step = 4; // HTMLElementの属性を定義
      for( v.j in v.def.attr ){
        v.node.setAttribute(v.j,v.x = v.def.attr[v.j]);
      }

      v.step = 5; // 論理属性を定義(ex.checked)
      for( v.j in v.def.logical ){
        if( v.def.logical[v.j] ){
          v.node.setAttribute(v.j,v.def.logical[v.j]);
        }
      }

      v.step = 6; // style属性の定義
      for( v.j in v.def.style ){
        if( v.j.match(/^\-\-/) ){ // CSS変数
          v.node.style.setProperty(v.j,v.def.style[v.j]);
        } else {
          v.node.style[v.j] = v.def.style[v.j];
        }
      }

      v.step = 7; // イベントの定義
      for( v.j in v.def.event ){
        v.node.addEventListener(v.j,v.def.event[v.j],false);
      }

      v.step = 8; // 内部文字列(html or text)
      if( v.def.html.length > 0 ){
        v.node.innerHTML = v.def.html;
      } else {
        // textareaの場合はvalueに、それ以外はinnerTextに内部文字列(text)をセット
        v.node[v.def.tag.toLowerCase()==='textarea'?'value':'innerText'] = v.def.text;
      }

      v.step = 9; // 子要素の追加(parentは指定しない)
      for( v.j=0 ; v.j<v.def.children.length ; v.j++ ){
        v.node.appendChild(this.createElement(v.def.children[v.j]));
      }

      v.step = 10; // 戻り値への登録
      v.rv.push(v.node);

      v.step = 11; // 親要素への追加
      if( parent !== null ){
        v.parent.appendChild(v.node);
      }

      v.step = 12; // メンバとして、また切替画面として登録
      if( v.def.name.length > 0 ){
        this[v.def.name] = v.node;
        this.screenList[v.def.name] = v.node;
      }
    }

    v.step = 12; // 配列で渡されたら配列で、オブジェクトならオブジェクトを返す
    v.rv = v.isArr ? v.rv : v.rv[0];
    console.log(`${v.whois} normal end.\nv.rv=${JSON.stringify(v.rv)}`);
    return v.rv;

  } catch(e){
    console.error(v.whois+' abnormal end(step.'+v.step+').',e,v);
    return e;
  }
}

/** サーバ側GASの指定関数を実行、結果を取得
 * 
 * - [GASのgoogle.script.runをPromise化する](https://www.330k.info/essay/gas_google_script_run_convert_promise/)
 * 
 * @exsample
 * 
 * <pre><code>
 * (async ()=> {
 *   const result1 = await doGAS('doSomething1');
 *   const result2 = await doGAS('doSomething2');
 *   const result3 = await doGAS('doSomething3');
 * })();
 * </code></pre>
 * 
 * doSomething(arg1, arg2, ...)のように引数を渡す時は以下のようにdoGASの第2引数以下に指定する。
 * ```
 * doGAS('doSomething', arg1, arg2);
 * ```
 */
function doGAS(func, ...args){
  console.log('doGAS start. func=%s',func,...args);
  return new Promise(function(resolve, reject){
    google.script.run.withSuccessHandler(function(...e){
      resolve(...e);
    }).withFailureHandler(function(...e){
      reject(...e);
    })[func](...args);
  });
}

function mergeDeeply(pri,sub,opt={}){
  const v = {whois:'mergeDeeply',rv:null,step:0,
    isObj: arg => arg && String(Object.prototype.toString.call(arg).slice(8,-1)) === 'Object',
    isArr: arg => arg && Array.isArray(arg),
  };
  //console.log(`${v.whois} start.`+`\npri=${stringify(pri)}`+`\nsub=${stringify(sub)}`+`\nopt=${stringify(opt)}`);
  try {

    v.step = 1; // 既定値の設定
    if( !opt.hasOwnProperty('array') ) opt.array = 'set';

    if( v.isObj(pri) && v.isObj(sub) ){
      v.step = 2; // sub,pri共にハッシュの場合
      v.rv = {};
      v.step = 2.1; // 優先・劣後Obj両方のハッシュキー(文字列)を、重複しない形でv.keysに保存
      v.keys = new Set([...Object.keys(pri),...Object.keys(sub)]);
      for( v.key of v.keys ){
        if( pri.hasOwnProperty(v.key) && sub.hasOwnProperty(v.key) ){
          v.step = 2.2; // pri,sub両方がキーを持つ
          if( v.isObj(pri[v.key]) && v.isObj(sub[v.key]) || v.isArr(pri[v.key]) && v.isArr(sub[v.key]) ){
            v.step = 2.21; // 配列またはオブジェクトの場合は再帰呼出
            v.rv[v.key] = mergeDeeply(pri[v.key],sub[v.key],opt);
          } else {
            v.step = 2.22; // 配列でもオブジェクトでもない場合は優先変数の値をセット
            v.rv[v.key] = pri[v.key];
          }
        } else {
          v.step = 2.3; // pri,subいずれか片方しかキーを持っていない
          v.rv[v.key] = pri.hasOwnProperty(v.key) ? pri[v.key] : sub[v.key];
        }
      }
    } else if( v.isArr(pri) && v.isArr(sub) ){
      v.step = '3 '+opt.array; // sub,pri共に配列の場合
      switch( opt.array ){
        case 'pri':
          // pri: 単純にpriをセット。subは全て廃棄 ⇒ [1,2,{x:'a'},{a:10,b:20}]
          v.rv = pri;
          break;
        case 'add':
          // add: 値の重複に拘わらず、pri+subを返す ⇒ [1,2,{x:'a'},{a:10,b:20},1,3,{x:'a'},{a:30,c:40}]
          v.rv = [...pri, ...sub];
          break;
        case 'str':
          // str(strict): priに無いsubの要素をpriに追加。setと異なり、内容が同値なら重複排除<br>
          // ⇒ [1,2,3,{x:'a'},{a:10,b:20},{a:30,c:40}]
          v.rv = [];
          pri.forEach(x => v.rv.push(x));
          sub.forEach(s => {
            v.flag = false;
            pri.forEach(p => v.flag = v.flag || isEqual(s,p));
            if( v.flag === false ) v.rv.push(s);
          });
          break;
        default:
          // set(既定値): priに無いsubの要素をpriに追加 ⇒ [1,2,{x:'a'},{a:10,b:20},3,{x:'a'},{a:30,c:40}]
          v.rv = [...new Set([...pri,...sub])];
      }
    } else {
      v.step = 4; // subとpriのデータ型が異なる ⇒ priを優先してセット
      v.rv = whichType(pri,'Undefined') ? sub : pri;
    }
    v.step = 5;
    //console.log(`${v.whois} normal end.`+`\npri=${stringify(pri)}`+`\nsub=${stringify(sub)}`+`\nopt=${stringify(opt)}`+`\nv.rv=${stringify(v.rv)}`)
    return v.rv;

  } catch(e) {
    e.message = `${v.whois} abnormal end at step.${v.step}`
    + `\n${e.message}`
    + `\npri=${JSON.stringify(pri)}`
    + `\nsub=${JSON.stringify(sub)}`
    + `\nopt=${JSON.stringify(opt)}`;
    console.error(`${e.message}\nv=${JSON.stringify(v)}`);
    return e;
  }
}

function stringify(variable,opt={addType:false}){
  const v = {whois:'stringify',rv:null,step:0};
  const conv = arg => {
    const w = {type:whichType(arg)};
    w.pre = opt.addType ? `[${w.type}]` : '';
    switch( w.type ){
      case 'Function': case 'Arrow': case 'Symbol':
        w.rv = w.pre + arg.toString(); break;
      case 'BigInt':
        w.rv = w.pre + parseInt(arg); break;
      case 'Undefined':
        w.rv = w.pre + 'undefined'; break;
      case 'Object':
        w.rv = {};
        for( w.i in arg ){
          // 自分自身(stringify)は出力対象外
          if( w.i === 'stringify' ) continue;
          w.rv[w.i] = conv(arg[w.i]);
        }
        break;
      case 'Array':
        w.rv = [];
        for( w.i=0 ; w.i<arg.length ; w.i++ ){
          w.rv[w.i] = conv(arg[w.i]);
        }
        break;
      default:
        w.rv = w.pre + arg;
    }
    return w.rv;
  };
  //console.log(`${v.whois} start.\nvariable=${variable}\nopt=${JSON.stringify(opt)}`);
  try {

    v.step = 1; // 事前準備
    if( typeof opt === 'boolean' ) opt={addType:opt};

    v.step = 2; // 終了処理
    //console.log(`${v.whois} normal end.`);
    return JSON.stringify(conv(variable));

  } catch(e) {
    e.message = `${v.whois} abnormal end at step.${v.step}`
    + `\n${e.message}`;
    console.error(`${e.message}\nv=${JSON.stringify(v)}`);
    return e;
  }
}

function toLocale(dObj,format='yyyy/MM/dd'){
  const v = {rv:format,l:{ // 地方時ベース
    y: dObj.getFullYear(),
    M: dObj.getMonth()+1,
    d: dObj.getDate(),
    h: dObj.getHours(),
    m: dObj.getMinutes(),
    s: dObj.getSeconds(),
    n: dObj.getMilliseconds()
  }};
  try {

    v.step = 1; // 無効な日付なら空文字列を返して終了
    if( isNaN(dObj.getTime()) ) return '';

    v.step = 2; // 日付文字列作成
    for( v.x in v.l ){
      v.m = v.rv.match(new RegExp(v.x+'+'));
      if( v.m ){
        v.str = v.m[0].length > 1
          ? ('000'+v.l[v.x]).slice(-v.m[0].length)
          : String(v.l[v.x]);
        v.rv = v.rv.replace(v.m[0],v.str);
      }
    }

    v.step = 3; // 終了処理
    return v.rv;

  } catch(e){
    console.error(e,v);
    return e;
  }
}

function whichType(arg,is){
  let rv = String(Object.prototype.toString.call(arg).slice(8,-1));
  switch(rv){
    case 'Number': if(Number.isNaN(arg)) rv = 'NaN'; break;
    case 'Function': if(!('prototype' in arg)) rv = 'Arrow'; break;
  }
  if( typeof is === 'string' ){
    return rv.toLowerCase() === is.toLowerCase();
  } else {
    return rv;
  }
}

/**
 * @classdesc 待機画面を表示する
 */
class LoadingIcon {
  /**
   * @constructor
   * @param {Object} [arg={}] - オプション
   * @param {HTMLElement} [arg.pattern='loading5'] - デザインパターン(CSSのクラス名)
   *
   * - [CSS Loaders](https://css-loaders.com/bars/)
   */
  constructor(arg={}){
    const v = {whois:this.constructor.name+'.constructor',rv:true,step:0,
      css: { theSpinner23: `
        dialog.LoadingIcon {
          width: 400px; /* .loader width * 2 */
          aspect-ratio: 1;
          position: relative;
          outline: none;
          border: none;
        }
        dialog.LoadingIcon::backdrop {background:#fff}
        dialog.LoadingIcon > div {
          position: absolute;
          top: 50%;
          left: 50%;
          margin: -100px 0 0 -100px;
        }

        /* HTML: <div class="loader"></div> */
        .loader {
          width: 200px;   /* ここは修正 */
          aspect-ratio: 1;
          display: grid;
          border-radius: 50%;
          background:
            linear-gradient(0deg ,rgb(0 0 0/50%) 30%,#0000 0 70%,rgb(0 0 0/100%) 0) 50%/8% 100%,
            linear-gradient(90deg,rgb(0 0 0/25%) 30%,#0000 0 70%,rgb(0 0 0/75% ) 0) 50%/100% 8%;
          background-repeat: no-repeat;
          animation: l23 1s infinite steps(12);
        }
        .loader::before,
        .loader::after {
          content: "";
          grid-area: 1/1;
          border-radius: 50%;
          background: inherit;
          opacity: 0.915;
          transform: rotate(30deg);
        }
        .loader::after {
          opacity: 0.83;
          transform: rotate(60deg);
        }
        @keyframes l23 {
          100% {transform: rotate(1turn)}
        }
      `},
    };
    console.log(`${v.whois} start.\narg=${stringify(arg)}`);
  try {

      v.step = 1; // 事前準備：argの既定値設定
      if( !arg.hasOwnProperty('pattern') ) arg.pattern = 'theSpinner23';

      v.step = 2; // 待機画面要素の準備
      this.screen = document.querySelector('.'+this.constructor.name);
      if( this.screen === null ){
        this.screen = createElement({
          tag:'dialog',
          attr:{class:this.constructor.name},
          children:[{attr:{class:'loader '+arg.pattern}}],
        },'body');
        if( this.screen instanceof Error ) throw this.screen;
      }

      v.step = 3; // styleの準備
      if( document.querySelector(`style[name="${this.constructor.name}_${arg.pattern}"]`) === null ){
        v.r = createElement({
          tag: 'style',
          attr: {type:'text/css',name:`${this.constructor.name}_${arg.pattern}"]`},
          text: v.css[arg.pattern].replaceAll(/\n/g,'').replaceAll(/\s+/g,' '),
        },'head');
      }

      v.step = 9; // 終了処理
      this.hide();
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;
  
    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** 待機画面を表示する */
  show = () => this.screen.showModal();

  /** 待機画面を隠蔽する */
  hide = () => this.screen.close();
}

class TypeDefs {
  constructor(arg={}){
    const v = {whois:this.constructor.name+'.constructor',rv:null,step:0,default:{
      showDeleted: true,
      maxDepth: 20, // 最深階層数。永久ループ防止用
      proto:{trans:JSON.stringify({node:{update:[],delete:[]},leaf:{update:[],delete:[]}})},
      iDef:{  /* 行タイプ別のitem領域(attribute)作成関連の定義
        proto: {項目名:新規作成時の既定値,..}
        ctrl: 子要素を持つ可能性がある(▶▼●)ならtrue、無い(常時□)ならfalse
        disp: 一行分のデータを引数に、item領域のchildren(createElement用配列)を返す関数
        edit: 一行分のデータを引数に、編集画面のchildren(createElement形式)を返す関数
        */
        variable: {
          proto: {label:'',type:'',role:'',note:''},
          ctrl: true,
          disp: x => {  // 変数型の行の出力定義
            const v = {rv:[{
              // 必須のlabelは事前にセット
              tag  : 'span',
              html : x.attribute.label || '',
              attr : Object.assign({name:'label'},this.linkTip(x)),
            }]};
            // 任意項目を順次追加
            if( x.attribute.type ){ v.rv.push({
              tag:'span',html:' '
            },{
              tag  : 'span',
              html : x.attribute.type || '',
              attr : {name:'type'},
            })}
            if( x.attribute.role ){ v.rv.push({
              tag:'span',html:' '
            },{
              tag  : 'span',
              html : x.attribute.role || '',
              attr : {name:'role'},
            })}
            if( x.attribute.note ){ v.rv.push({
              tag:'br'
            },{
              tag  : 'span',
              html : x.attribute.note || '',
              attr : {name:'note'},
            })}
            return v.rv;
          },
          edit: x => {
            const v = {rv:[
              {attr:{class:'tr'},children:[
                {attr:{class:'th'},text:'label'},
                {tag:'input',attr:{name:'label',class:'td',value:x.attribute.label || ''}},
              ]},
              {attr:{class:'tr'},children:[
                {attr:{class:'th'},text:'type'},
                {tag:'input',attr:{name:'type',class:'td',value:(x.attribute.type || '')}},
              ]},
              {attr:{class:'tr'},children:[
                {attr:{class:'th'},text:'role'},
                {tag:'input',attr:{name:'role',class:'td',value:(x.attribute.role || '')}},
              ]},
              {attr:{class:'tr'},children:[
                {attr:{class:'th'},text:'note'},
                {tag:'textarea',attr:{name:'note',class:'td',value:(x.attribute.note || '')}},
              ]},
            ]};
            return v.rv;
          },
        },
        branch: {
          proto: {label:'',note:''},
          ctrl: true,
          disp: x => {  // ブランチ行(グループまとめ)の出力定義
            const v = {rv:[{
              tag  : 'span',
              html : x.attribute.label || '',
              attr : Object.assign({name:'label'},this.linkTip(x)),
            }]};
            // noteが有れば追加
            if( x.attribute.note ){ v.rv.push({
              tag:'br'
            },{
              tag  : 'span',
              html : x.attribute.note || '',
              attr : {name:'note'},
            })};
            return v.rv;
          },
          edit: x => {
            const v = {rv:[
              {attr:{class:'tr'},children:[
                {attr:{class:'th'},text:'label'},
                {tag:'input',attr:{name:'label',class:'td',value:x.attribute.label || ''}},
              ]},
              {attr:{class:'tr'},children:[
                {attr:{class:'th'},text:'note'},
                {tag:'textarea',attr:{name:'note',class:'td'},text:(x.attribute.note || '')},
              ]},
            ]};
            return v.rv;
          },
        },
        comment: {
          proto: {label:''},
          ctrl: false,
          disp: x => { // コメント行の出力定義
            const v = {rv:[{
              tag  : 'span',
              html : x.attribute.label || '',
              attr : Object.assign({name:'label',class:'comment'},this.linkTip(x)),
            }]};
            return v.rv;
          },
          edit: x => {
            const v = {rv:[
              {attr:{class:'tr'},children:[
                {attr:{class:'th'},text:'label'},
                {tag:'input',attr:{name:'label',class:'td',value:x.attribute.label || ''}},
              ]},
            ]};
            return v.rv;
          },
        },
      },
      tDef: { // テーブル定義
        node: {
          nId      : 'int not null primary key default 0',
          pId      : 'int not null default 0',
          seq      : 'int not null default 0',
          lId      : 'int not null default 0',
          type     : 'string not null',
          isOpen   : 'boolean default false', // ローカル側のみ保持する項目
          selected : 'boolean default false', // ローカル側のみ保持する項目
          created  : 'string not null', // yyyy/MM/dd hh:mm:ss.nnn
          updated  : 'string default null',
          deleted  : 'string default null',
        },
        leaf: {
          lId      : 'int not null primary key default 0',
          attribute: 'json not null',
          created  : 'string not null', // yyyy/MM/dd hh:mm:ss.nnn
          updated  : 'string default null',
          deleted  : 'string default null',
        },
      },
      css: `
        /* ツリー描画領域 */
        .TypeDefs .tree, .tr {display: grid; width: 100%;}
        .TypeDefs .tree .tr {grid-template-columns: repeat(21,1rem) 1fr; gap:0.2rem; width:100%}
        .TypeDefs .tree .tr.deleted {color:#aaa; text-decoration: line-through;}
        .TypeDefs .tree .th {grid-column: 1/3;}
        .TypeDefs .tree .td {grid-column: 3/13; width: 100%;}
        .TypeDefs .tree .ctrl {color:#aaa}
        .TypeDefs .tree .comment {background-color: #ccc; padding: 0 3rem;}
        .TypeDefs .tree span.link[name="label"] {color:#00f}

        /* ダイアログ共通 */
        .TypeDefs dialog {box-shadow: 0px 20px 36px 0px rgba(0, 0, 0, 0.6);width: 10rem;}
        .TypeDefs dialog::backdrop {backdrop-filter: blur(8px);}
        /* context: 右ボタンメニュー */
        .TypeDefs dialog.context > div, dialog.context button {width: 100%;margin: 0.3rem 0;}
        .TypeDefs dialog.context [name="arrow"] {display: grid;gap: 1rem;grid-template-columns: repeat(4, 1fr);}
        .TypeDefs dialog.context [name="arrow"] > div {text-align: center;background-color: #ccc;}
        /* edit: attribute編集用ダイアログ */
        .TypeDefs dialog.edit { width: 25rem; }
        /* validation: 有効/無効変更指定ダイアログ */

        /* 待機画面
          CSSだけでツールチップを実現する方法
          https://so-zou.jp/web-app/tech/css/sample/tooltip.htm */
        .TypeDefs .tooltip a:hover {position: relative;}
        .TypeDefs .tooltip a:hover:after {content: attr(title);
          /* 位置 */
          position: absolute;
          left: 0;
          top: 32px;
          z-index: 1;
          /* 文字 */
          font-weight: normal;
          color: black;
          white-space: nowrap;
          /* 背景 */
          background-color: white;
          padding: 3px;
          border: 1px silver solid;
          border-radius: 3px;
          box-shadow: 1px 1px 3px silver;
        }
      `,
    }};
    console.log(`${v.whois} start.\narg=${JSON.stringify(arg)}`);
    try {

      // ---------------------------------------------------
      v.step = 1; // 既定値を設定、データを取得(this.raw)
      // ---------------------------------------------------
      // サーバ側から渡されるマスタ(JSON)が格納される領域
      this.raw = JSON.parse(document.querySelector(arg.dataDiv || 'div[name="data"]').innerText);
      // サーバ側から渡されるルートのID
      this.rootId = Number(document.querySelector(arg.pId || 'div[name="pId"]').innerText);
      // 引数とv.defaultで設定された既定値からメンバ作成
      Object.keys(v.default).forEach(x => 
        this[x] = whichType(v.default[x],'Object')
        ? mergeDeeply((arg[x]||{}),v.default[x])
        : (arg[x] || v.default[x])
      );

      // ---------------------------------------------------
      v.step = 2; // データベース化
      // ---------------------------------------------------
      Object.keys(this.tDef).forEach(tableName => {
        v.step = 2.1; // テーブルの作成
        v.cols = Object.keys(this.tDef[tableName]);
        v.sql = '';
        v.cols.forEach(colName => {
          v.sql += `\`${colName}\` ${this.tDef[tableName][colName]},`;
        });
        v.sql = `create table ${tableName} (${v.sql.slice(0,v.sql.length-1)});`;
        v.r = alasql(v.sql);
        if( v.r instanceof Error ) throw v.r;

        v.step = 2.2; // データのセット
        this.raw[tableName].forEach(row => {
          v.cols = []; v.vals = [];
          Object.keys(row).forEach(col => {
            if( row[col] || row[col] === 0 ){
              v.cols.push('`'+col+'`');
              v.colType = this.tDef[tableName][col].split(' ')[0].toLowerCase();
              v.vals.push(v.colType === 'json'
                ? '@' + row[col]  // JSONは@をつける
                : ( v.colType === 'string' || v.colType === 'date'
                  ? '"' + row[col] + '"' // string,dateはダブルクォーテーションで囲む
                  : row[col] // number,booleanはそのまま使用
              ));
            }
          });
          v.sql = `insert into ${tableName}`
          + ` (${v.cols.join()}) values (${v.vals.join()})`;
          v.r = alasql(v.sql);
          if( v.r instanceof Error ) throw v.r;
        });
      });

      // ---------------------------------------------------
      v.step = 3; // ツリー描画領域・ダイアログ・ツールチップの準備
      // ---------------------------------------------------
      v.step = 3.1; // ツリー描画領域
      this.wrapper = document.querySelector('body > .'+this.constructor.name);
      this.treeDiv = createElement({
        attr:{class:'tree'}
      },this.wrapper);

      v.step = 3.2; // コンテキストメニュー(右ボタンメニュー)
      v.step = 3.21; // 行タイプ選択用プルダウンの選択肢をセット
      v.opt = [];
      Object.keys(this.iDef).forEach(x =>
        v.opt.push({tag:'option',attr:{value:x},text:x}));
      v.step = 3.22; // 右ボタンメニューダイアログの作成
      this.contextDialog = createElement({
        tag:'dialog',
        attr:{class:'context'},
        // Zenn <dialog>要素に「ダイアログの外側クリックで閉じる」処理の追加
        // https://zenn.dev/de_teiu_tkg/articles/96a46374655e56
        event:{'click':(event) => {
          if( event.target.closest('[name="container"]') === null ){
            this.contextDialog.close();
            this.editDialog.close();
            this.validationDialog.close();
          }
        }},
        children:[
          {attr:{name:'container'},children:[
            {attr:{name:'label'}},
            {tag:'button',attr:{name:'edit'},text:'編集',event:{click:e=>this.context(e)}},
            {tag:'button',attr:{name:'append'},text:'追加',event:{click:e=>this.context(e)},
              children:[{tag:'select',children:v.opt,style:{marginLeft:'2rem'}}]},
            {tag:'button',attr:{name:'copy'},text:'複写',event:{click:e=>this.context(e)}},
            {tag:'button',attr:{name:'paste'},text:'貼付',event:{click:e=>this.context(e)}},
            {tag:'button',attr:{name:'setValidation'},text:'無効化',event:{click:e=>this.context(e)}},
            {tag:'button',attr:{name:'delete'},text:'削除',event:{click:e=>this.context(e)}},
            {attr:{name:'arrow'},children:[
              {attr:{name:'levelUp'},text:'◀',event:{click:e=>this.context(e)}},
              {attr:{name:'moveForward'},text:'▲',event:{click:e=>this.context(e)}},
              {attr:{name:'moveLater'},text:'▼',event:{click:e=>this.context(e)}},
              {attr:{name:'levelDown'},text:'▶',event:{click:e=>this.context(e)}},
            ]},
          ]},
        ]
      },this.wrapper);

      v.step = 3.3; // attribute編集用ダイアログの作成
      this.editDialog = createElement({
        tag:'dialog',
        attr:{class:'edit'},
        event:{'click':(event) => {
          if( event.target.closest('[name="container"]') === null ){
            this.contextDialog.close();
            this.editDialog.close();
            this.validationDialog.close();
          }
        }},
        children:[{attr:{name:'container'},children:[]}]
      },this.wrapper);

      v.step = 3.4; // 有効/無効変更指定ダイアログ
      this.validationDialog = createElement({
        tag:'dialog',
        attr:{class:'validation'},
        event:{'click':(event) => {
          if( event.target.closest('[name="container"]') === null ){
            this.contextDialog.close();
            this.editDialog.close();
            this.validationDialog.close();
          }
        }},
        children:[
          {attr:{name:'container'},children:[
            {tag:'input',attr:{type:'checkbox',name:'isInvalid'}},
            {tag:'span',text:'無効化する'},
            {tag:'hr'},
            {tag:'input',attr:{type:'checkbox',name:'hideDeleted'}},
            {tag:'span',text:'無効行は表示しない'},
            {children:[
              {tag:'button',attr:{name:'submit'},text:'更新'},
              {tag:'button',attr:{name:'cancel'},text:'取消'},
            ]},
          ]}
        ],
        style:{width:'15rem'},
      },this.wrapper);

      v.step = 3.5; // 待機画面の準備
      this.loading = new LoadingIcon();

      v.step = 3.6; // スタイルシートの準備
      if( document.querySelector(`style[name="${this.constructor.name}"]`) === null ){
        v.r = createElement({
          tag: 'style',
          attr: {type:'text/css',name:this.constructor.name},
          text: this.css.replaceAll(/\/\*[\s\S]+?\*\//g,'').replaceAll(/\n/g,' ').replaceAll(/ +/g,' ').trim(),
        },'head');
        if( v.r instanceof Error ) throw v.r;
      }

      // ---------------------------------------------------
      v.step = 4; // ツリーを描画
      // ---------------------------------------------------
      v.r = this.disp();
      if( v.r instanceof Error ) throw v.r;

      v.step = 9; // 終了処理
      console.log(`${v.whois} normal end.\nv.rv=${JSON.stringify(v.rv)}`);

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** disp: 描画領域にツリーを描画
   * @param {number} nId - 描画対象のルート要素のnId
   * @param {number[]} path=[] - ツリーの階層(ルートから自要素までのnIdの配列)
   * @returns {null}
   */
  disp(nId=this.rootId,path=[]){
    const v = {whois:this.constructor.name+'.disp',rv:null,step:0};
    console.log(`${v.whois} start.\nnId=${nId}, path=${stringify(path)}`);
    try {

      v.step = 1; // 事前準備
      v.step = 1.1; // pathを別オブジェクト化
      v.path = JSON.parse(JSON.stringify(path));
      v.step = 1.2; // 永久ループ防止
      if( v.path.length > this.maxDepth ) throw new Error('too many depth');
      v.step = 1.3; // ルート要素のみの処理
      if( v.path.length === 0 ){
        this.treeDiv.innerHTML = ''; // 表示領域をクリア
      }

      v.step = 2; // 自要素を描画
      v.step = 2.1; // 自要素のnodeオブジェクトをv.nodeとして取得
      v.sql = 'select node.nId, node.pId, node.seq, node.type'
      + ', node.isOpen, node.`selected`' // ローカル側のみの項目
      + ', node.`deleted`, leaf.lId, leaf.attribute'
      + ' from node inner join leaf on node.lId=leaf.lId where '
      + (this.showDeleted ? '' : 'node.`deleted` is null and ');
      v.node = alasql(v.sql+'node.nId='+nId)[0];
      if( !v.node ){  // 削除済だった場合、空集合 ⇒ 以降の処理をスキップ
        console.log(`${v.whois} normal end. (empty node)`);
        return v.rv;
      }
      v.path.push(nId);

      v.step = 2.2; // lIdが他のブランチにも存在するならv.node.linkにツールチップ用文字列を設定
      // v.node.link = [
      //   [  ※ルートから自要素まで、node+leafのオブジェクトを並べる
      //      {nId:0,lId:0,attribute:{label:'root'}}, 
      //      {nId:1,lId:1,attribute:{label:'祖父母要素'}},
      //      {nId:5,lId:2,attribute:{label:'親要素'}},
      //      {nId:9,lId:5,attribute:{label:'自要素'}},
      //   ],[..],..  ※複数箇所でリンクしていた場合、複数
      // ]
      // なお無効化されている行はthis.showDeleted=falseなら除外する
      v.sql = 'select node.nId, node.pId, node.seq, node.lId, node.type, leaf.attribute'
      + ' from node inner join leaf on node.lId=leaf.lId where'
      + ( this.showDeleted ? '' : ' node.`deleted` is null and');
      v.linkNodes = alasql(`${v.sql} node.nId<>${nId} and leaf.lId=${v.node.lId}`);

      if( v.linkNodes.length > 0 ){
        v.step = 2.21; // リンクが存在
        v.node.link = [];
        v.linkNodes.forEach(linkNode => {
          v.step = 2.22; // 個々のリンクについて順次処理
          v.nId = linkNode.pId;
          v.tree = [linkNode];
          v.depth = 0;
          v.add = true;
          while( v.add && linkNode.pId > 0 && v.depth < this.maxDepth ){
            v.step = 2.23; // リンク〜ルートまでの要素を抽出
            linkNode = alasql(`${v.sql} node.nId=${v.nId}`)[0];
            if( linkNode !== undefined ){
              v.step = 2.24; // 途中のノードを保存
              v.tree.unshift(linkNode);
              v.nId = linkNode.pId;
              v.depth++;
            } else {
              v.step = 2.25; // 途中で見つからないノードが存在
              // ⇒ this.showDeleted=falseでdeletedが設定されているノード
              // ⇒ ツールチップ表示の対象外
              v.add = false;
            }
          }
          v.step = 2.26; // 途中のノードを先頭に保存
          if( v.add ) v.node.link.push(v.tree);
        });
      }

      v.step = 2.3; // createElement用の行オブジェクトをv.rvとして作成
      v.step = 2.31; // 行(tr)を作成。deletedに日付があればclassにも追加、
      // nameはJSON化したpath(ルート〜自要素のnIdの配列)
      v.rv = {
        attr:{name:JSON.stringify(v.path),class: 'tr'
          + (v.node.deleted && v.node.deleted.length > 0 ? ' deleted' : '')},
        event: {contextmenu:e => this.context(e)},
        children:[],
      };

      v.step = 2.32; // 行内部のindent部を作成
      v.rv.children.push({
        attr:{class:'indent'},
        style:{gridColumn:`1/${v.path.length+1}`,width:v.path.length+'rem'}
      });

      v.step = 2.33; // 行内部のctrl部を作成
      v.ctrl = {  // 共通部分
        attr: {class:'ctrl tooltip',title:`n=${v.node.nId},l=${v.node.lId}`},
        style:{gridColumn:`${v.path.length+1}/${v.path.length+2}`},
      };
      // 子要素があれば[▶|▼]、無ければチェックボックス。コメント行等、子要素を持ち得ないtypeなら空白
      v.children = alasql(v.sql+' node.pId='+nId+' order by seq');
      if( this.iDef[v.node.type].ctrl ){
        if( v.children.length > 0 ){
          // 子要素が存在する場合、[▶|▼]を表示
          v.ctrl.text = v.node.isOpen ? '▼' : '▶';
          v.ctrl.event = {click:e => this.toggle(e)};
        } else {
          // 子要素が存在しない場合、チェックボックスを表示
          v.ctrl.children = [{
            tag:'input',
            attr:{type:'checkbox'},
            logical: {checked:v.node.selected},
            event: {change:e=>{
              const v = {};
              v.name = e.target.closest('.tr').getAttribute('name');
              v.nId = JSON.parse(v.name).slice(-1)[0];
              v.checked = e.target.checked;
              alasql('update node set `selected`='+v.checked+' where nId='+v.nId);
            }}
          }];
        }
      } else {
        // コメント行等、子要素を持ち得ないtypeなら「□」を表示
        // ※ this.iDef[v.node.type].ctrlで"false"が設定されているtype
        v.ctrl.text = '□';
        v.ctrl.event = {click:e => this.toggle(e)};
      }
      v.rv.children.push(v.ctrl);

      v.step = 2.34; // 行内部のitem部を作成
      v.rv.children.push({
        attr:{class:'item'},
        style:{gridColumn:`${v.path.length+2}/23`},
        children: this.iDef[v.node.type].disp(v.node),
      });

      v.step = 2.4; // v.rvを描画領域に追加
      v.r = createElement(v.rv,this.treeDiv);
      if( v.r instanceof Error ) throw v.r;

      v.step = 3; // 子要素を順次再帰呼出
      if( v.node.isOpen === true ){
        for( v.i=0 ; v.i<v.children.length ; v.i++ ){
          v.r = this.disp(v.children[v.i].nId,v.path);
          if( v.r instanceof Error ) throw v.r;
        }
      }

      v.step = 4; // 終了処理
      console.log(`${v.whois} normal end.`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** toggle: 子要素を開閉
   * @param {Event} - クリックのイベントオブジェクト
   * @returns {null}
   */
  toggle(event){
    const v = {whois:this.constructor.name+'.toggle',rv:null,step:0};
    console.log(`${v.whois} start.`);
    try {

      v.step = 1; // 対象idの取得
      //v.nId = Number(event.target.parentNode.getAttribute('name'));
      v.name = event.target.closest('.tr').getAttribute('name');
      v.nId = JSON.parse(v.name).slice(-1)[0];

      v.step = 2; // isOpenを逆転
      v.node = alasql('select * from node where nId='+v.nId)[0];
      v.node.isOpen = v.node.isOpen ? false : true;
      v.r = alasql(`update node set isOpen=${v.node.isOpen} where nId=${v.nId}`);

      v.step = 3; // 再描画
      v.r = this.disp();
      if( v.r instanceof Error ) throw v.r;

      v.step = 9; // 終了処理
      console.log(`${v.whois} normal end.`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** editLeaf: leafの編集
   * @param {Object} arg - 編集対象のleafオブジェクト＋type属性
   * @returns {Object} 編集結果のleafオブジェクト {status:boolean,leaf:leafObj}
   * 
   * - Qiita [【javascript】非同期な自作 confirm を作ってみた](https://qiita.com/naoki-funawatari/items/4de792bfefe5eab909cc)
   */
  async editLeaf(arg){
    const v = {whois:this.constructor.name+'.editLeaf',rv:null,step:0};
    console.log(`${v.whois} start.\narg=${stringify(arg)}`);
    try {

      v.step = 1; // 編集画面の作成
      v.editDialog = this.iDef[arg.type].edit(arg);

      v.step = 2; // 更新ボタンを追加、編集画面の再作成
      v.editDialog.push(
        {tag:'button',attr:{name:'submit'},text:'更新'},
        {tag:'button',attr:{name:'cancel'},text:'取消'},
      );

      v.step = 3; // 更新対象領域をv.containerとして取得、編集画面を更新
      v.container = this.editDialog.querySelector('[name="container"]');
      v.container.innerHTML = '';
      v.r = createElement(v.editDialog,v.container);
      //this.editDialog.innerHTML = '';
      //v.r = createElement(v.editDialog,this.editDialog);
      if( v.r instanceof Error ) throw v.r;

      v.step = 4; // 編集画面を表示
      v.r = await (async ()=>{
        this.editDialog.showModal();

        return new Promise(resolve => {
          this.editDialog.querySelector('button[name="submit"]').addEventListener("click", () => {
            this.editDialog.close();
            // .td[name]属性を持つ全要素からvalueを取得してオブジェクト化
            const rv = {status:true,leaf:{}}
            this.editDialog.querySelectorAll('.td[name]').forEach(x => {
              if( x.value ){
                rv.leaf[x.getAttribute('name')] = x.value;
              }
            });
            resolve(rv);
          });

          this.editDialog.querySelector('button[name="cancel"]').addEventListener("click", () => {
            this.editDialog.close();
            resolve({status:false});
          });
        });
      })();

      v.step = 5; // 終了処理
      v.rv = {status:v.r.status};
      if( v.r.status ){
        v.rv.leaf = mergeDeeply({
          lId: arg.lId,
          attribute: v.r.leaf,
          updated: toLocale(new Date(),'yyyy/MM/dd hh:mm:ss.nnn'),
        },arg);
      }
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** syncDB: データベースとシートの両方を更新・追加する
   * 
   * 尚「(物理)削除」は当面シート上で行うため割愛。
   * 
   * @param {Object.<string, Object>} arg - テーブル名と操作オブジェクト
   * @param {Object} arg.node
   * @param {Object[]} arg.node.update - 更新・追加対象のnodeオブジェクト
   * @param {Object[]} arg.node.delete - 削除対象のnodeオブジェクト
   * @param {Object} arg.leaf
   * @param {Object[]} arg.leaf.update - 更新・追加対象のleafオブジェクト
   * @param {Object[]} arg.leaf.delete - 削除対象のleafオブジェクト
   * @returns {null}
   */
  async syncDB(arg){
    const v = {whois:this.constructor.name+'.syncDB',rv:null,step:0,rex:/,"\w+":"undefined"/g};
    console.log(`${v.whois} start.\narg=${stringify(arg)}`);
    try {

      // ----------------------------------------------
      v.step = 1; // 事前準備
      // ----------------------------------------------
      arg = JSON.parse(JSON.stringify(arg).replaceAll(v.rex,''));
      v.arg = mergeDeeply(arg,JSON.parse(this.proto.trans));
      v.trans = mergeDeeply(v.arg,{node:{insert:[]},leaf:{insert:[]}});

      v.step = 1.1; // nodeについてupdateとinsertの切り分け
      // 引数v.trans.updateの内、既存はupdateに、不在はinsertに分ける
      v.sql = 'select * from ? as n1'
      + ' left join node as n2 on n1.nId=n2.nId'
      + ' where n2.nId is ';
      v.trans.node.update = alasql(v.sql+'not null',[v.arg.node.update]);
      v.trans.node.insert = alasql(v.sql+'null',[v.arg.node.update]);

      v.step = 1.2; // leafについてupdateとinsertの切り分け
      // 引数v.trans.updateの内、既存はupdateに、不在はinsertに分ける
      v.sql = 'select * from ? as l1'
      + ' left join leaf as l2 on l1.lId=l2.lId'
      + ' where l2.lId is ';
      v.trans.leaf.update = alasql(v.sql+'not null',[v.arg.leaf.update]);
      v.trans.leaf.insert = alasql(v.sql+'null',[v.arg.leaf.update]);
      // undefinedを削除
      v.trans = JSON.parse(JSON.stringify(v.trans).replaceAll(v.rex,''));

      // ----------------------------------------------
      v.step = 2; // leafの更新・追加
      // ----------------------------------------------
      v.step = 2.1; // leafの更新処理
      v.trans.leaf.update.forEach(x => {
        v.stack = [];
        if( x.hasOwnProperty('attribute') )
          v.stack.push('`attribute`=@'+JSON.stringify(x.attribute));
        ['created','updated','deleted'].forEach(y => {
          if( x.hasOwnProperty(y) && (x[y] || x[y] === '') )
            v.stack.push(`\`${y}\`="${x[y]}"`);
        });
        v.sql = `update leaf set ${v.stack.join()} where lId=${x.lId}`;
        v.r = alasql(v.sql);
        if( v.r instanceof Error ) throw v.r;
      });

      v.step = 2.2; // leafの追加処理
      v.trans.leaf.insert.forEach(x => {
        v.cols = ['`lId`']; v.vals = [x.lId];
        // JSON型(先頭に'@'をつける項目)
        if( x.hasOwnProperty('attribute') ){
          v.cols.push('`attribute`');
          v.vals.push('@'+JSON.stringify(x.attribute));
        }
        // string,Date型(ダブルクォーテーションで囲む項目)
        ['created','updated','deleted'].forEach(y => {
          if( x.hasOwnProperty(y) ){
            v.cols.push('`'+y+'`');
            v.vals.push(`"${x[y]}"`);
          }
        });
        v.sql = `insert into leaf (${v.cols.join()}) values (${v.vals.join()})`;
        v.r = alasql(v.sql);
        if( v.r instanceof Error ) throw v.r;
      });

      v.step = 2.3; // leafの削除処理
      v.trans.leaf.delete.forEach(x => {
        v.r = alasql('delete from leaf where lId='+x.lId);
        if( v.r instanceof Error ) throw v.r;
      });

      // ----------------------------------------------
      v.step = 3; // nodeの更新・追加
      // ----------------------------------------------
      v.step = 3.1; // nodeの更新処理
      v.trans.node.update.forEach(x => {
        v.stack = [];
        ['pId','seq','lId'].forEach(y => {
          if( x.hasOwnProperty(y) && (x[y] || x[y] === 0) )
            v.stack.push(`\`${y}\`=${x[y]}`);
        });
        ['type','created','updated','deleted'].forEach(y => {
          if( x.hasOwnProperty(y) && (x[y] || x[y] === '') )
            v.stack.push(`\`${y}\`="${x[y]}"`);
        });
        v.sql = `update node set ${v.stack.join()} where nId=${x.nId}`;
        v.r = alasql(v.sql);
        if( v.r instanceof Error ) throw v.r;
      });

      v.step = 3.2; // nodeの追加処理
      v.trans.node.insert.forEach(x => {
        v.cols = []; v.vals = [];
        ['nId','pId','seq','lId'].forEach(y => {
          if( x.hasOwnProperty(y) && (x[y] || x[y] === 0) ){
            v.cols.push('`'+y+'`');
            v.vals.push(x[y]);
          }
        });
        ['type','created','updated','deleted'].forEach(y => {
          if( x.hasOwnProperty(y) && (x[y] || x[y] === '') ){
            v.cols.push('`'+y+'`');
            v.vals.push(`"${x[y]}"`);
          }
        });
        v.sql = `insert into node (${v.cols.join()}) values (${v.vals.join()})`;
        v.r = alasql(v.sql);
        if( v.r instanceof Error ) throw v.r;
      });

      v.step = 3.3; // nodeの削除処理
      v.trans.node.delete.forEach(x => {
        v.r = alasql('delete from node where nId='+x.nId);
        if( v.r instanceof Error ) throw v.r;
      });


      // ----------------------------------------------
      v.step = 4; // シートへの反映
      // ----------------------------------------------
      v.step = 4.1; // Date型を日時文字列に変換
      Object.keys(this.tDef).forEach(tableName => {
        ['update','insert','delete'].forEach(func => {
          v.i<v.trans[tableName][func].forEach(obj => {
            Object.keys(obj).forEach(col => {
              if( whichType(obj[col],'Date') ){
                obj[col] = toLocale(obj[col],'yyyy/MM/dd hh:mm:ss.nnn');
              }
            })
          });
        });
      });
      v.step = 4.2; // サーバ側処理
      this.contextDialog.close();
      this.editDialog.close();
      this.validationDialog.close();
      this.loading.show();
      v.r = await doGAS('typeDefsFront',v.trans);
      if( v.r instanceof Error ) throw v.r;
      this.loading.hide();

      // ----------------------------------------------
      v.step = 5; // 終了処理
      // ----------------------------------------------
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** decidePosition: 挿入位置の決定
   * @param {void}
   * @returns {Object}
   *
   * ** 戻り値 **
   *
   * - rv {Object}
   *   - pId {number} : 親要素のnId
   *   - seq {number} : 親要素内での順番
   */
  decidePosition(){
    const v = {whois:this.constructor.name+'.decidePosition',rv:null,step:0};
    console.log(`${v.whois} start.`);
    try {

      v.node = alasql('select * from node where nId='+this.nId)[0];
      v.children = alasql('select * from node where pId='+this.nId);
      if( v.node.isOpen && v.children.length > 0 ){
        v.step = 2.1; // ①子孫があり、開いている ⇒ 長男として作成
        v.rv = {pId:this.nId,seq:1};
      } else {
        v.step = 2.2; // ②①以外なら弟として作成
        v.rv = {pId:v.node.pId,seq:v.node.seq+1};
      }

      v.step = 9; // 終了処理
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** moveNode: nodeの移動に必要なsyncDB更新用データを作成
   * @param {Object} arg
   * @param {number} arg.fId - 移動元親nodeのnId。0なら新規作成node
   * @param {number} arg.tId - 移動先親nodeのnId
   * @param {number|Object} arg.nId - 移動対象nodeのnId、または移動対象nodeオブジェクト
   * @param {number} [arg.seq=1] - 移動先のseq
   * @returns {Object[]} rv - 更新・追加対象のnodeオブジェクトの配列
   *
   * **処理概要**
   *
   * 1. 事前準備
   *    1.1 引数への既定値設定
   *    1.2 v.bmNodeに移動前のnodeを退避、v.amNodeに移動後のnodeをセット
   *    1.3 v.bmParentに移動前の親要素を、v.amParentに移動後の親要素をセット
   *    1.4 v.bmChildrenにv.bmParentの子要素を、v.amChildrenにv.amParentの子要素をセット
   * 2. 「fId <> tId」ならば、移動元親の子要素について並び順を変更
   *    2.1 v.bmChildren[x].seq > v.bmNode.seqについて、seqを繰り上げ(-1)
   * 3. 移動先親の子要素(v.amChildren)について並び順を変更
   *    3.1 前に移動(v.amNode.seq<v.bmNode.seq)
   *    ⇒ v.amChildren.forEach(x => v.amNode.seq <= x.seq < v.bmNode.seq)
   *      を満たす要素について、seqを繰り下げ(+1)
   *    3.2 後に移動(v.amNode.seq>v.bmNode.seq)
   *    ⇒ v.amChildren.forEach(x => v.bmNode.seq < x.seq <= v.amNode.seq)
   *      を満たす要素について、seqを繰り上げ(-1)
   * 4. 移動対象のpIdを(fIdから)tIdに変更、seqを上書き
   * 5. 移動対象が子要素を持っていた場合、コピー元の全子孫要素を新規nodeとして追加
   */
  moveNode(arg){
    const v = {whois:this.constructor.name+'.moveNode',step:0,
      rv:[],now:toLocale(new Date(),'yyyy/MM/dd hh:mm:ss.nnn')};
    console.log(`${v.whois} start.\narg=${stringify(arg)}`);
    try {

      v.step = 1; // 事前準備
      v.step = 1.1; // 引数への既定値設定
      v.arg = Object.assign({seq:1},arg);

      v.step = 1.2 // v.bmNodeに移動前のnodeを退避、v.amNodeに移動後のnodeをセット
      v.sql = 'select * from node where nId=';
      v.bmNode = alasql(v.sql+v.arg.nId)[0];
      v.amNode = Object.assign({},v.bmNode,{
        // nId : 変化無し
        pId : v.arg.tId,
        seq : v.arg.seq,
        // lId : 変化無し
        // type : 変化無し
        //created : 変化無し
        updated : v.now,
        //deleted : 変化無し
      });

      v.step = 1.3 // v.bmParentに移動前の親要素を、v.amParentに移動後の親要素をセット
      v.bmParent = alasql(v.sql+v.arg.fId)[0];
      v.amParent = alasql(v.sql+v.arg.tId)[0];

      v.step = 1.4 // v.bmChildrenにv.bmParentの子要素を、v.amChildrenにv.amParentの子要素をセット
      v.sql = 'select * from node where pId=';
      v.bmChildren = alasql(v.sql+v.arg.fId);
      v.amChildren = alasql(v.sql+v.arg.tId);

      v.step = 2. // 「fId <> tId」ならば、移動元親の子要素について並び順を変更
      if( v.arg.fId !== v.arg.tId ){
        v.step = 2.1 // v.bmChildren[x].seq > v.bmNode.seqについて、seqを繰り上げ(-1)
        v.bmChildren.forEach(x => {
          if( x.seq > v.bmNode.seq ){
            x.seq -= 1;
            v.rv.push(x);
          }
        });
      }
      
      v.step = 3. // 移動先親の子要素(v.amChildren)について並び順を変更
      if( v.amNode.seq < v.bmNode.seq ){
        v.step = 3.1 // 前に移動(v.amNode.seq<v.bmNode.seq)
          // ⇒ v.amChildren.forEach(x => v.amNode.seq <= x.seq < v.bmNode.seq)
          //   を満たす要素について、seqを繰り下げ(+1)
        v.amChildren.forEach(x => {
          if( v.amNode.seq <= x.seq && x.seq < v.bmNode.seq ){
            x.seq += 1;
            v.rv.push(x);
          }
        });
      } else {
        v.step = 3.2 // 後に移動(v.amNode.seq>v.bmNode.seq)
          // ⇒ v.amChildren.forEach(x => v.bmNode.seq < x.seq <= v.amNode.seq)
          //   を満たす要素について、seqを繰り上げ(-1)
        v.amChildren.forEach(x => {
          if( v.bmNode.seq < x.seq && x.seq <= v.amNode.seq ){
            x.seq -= 1;
            v.rv.push(x);
          }
        });
      }

      v.step = 4. // 移動対象のpIdを(fIdから)tIdに変更、seqを上書き
      v.rv.push(v.amNode);

      // v.step = 5. // 移動対象が子要素を持っていた場合、コピー元の全子孫要素を新規nodeとして追加
      // ↑ 移動では使用しない

      v.step = 5; // 終了処理
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** appendBranch: コピー元要素をコピー先およびリンク先に追加
   * @param {number|Object} arg=this.copiedId - 追加するnodeのnId。Objectの場合、leaf+type
   * @param {number} [nextId=null] - 新規採番するnId。nIdは通常DB上の最大値＋1で採番するが、
   * 複数箇所のpasteを行う場合、先行箇所をDB登録前に次の箇所の採番を行うため、paste側で採番して渡される。
   * @returns {Object} rv syncDBでupdateに渡す更新対象の配列(={node:Object[],leaf:Object[]})
   * 
   * **処理概要**
   * 
   * 1. 事前準備
   * 1.1 追加位置のpId,seqを確定(v.dp=decidePosition())
   * 1.2 コピー元要素をv.originalとして作成
   * 1.3 追加用の内部関数を定義
   * 2. コピー元要素(含、子孫)を対象要素(コピー先)に作成
   * 3. リンク先への追加
   * 3.1 コピー先要素の配下に存在するlIdをleavesとして取得
   * 3.2 リンク先の親要素(=leavesのいずれかを子要素とする要素)をv.parentsとして取得
   * 3.3 v.parents配下の子要素について内部関数を呼び出し
   * 
   * @example 複写・貼付(copy & paste)の考え方
   * 
   * nId label
   * 00  root(lId=0)
   * 01    ▼記憶領域(lId=1)
   * 02      ▼sessionStorage(lId=2)  ※リンク先
   * 03        ●userId(lId=3)
   * 04        ●auth(lId=4)
   * 05        ●trial(lId=5)
   * 20        ▼typeDefs(lId=13)  ※リンク先に追加されたコピー元要素
   * 21          ●メンバ変数(lId=14)
   * 06      ▶DocumentProperties(lId=6)
   * 07        □SV/CL共用設定情報(lId=7)
   * 08        ●SPkey(lId=8)
   * 09        □SV専用設定情報(lId=9)
   * 10        ●notificatePasscodeMail(lId=10)
   * 11      ▼sessionStorage(link)(lId=11)  ※コピー先(v.dp.pId)
   * 18        ▼typeDefs(lId=13)  ※コピー先に追加されたコピー元要素
   * 19          ●メンバ変数(lId=14)
   * 12        ●userId(lId=3)
   * 13        ●auth(lId=4)
   * 14        ●trial(lId=5)
   * 15        ●passPhrase(lId=12)
   * 16  ▼typeDefs(lId=13)  ※コピー元要素
   * 17    ●メンバ変数(lId=14)  ※コピー元の子要素
   * 
   * ①コピー元要素(nId=16)を「複写」
   * ②コピー先(nId=11)の「▼」からコンテキストメニューを表示、「貼付」
   * 　⇒ コピー元の「typeDefs(nId=16,lId=13)」およびその子孫(nId=17,lId=14)を
   * 　　 コピー先の次行(nId=18,19)に追加
   * ※以降、コピー先のリンク要素の検索とコピー元要素の追加手順
   * ③コピー先(nId=11)の子要素のlIdをv.leavesとして取得
   * 　⇒ 子要素はuserId,auth,trial,passPhraseなので、v.leaves=[3,4,5,12]
   * ④v.leavesのいずれかを子要素とし、かつコピー先ではない要素をv.parentsとして取得
   * 　⇒ 3,4,5,12のいずれかを子要素として持つ要素 = nId=02,11
   * 　　 但しnId=11はコピー先なので除外すると、v.parents=[2]
   * ⑤v.parents(nId=2)の長子としてコピー元要素(nId=20)＋その子孫(nId=21)を追加
   */
  appendBranch(arg=this.copiedId,nextId=null){
    const v = {whois:this.constructor.name+'.appendBranch',step:0,
      rv:JSON.parse(this.proto.trans)};
    console.log(`${v.whois} start.\narg=${stringify(arg)}`);
    try {

      v.step = 1; // 事前準備
      v.step = 1.1; // 追加位置のpId,seqを確定(v.dp=decidePosition())
      v.dp = this.decidePosition();
      if( v.dp instanceof Error ) throw v.dp;
      v.nextId = nextId || alasql('select max(nId) as m from node')[0].m + 1;
      v.now = toLocale(new Date(),'yyyy/MM/dd hh:mm:ss.nnn');

      v.step = 1.2; // コピー元要素をv.originalとして作成
      v.original = typeof arg === 'number'
      ? alasql('select * from node inner join leaf on node.lId=leaf.lId where nId='+arg)[0]
      : arg;  // this.appendからオブジェクトを渡された場合

      v.step = 1.3; // 追加用の内部関数を定義
      v.recursive = (
          pId,  // {number} 対象の親要素のnId
          seq,  // {number} 対象の順番
          org,  // {Object} コピー元要素のオブジェクト
          depth // {number} 階層。永久ループ防止用
      ) => {
        if( depth > this.maxDepth ) return new Error('too many depth');
        const w = {};
        v.step = 1.31; // 追加するnodeの作成
        w.new = {
          nId: v.nextId++,
          pId: pId,
          seq: seq,
          lId: org.lId,
          type: org.type,
          created: v.now,
          deleted: //指定箇所への追加で無い場合、または追加要素の子要素の場合は現在日時を設定
            ( depth > 0 || v.dp.pId === pId && v.dp.seq === seq ) ? null : v.now,
        }
        v.rv.node.update.push(w.new);

        v.step = 1.32; // 追加により影響を受ける兄弟要素の順番修正
        w.sql = `select * from node where pId=${pId} and seq>=${seq}`;
        w.r = alasql(w.sql);
        w.r.forEach(x => {
          x.seq += 1;
          x.updated = w.now;
          v.rv.node.update.push(x);
        });

        v.step = 1.33; // 子要素を洗い出し、再帰呼出
        w.r = alasql('select * from node where pId=' + org.nId);
        w.r.forEach(x => v.recursive(w.new.nId,x.seq,x,depth+1));
      };

      v.step = 2; // コピー元要素(含、子孫)を対象要素(コピー先)に作成
      v.recursive(v.dp.pId,v.dp.seq,v.original,0);

      v.step = 3; // リンク先への追加
      // 「追加対象の兄弟要素を子要素として持つ要素」にも追加

      v.step = 3.1; // コピー先要素の配下に存在するlIdをleavesとして取得
      v.sql = 'select lId from node where pId='+v.dp.pId+' group by lId';
      v.leaves = alasql(v.sql);

      v.step = 3.2; // リンク先の親要素(=leavesのいずれかを子要素とする要素)をv.parentsとして取得
      v.sql = 'select node.* from node inner join'
      + ` ? as leaves on node.lId=leaves.lId`
      + ` where pId<>${v.dp.pId}`
      + ` group by node.pId`;
      v.parents = alasql(v.sql,[v.leaves]);

      v.step = 3.3; // v.parents配下の子要素について内部関数を呼び出し
      v.parents.forEach(p => v.recursive(p.pId,1,v.original,0));
      
      v.step = 9; // 終了処理
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** linkTip: ツールチップ用文字列を作成
   * @param {Object} arg - this.iDef[xxx].dispに渡されたオブジェクト
   * @param {Object[][]} arg.link - ルートからリンク先要素までのnode+leafオブジェクトの配列
   * @param {string} attr='title' - ツールチップ用文字列をセットする属性
   * @returns {string}
   */
  linkTip(arg,attr='title'){
    const v = {whois:this.constructor.name+'.linkTip',rv:{},step:0};
    console.log(`${v.whois} start.\narg=${stringify(arg)}`);
    try {

      if( arg.link && arg.link.length > 0 ){
        v.step = 1; 
        v.rv.class = 'link';
        v.rv[attr] = '';
        v.cnt = 1;
        arg.link.forEach(link => {
          v.stack = link.map(o => o.attribute.label);
          v.rv[attr] += `${v.cnt++}. ${v.stack.join(' > ')}\n`;
        });
        v.rv[attr] = v.rv[attr].slice(0,v.rv[attr].length-1);
      }

      v.step = 9; // 終了処理
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** context: 右ボタンメニューを表示し、選択された処理を呼び出す
   * @param {Event} - クリックのイベントオブジェクト
   * @returns {null}
   */
  async context(event){
    const v = {whois:this.constructor.name+'.context',rv:null,step:0};
    console.log(`${v.whois} start.`,event.target);
    try {

      v.step = 1; // 準備
      event.preventDefault();
      v.tr = event.target.closest('.tr');

      v.step = 2; // 動作を分岐
      if( v.tr !== null ){
        
        v.step = 2.1; // trクラスが祖先に存在
        // ⇒ 「▶」等、行頭のアイコンの右ボタンクリックから呼ばれた
        // ⇒ 右ボタンメニューのダイアログ表示

        v.step = 2.11; // 選択されたidを保存(pathの末尾のnId)
        this.nId = JSON.parse(v.tr.getAttribute('name')).slice(-1)[0];

        v.step = 2.12; // ダイアログ内ボタンのラベル「有効化⇔無効化」の切替
        v.sql = 'select node.*, leaf.attribute'
        + ' from node inner join leaf on node.lId=leaf.lId'
        + ' where node.nId=' + this.nId;
        v.node = alasql(v.sql)[0];
        this.contextDialog.querySelector('[name="setValidation"]')
        .innerText = v.node.deleted && v.node.deleted.length > 0 ? '有効化' : '無効化';

        v.step = 2.13; // ラベルの表示
        this.contextDialog.querySelector('[name="label"]').innerText = v.node.attribute.label;

        v.step = 2.14; // ダイアログの表示
        this.contextDialog.showModal();

      } else {

        v.step = 2.2; // trクラスが祖先に存在しない
        // ⇒ ダイアログ内の機能選択(ex. appendのDivがクリックされた)
        v.name = event.target.getAttribute('name');
        if( v.name !== null ){
          // 追加ボタン内のプルダウンが変更された場合、v.name===null
          v.step = 2.21; // 選択された機能の呼び出し
          v.r = await this[v.name](event);
          if( v.r instanceof Error ) throw v.r;
          v.step = 2.22; // ダイアログを閉じてツリーを再描画
          this.contextDialog.close();
          v.r = this.disp();
          if( v.r instanceof Error ) throw v.r;
        }
      }

      v.step = 3; // 終了処理
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** edit: コンテキストメニューで指定されたノードを編集
   * @param {Event} - クリックのイベントオブジェクト
   * @returns {null}
   */
  async edit(arg){
    const v = {whois:this.constructor.name+'.edit',rv:null,step:0};
    console.log(`${v.whois} start.\narg=${stringify(arg)}`);
    try {

      v.step = 1; // 対象leaf＋typeの取得
      v.sql = 'select node.type, leaf.*'
      + ' from leaf inner join node on node.lId=leaf.lId'
      + ' where node.nId=' + this.nId;
      v.leaf = alasql(v.sql)[0];

      v.step = 1; // 対象leafを編集
      v.r = await this.editLeaf(v.leaf);
      if( v.r instanceof Error ) throw v.r;

      if( v.r.status === true ){
        v.step = 2; // DBおよびシートに反映
        v.r = await this.syncDB({leaf:{update:[v.r.leaf]}});
        if( v.r instanceof Error ) throw v.r;
      }

      v.step = 4; // 終了処理
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** append: 新規行を追加
   * @parem {void}
   * @returns {null}
   */
  async append(){
    const v = {whois:this.constructor.name+'.append',rv:null,step:0,
      trans:JSON.parse(this.proto.trans)};
    console.log(`${v.whois} start.`);
    try {

      v.step = 1; // 新規leafを作成して編集
      v.type = this.contextDialog.querySelector('select').value;
      v.r = await this.editLeaf({
        type: v.type,
        lId: alasql('select max(lId) as m from leaf')[0].m + 1,
        attribute: {label:''},
        created: toLocale(new Date(),'yyyy/MM/dd hh:mm:ss.nnn'),
      });
      if( v.r instanceof Error ) throw v.r;

      if( v.r.status === true ){
        v.step = 2; // ブランチへの追加
        v.leaf = v.r.leaf;
        v.trans.leaf.update.push(v.r.leaf);
        v.leaf.type = v.type;
        v.r = this.appendBranch(v.leaf);
        if( v.r instanceof Error ) throw v.r;
        v.trans.node.update = [...v.trans.node.update,...v.r.node.update];
        v.trans.leaf.update = [...v.trans.leaf.update,...v.r.leaf.update];

        v.step = 3; // DBおよびシートに反映
        v.r = await this.syncDB(v.trans);
        if( v.r instanceof Error ) throw v.r;
      }

      v.step = 4; // 終了処理
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** copy: 現在選択されている行をコピーする
   * 「現在選択されている行」とはコンテキストメニューを呼び出した行(現在行)と
   * チェックボックスで選択されている行(選択行)の和集合。
   * ただし選択行が現在行の子孫だった場合、コピー対象外となる。
   * 
   * @parem {void}
   * @returns {null}
   */
  copy(){
    const v = {whois:this.constructor.name+'.copy',rv:null,step:0};
    console.log(`${v.whois} start.`);
    try {

      v.step = 1; // 選択中の行(this.nId)をthis.copiedIdに保存する
      this.copiedId = [this.nId];
      this.treeDiv.querySelectorAll('.ctrl input').forEach(o => {
        v.step = 2;
        if( o.checked === true ){
          v.step = 3;
          v.tr = JSON.parse(o.closest('.tr').getAttribute('name'));
          if( v.tr.findIndex(x => x == this.nId) < 0 ){
            v.step = 4;
            // ルート〜自要素までの間に現在行が存在しない場合は
            // checkされていた要素のnIdをcopy対象として追加
            this.copiedId.push(v.tr.slice(-1)[0]);
          }
        }
      });

      v.step = 9; // 終了処理
      console.log(`${v.whois} normal end.\nthis.copiedId=${stringify(this.copiedId)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** paste: コピーされた要素の実体を追加登録
   * @parem {void}
   * @returns {null}
   */
  async paste(){
    const v = {whois:this.constructor.name+'.paste',rv:null,step:0,
      trans:JSON.parse(this.proto.trans)};
    console.log(`${v.whois} start.\nthis.copiedId=${stringify(this.copiedId)}`);
    try {

      v.step = 1; // ブランチへの追加
      v.nextId = alasql('select max(nId) as m from node')[0].m + 1;
      this.copiedId.forEach(x => {
        v.r = this.appendBranch(x,v.nextId);
        if( v.r instanceof Error ) throw v.r;
        v.trans.node.update = [...v.trans.node.update,...v.r.node.update];
        //v.trans.leaf.update = [...v.trans.leaf.update,...v.r.leaf.update];
        v.nextId += v.r.node.update.length;
      });

      v.step = 2; // DBおよびシートに反映
      v.r = await this.syncDB(v.trans);
      if( v.r instanceof Error ) throw v.r;

      v.step = 3; // 終了処理
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** setValidation: 選択された行の表示/非表示切替と同時に、削除済要素の表示/非表示切替を行う
   * @parem {void}
   * @returns {null}
   */
  async setValidation(){
    const v = {whois:this.constructor.name+'.setValidation',rv:null,step:0,
      trans:JSON.parse(this.proto.trans),isInvalid:false};
    console.log(`${v.whois} start.`);
    try {

      v.step = 1; // 選択された行の表示/非表示設定をチェックボックスに表示
      v.node = alasql('select * from node where nId='+this.nId)[0];
      if( v.node.deleted && v.node.deleted.length > 0 ){
        this.validationDialog.querySelector('input[name="isInvalid"]').checked = true;
        v.isInvalid = true;  // 変更前の状態を無効に変更
      }

      v.step = 2; // 削除済要素の表示/非表示設定をチェックボックスに表示
      if( this.showDeleted === false ){
        this.validationDialog.querySelector('input[name="hideDeleted"]').checked = true;
      }

      v.step = 3; // 設定画面を表示
      v.r = await (async ()=>{
        this.validationDialog.showModal();

        return new Promise(resolve => {
          this.validationDialog.querySelector('button[name="submit"]').addEventListener("click", () => {
            this.validationDialog.close();
            // .input[name]属性を持つ全要素からvalueを取得してオブジェクト化
            const rv = {status:true,values:{}}
            this.validationDialog.querySelectorAll('input[name]').forEach(x => {
              rv.values[x.getAttribute('name')] = x.checked;
            });
            resolve(rv);
          });

          this.validationDialog.querySelector('button[name="cancel"]').addEventListener("click", () => {
            this.validationDialog.close();
            resolve({status:false});
          });
        });
      })();
      if( v.r instanceof Error ) throw v.r;

      v.step = 4; // 設定結果の反映
      if( v.r.status === true ){
        v.step = 4.1; // 削除済要素の表示/非表示設定
        this.showDeleted = !v.r.values.hideDeleted;

        v.step = 4.2; // 選択された行の表示/非表示設定
        if( v.r.values.isInvalid !== v.isInvalid ){
          v.step = 4.21; // v.node.deletedを設定
          v.node.deleted = v.r.values.isInvalid === true
          ? toLocale(new Date(),'yyyy/MM/dd hh:mm:ss.nnn') // 有効->無効 : node.deletedに日時文字列
          : ''; // 無効->有効 : deletedを削除
          v.trans.node.update.push(v.node);

          v.step = 4.22; // DBおよびシートの更新
          v.r = await this.syncDB(v.trans);
          if( v.r instanceof Error ) throw v.r;
        }
      }

      v.step = 9; // 終了処理
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** delete: 選択された行および子孫を物理削除
   * @parem {void}
   * @returns {null}
   */
  async delete(){
    const v = {whois:this.constructor.name+'.delete',rv:null,step:0,
      trans:JSON.parse(this.proto.trans),label:[]};
    console.log(`${v.whois} start.`);
    try {

      v.step = 1; // 削除対象のnIdを洗い出し
      v.delId = [this.nId];
      this.treeDiv.querySelectorAll('.ctrl input').forEach(o => {
        if( o.checked === true ){
          v.tr = JSON.parse(o.closest('.tr').getAttribute('name'));
          if( v.tr.findIndex(x => x == this.nId) < 0 ){
            // ルート〜自要素までの間に現在行が存在しない場合は
            // checkされていた要素のnIdを削除対象として追加
            v.delId.push(v.tr.slice(-1)[0]);
          }
        }
      });

      v.step = 2; // 削除対象のnodeをv.nodesに取得
      v.sql = 'select node.*, leaf.attribute'
      + ' from node inner join leaf on node.lId = leaf.lId';
      v.nodes = alasql(v.sql+` where node.nId in (${v.delId.join()})`);

      v.step = 3; // node内の削除対象＋子孫を再帰的に削除
      v.recursive = pNode => {
        v.label.push(pNode.attribute.label || '(不明)');
        v.trans.node.delete.push(pNode);
        alasql(v.sql+' where pId='+pNode.nId)
        .forEach(cNode => v.recursive(cNode));
      };
      v.nodes.forEach(x => v.recursive(x));

      v.step = 5; // nodeに紐付かないleafを削除対象としてセット
      v.sql = 'select leaf.* from leaf'
      + ' left join node on leaf.lId=node.lId'
      + ' where node.nId is null';
      v.trans.leaf.delete = alasql(v.sql);

      v.step = 6; // 削除の確認、syncDBの呼び出し
      if( window.confirm(v.label.join()+'を削除しますか？') ){
        v.r = await this.syncDB(v.trans);
        if( v.r instanceof Error ) throw v.r;
      }

      v.step = 9; // 終了処理
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** levelUp: 一つ上の階層に移動
   * @parem {void}
   * @returns {null}
   */
  async levelUp(){
    const v = {whois:this.constructor.name+'.levelUp',rv:null,step:0};
    console.log(`${v.whois} start.`);
    try {

      v.step = 1; // 祖父母・親・自要素の情報を取得
      v.sql = 'select n1.pId as gId' // 祖父母のnId
      + ', n1.nId as pId'  // 親要素のnId
      + ', n1.seq as pSeq'   // 親要素の祖父母要素内での順番
      + ', n2.nId as nId'  // 対象要素のnId
      + ' from node as n2' // 親が無い場合に備え、b2を基にする
      + ' inner join node as n1 on n1.nId=n2.pId'
      + ' where n2.nId=' + this.nId;
      v.r = alasql(v.sql)[0];

      // 祖父母要素が無い ⇒ 一つ上の階層はない ⇒ 処理終了
      if( v.r ){
        v.step = 2; // moveNodeでsyncDB更新用データを作成
        v.r = this.moveNode({
          fId: v.r.pId,       // 親要素
          tId: v.r.gId,       // 祖父母要素
          nId: this.nId,      // 移動対象要素
          seq: v.r.pSeq + 1,  // 親要素の次
        });
        if( v.r instanceof Error ) throw v.r;

        v.step = 3; // データベースの更新
        v.r = await this.syncDB({node:{update:v.r}});
        if( v.r instanceof Error ) throw v.r;

        v.step = 4; // ツリーを再描画
        v.r = this.disp();
        if( v.r instanceof Error ) throw v.r;
      }

      v.step = 5; // 終了処理
      console.log(`${v.whois} normal end.`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** levelDown: 一つ下の階層に移動
   * 「一つ下の階層」⇒「兄要素の末子」と看做す
   * @parem {void}
   * @returns {null}
   */
  async levelDown(){
    const v = {whois:this.constructor.name+'.levelDown',rv:null,step:0};
    console.log(`${v.whois} start.`);
    try {

      v.step = 1; // 親(parent)、兄(brother)要素を取得
      v.sql = 'select n1.pId as pId, n2.nId as bId'
      + ' from node as n1' // n1:対象要素
      + ' inner join node as n2 on n1.pId=n2.pId and n1.seq-1=n2.seq' // n2:兄要素
      + ' where n1.nId=' + this.nId;
      v.r = alasql(v.sql)[0];

      // 兄要素が無い ⇒ 一つ上の階層はない ⇒ 処理終了
      if( v.r ){

        v.step = 2; // 甥(nephew)要素の数を取得
        v.sql = 'select count(*) as num from node where pId='+v.r.bId;
        v.num = alasql(v.sql)[0].num;

        v.step = 3; // moveNodeでsyncDB更新用データを作成
        v.r = this.moveNode({
          fId: v.r.pId,       // 親要素
          tId: v.r.bId,       // 兄要素
          nId: this.nId,      // 移動対象要素
          seq: v.num + 1,     // 甥要素の数＋1
        });
        if( v.r instanceof Error ) throw v.r;

        v.step = 3; // データベースの更新
        v.r = await this.syncDB({node:{update:v.r}});
        if( v.r instanceof Error ) throw v.r;

        v.step = 4; // ツリーを再描画
        v.r = this.disp();
        if( v.r instanceof Error ) throw v.r;
      }

      v.step = 5; // 終了処理
      console.log(`${v.whois} normal end.`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** moveForward: 表示順を一つ前に移動
   * @parem {void}
   * @returns {null}
   * 
   * 相対seqを絶対seqに変換 : context側で処理
   */
  async moveForward(){
    const v = {whois:this.constructor.name+'.moveForward',rv:null,step:0};
    console.log(`${v.whois} start.`);
    try {

      v.step = 1; // 対象ノードを取得、移動先を設定
      v.r = alasql(`select * from node where nId=`+this.nId)[0];

      // 長子 ⇒ これ以上前に行けない ⇒ 処理終了
      if( v.r.seq > 1 ){
        v.step = 2; // moveNodeでsyncDB更新用データを作成
        v.r = this.moveNode({
          fId: v.r.pId,       // 親要素
          tId: v.r.pId,       // 親要素(変わらず)
          nId: this.nId,      // 移動対象要素
          seq: v.r.seq - 1,   // 現在の一つ前
        });
        if( v.r instanceof Error ) throw v.r;

        v.step = 3; // データベースの更新
        v.r = await this.syncDB({node:{update:v.r}});
        if( v.r instanceof Error ) throw v.r;

        v.step = 4; // ツリーを再描画
        v.r = this.disp();
        if( v.r instanceof Error ) throw v.r;
      }

      v.step = 5; // 終了処理
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }

  /** moveLater: 表示順を一つ後に移動
   * @parem {void}
   * @returns {null}
   */
  async moveLater(){
    const v = {whois:this.constructor.name+'.moveLater',rv:null,step:0};
    console.log(`${v.whois} start.`);
    try {

      v.step = 1; // 対象ノードを取得、移動先を設定
      v.r = alasql(`select * from node where nId=`+this.nId)[0];
      // 兄弟要素数を取得
      v.b = alasql(`select count(nId) as num from node where pId=`+v.r.pId)[0];

      // 末子 ⇒ これ以上後に行けない ⇒ 処理終了
      if( v.r.seq < v.b.num ){
        v.step = 2; // moveNodeでsyncDB更新用データを作成
        v.r = this.moveNode({
          fId: v.r.pId,       // 親要素
          tId: v.r.pId,       // 親要素(変わらず)
          nId: this.nId,      // 移動対象要素
          seq: v.r.seq + 1,   // 現在の一つ後
        });
        if( v.r instanceof Error ) throw v.r;

        v.step = 3; // データベースの更新
        v.r = await this.syncDB({node:{update:v.r}});
        if( v.r instanceof Error ) throw v.r;

        v.step = 4; // ツリーを再描画
        v.r = this.disp();
        if( v.r instanceof Error ) throw v.r;
      }

      v.step = 5; // 終了処理
      console.log(`${v.whois} normal end.\nv.rv=${stringify(v.rv)}`);
      return v.rv;

    } catch(e) {
      e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
      console.error(`${e.message}\nv=${stringify(v)}`);
      return e;
    }
  }
}

window.addEventListener('DOMContentLoaded',() => {
  const v = {whois:'DOMContentLoaded',rv:null,step:0};
  console.log(`${v.whois} start.`);
  try {

    v.step = 1;
    v.TypeDefs = new TypeDefs();

    v.step = 99; // 終了処理
    console.log(`${v.whois} normal end.`);
    return v.rv;
    
  } catch(e) {
    e.message = `${v.whois} abnormal end at step.${v.step}\n${e.message}`;
    console.error(`${e.message}\nv=${JSON.stringify(v)}`);
    alert(e.message);
  }
});
</script>
</html>
