<!DOCTYPE html><html xml:lang="ja" lang="ja"><head>
  <title>scanQR</title>
  <h1>scanQR</h1>
  <p style="text-align: right;">rev.1.0 : 2023/08/13</p>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <style type="text/css">
    /* スマホ用に縦方向も最大領域を設定 */
    html {height: 100%;font-size: 100%;}
    body {height: 100%;}
    input {
      margin: 1rem;
      font-size:3rem;
    }
    #qrcode {
      margin: 1rem;
    }
    #result {
      margin: 1rem;
      font-size:2rem;
      overflow-wrap: anywhere;
      padding: 1rem;
    }
  </style>
</head>
<body>
  <div id="webScanner"></div>
  <input type="text" onchange="genQR()" />
  <div id="qrcode"></div>
  <a target="_blank"></a>
</body>
<!-- =====================================================
  CDN
===================================================== -->
<!-- QRコード検出 -->
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
<!-- QRコード生成 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

<!-- =====================================================
  自作ライブラリ
===================================================== -->
<script>  // src="core.js">
/** QRコードをスキャン
 * @param {string} parent - 親要素のCSSセレクタ
 * @param {Object} [opt={}] - オプション
 * @param {number} opt.size - ファインダ領域のサイズ
 * @param {number} opt.interval=300 - 撮像間隔。ミリ秒
 * @param {number} opt.max=90000 - 最大待機時間。単位：ミリ秒
 * @returns {string} スキャンしたQRコードの文字列
 * 
 * - Qiita [html＋javascriptだけで実装したシンプルなQRコードリーダー](https://qiita.com/murasuke/items/c16e4f15ac4436ed2744)
 * - [Promiseでsleep機能を作る](https://www.sejuku.net/blog/24629#index_id5)
 * 
 * @typedef scanQRopt
 * @prop {number} [size=500] - ファインダのサイズ
 */
 async function scanQR(parent,opt={}){
  const v = {whois:'scanQR',rv:null,
    constraints:{
      audio: false,
      video: {
        facingMode: 'environment',
        //width: opt.size || 500,
        //height: opt.size || 500,
      },
    },
    max: opt.max || 90000, // 最大待機時間。単位：ミリ秒
    interval: opt.interval || 300, // 撮像間隔。ミリ秒
    minSize : opt.minSize || 640, // 最小撮像サイズ。px
    sleep: (sec) =>  // 指定時間待機
      {return new Promise(resolve => setTimeout(resolve,sec))},
  };
  console.log(v.whois+' start.');
  try {

    // ファインダ領域の作成
    v.step = '1.1'; // 親要素の高さを最大に
    v.parent = document.querySelector(parent);
    v.parent.style.width = v.parent.style.height = '100%';
    v.step = '1.2'; // 撮像領域を親要素の幅・高さ、いずれか小さい方の正方形に設定
    if( opt.hasOwnProperty('size') ){
      v.ps = opt.size;
    } else {
      v.pw = v.parent.clientWidth;
      v.ph = v.parent.clientHeight;
      if( v.pw < v.ph ){
        v.ps = v.pw < v.minSize ? v.minSize : v.pw;
        v.parent.style.height = v.ps + 'px';
      } else {
        v.ps = v.ph < v.minSize ? v.minSize : v.ph;
        v.parent.style.width = v.ps + 'px';
      }
    }
    v.constraints.video.width = v.constraints.video.height = v.ps;
    v.step = '1.3'; // video要素の生成
    v.video = createElement({tag:'video',style:{margin:'auto'}});
    v.parent.append(v.video);

    v.step = '2';
    const stream = await navigator.mediaDevices.getUserMedia(v.constraints);
    v.video.srcObject = stream;
    v.video.play();

    v.step = '3';
    const { width, height } = v.constraints.video;
    v.canvas = new OffscreenCanvas(width, height);
    const context = v.canvas.getContext('2d');

    v.step = '4'; // 定期的にスキャン実行
    v.cnt = 0;
    do {
      context.drawImage(v.video, 0, 0, width, height);
      const imageData = context.getImageData(0, 0, width, height);
      const code = jsQR(imageData.data, imageData.width, imageData.height);
      if (code) {
        console.log(code);
        v.rv = code.data;
      }
      await v.sleep(v.interval);
      console.log(v.cnt);
      v.cnt += v.interval;
    } while( v.rv === null && v.cnt < v.max );

    // 終了処理
    v.video.srcObject.getVideoTracks().forEach((track) => {
      track.stop();
    });
    v.parent.innerHTML = ''; // 作業用DIVを除去

    console.log(v.whois+' normal end.\n'+v.rv);
    return v.rv;

  } catch(error) {
    console.error(v.whois+' abnormal end.',error,v);
    return error;
  }
};
</script>
<script> //src="../../component/createElement.js">
function createElement(arg={}){
  const v = {rv:null,arg:{}};
  //console.log('createElement start.');

  // 既定値の設定
  v.arg = mergeDeeply(
    {tag: 'div',attr: {},style:{},event:{},text: '',html:'',children:[]},
    (typeof arg === 'string' ? {tag:arg} : arg));
  //console.log(v.arg);

  v.rv = document.createElement(v.arg.tag);
  for( v.i in v.arg.attr ){ // 属性の設定
    v.rv.setAttribute(v.i,v.x = v.arg.attr[v.i]);
  }
  for( v.i in v.arg.logical ){  // 論理属性の設定
    if( v.arg.logical[v.i] ){
      v.rv.setAttribute(v.i,true);
    }
  }
  for( v.i in v.arg.style ){ // スタイルの設定
    if( v.i.match(/^\-\-/) ){ // CSS変数の場合
      v.rv.style.setProperty(v.i,v.arg.style[v.i]);
    } else {
      v.rv.style[v.i] = v.arg.style[v.i];
    }
    //console.log(v.i,v.arg.style[v.i],v.rv.style);
  }
  for( v.i in v.arg.event ){ // イベントの設定
    v.rv.addEventListener(v.i,v.arg.event[v.i]);
    //console.log(v.i,v.arg.event[v.i],v.rv);
  }
  if( v.arg.html.length > 0 ){
    v.rv.innerHTML = v.arg.html;
  } else {
    v.rv.innerText = v.arg.text;  // 内部文字列
  }
  for( v.i=0 ; v.i<v.arg.children.length ; v.i++ ){
    // 子要素の追加
    v.rv.appendChild(createElement(v.arg.children[v.i]));
  }
  //console.log('createElement end.',v.rv);
  return v.rv;
}
</script>
<script>// src="../../component/mergeDeeply.js">
function mergeDeeply(target, source, opts) {
  const isObject = obj => obj && typeof obj === 'object' && !Array.isArray(obj);
  const isConcatArray = opts && opts.concatArray;
  let result = Object.assign({}, target);
  if (isObject(target) && isObject(source)) {
    for (const [sourceKey, sourceValue] of Object.entries(source)) {
      const targetValue = target[sourceKey];
      if (isConcatArray && Array.isArray(sourceValue) && Array.isArray(targetValue)) {
        result[sourceKey] = targetValue.concat(...sourceValue);
      }
      else if (isObject(sourceValue) && target.hasOwnProperty(sourceKey)) {
        result[sourceKey] = mergeDeeply(targetValue, sourceValue, opts);
      }
      else {
        Object.assign(result, {[sourceKey]: sourceValue});
      }
    }
  }
  return result;
}
</script>
<script>// src="../../component/whichType.js">
function whichType(arg,is){
  let rv = String(Object.prototype.toString.call(arg).slice(8,-1));
  switch(rv){
    case 'Number': if(Number.isNaN(arg)) rv = 'NaN'; break;
    case 'Function': if(!('prototype' in arg)) rv = 'Arrow'; break;
  }
  if( typeof is === 'string' ){
    return rv.toLowerCase() === is.toLowerCase();
  } else {
    return rv;
  }
}
</script>

<!-- =====================================================
  主処理
===================================================== -->
<script type="text/javascript" class="main">
function genQR(){
  const v = {whois:'genQR',rv:null};
  try {
    console.log(v.whois+' start.');
    v.text = document.querySelector('input').value;

    // QRコードの作成
    v.qr = document.querySelector('#qrcode');
    v.qr.innerHTML = '';
    v.rv = new QRCode(v.qr,{
			text: v.text,
			width: 300, height: 300,
			colorDark: "#000000",
			colorLight: "#ffffff",
			correctLevel: QRCode.CorrectLevel.H
    });

    // リンクの更新
    v.a = document.querySelector('a');
    v.a.setAttribute('href',v.text);
    v.a.innerText = v.text;

    console.log(v.whois+' normal end.',v.rv);
  } catch(e){
    console.error(v.whois+' abnormal end.',e,v);
    return e;
  }
}

window.addEventListener('DOMContentLoaded',async () => {
  const v = {};
  console.log('DOMContentLoaded start.');

  const rv = await scanQR('#webScanner');
  console.log(rv);
  document.querySelector('input').value = rv;

  genQR();

  console.log('DOMContentLoaded end.');
});
</script>
</html>