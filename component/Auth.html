<!DOCTYPE html><html xml:lang="ja" lang="ja"><head>
<title>Auth</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- 自作CSS -->
<link rel="stylesheet" type="text/css" href="szLib.css" />
<link rel="stylesheet" type="text/css" href="loading.css" class="core"
  data-embed="../component/loading.css" />
<style type="text/css" class="core">/* コアCSS */
</style>
<!-- 外部Script -->
<!-- 自作ライブラリ -->
<!-- webApp利用時： srcのみ必要。パスはcomponentが起点
  コンソール利用時：class="onConsole" data-embedが必要。data-embedの起点はtools -->
<script type="text/javascript" src="createElement.js" data-embed="../component/createElement.js"></script>
<script type="text/javascript" src="createPassword.js" data-embed="../component/createPassword.js"></script>
<script type="text/javascript" src="../external/cryptico.min.js" data-embed="../external/cryptico.min.js"></script>
<script type="text/javascript" src="mergeDeeply.js" data-embed="../component/mergeDeeply.js"></script>
<script type="text/javascript" src="whichType.js" data-embed="../component/whichType.js"></script>
</head><body>
  <div>
    <h1>だみぃ</h1>
    <p>これはログイン後に表示される初期画面です。</p>  
  </div>

<script type="text/javascript" class="core">/* コアScript */
/**
 * @typedef {Object} AuthProp - AuthOpt以外のAuthクラスプロパティ
 * @prop {number} constructorStart - constructor開始時刻(UNIX時間)
 * @prop {string} parentSelector - 親画面のCSSセレクタ
 * @prop {HTMLElement} parentWindow - 親画面のHTML要素
 * @prop {HTMLElement} AuthWindow - Auth関係画面のwrapper
 * @prop {HTMLElement} loading - ローディング画面のHTML要素
 */

/**
 * @typedef {Object} AuthOpt
 * @prop {string} [entryNo] - 受付番号(ID)
 * @prop {string} [passWord] - パスワード
 * @prop {string} [header=''] - 受付番号入力画面に表示するheaderのinnerHTML
 * @prop {string} [entryNoMessage='受付番号を入力してください'] - 受付番号入力画面に表示するメッセージ
 * @prop {string} [entryNoButton='送信'] - 受付番号入力画面のボタンのラベル
 * @prop {RegExp} [entryNoRegExp=/^[0-9]{1,4}$/] - 受付番号チェック用正規表現
 */

/**
 * @classdesc 入力されたID/PWと登録情報を突合し、IDに紐づく各種情報を返す
 *
 * - パスコード(passCode) : 受付番号入力後受信したメールに記載された番号
 * - パスワード(passWord) : 鍵ペア生成の際、秘密鍵の基となる文字列
 */
class Auth {
  /**
   * @constructor
   * @param {string} gatewayUrl - 認証局APIのURL
   * @param {AuthOpt} [opt={}] - 生成時オプション
   */
  constructor(gatewayUrl,opt={}){
    const v = {rv:null};
    console.log('Auth.constructor start.');
    try {
      this.constructorStart = Date.now();

      // 1.オプション未定義項目の既定値をプロパティにセット
      this.#setProperties(this,null,opt);
      console.log('this:',this);
      console.log(Date.now()-this.constructorStart);

      // 2.必須項目をプロパティに保存
      this.gateway.url = gatewayUrl;  // 認証局のURL
      console.log(Date.now()-this.constructorStart);

      // 3.各種画面を用意する
      //   ※鍵ペア生成で時間がかかるので、先に待機画面を表示
      this.#setWindows();
      // 初期画面として待機画面を表示
      this.#changeScreen('loading');
      console.log(Date.now()-this.constructorStart);

      // 4.秘密鍵・公開鍵を作成し、プロパティに格納する
      this.#setupKeys();
      console.log(Date.now()-this.constructorStart);

      // 5.entryNo(ID)を認証局に送信、パスコードメールを受け取る
      this.#getEntryNo();
      console.log(Date.now()-this.constructorStart);

      //console.log('v.rv='+JSON.stringify(v.rv));
      console.log('Auth.constructor end.');
      return v.rv;
    } catch(e){
      console.error('Auth.constructor abnormal end.',e);
      // ブラウザで実行する場合はアラート表示
      //if( typeof window !== 'undefined' ) alert(e.stack);
      throw e; //以降の処理を全て停止
    }
  }

  /** 既定値を設定する
   * @param {AuthOpt} opt - 生成時オプションとして渡された値
   * @returns {void}
   */
  #setProperties(dest,def,opt){
    const v = {rv:true,def:{
      parentSelector: "body", // {string} - 親要素のCSSセレクタ
      RSA:{  // 自局のRSAキー関係情報
        bits: 2048,     // {number} - RSAキー長
        passWord: null, // {string} - パスワード
        pwLength: 32,   // {number} - 自動生成する場合のパスワード文字数
        sKey: null,     // {RSAKey} - 秘密鍵
        pKey: null,     // {string} - 公開鍵
      },
      gateway:{ // 認証局関連情報
        url: null,  // {string} - APIのURL
        pKey: null, // {string} - 公開鍵
      },
      front: {  // 配信局関連情報
        url: null,  // {string} - APIのURL
        pKey: null, // {string} - 公開鍵
      },
      AuthWindow: {
        element: null, // {HTMLElement} - 受付番号入力画面の要素。setWindowsで設定。
        zIndex: 2147483646,  // z-indexの最大値-1
      },
      entryNo:{ // 受付番号関係
        element: null, // {HTMLElement} - 受付番号入力画面の要素。setWindowsで設定。
        value: null,  // {string} - 受付番号
        header:'',    // {string} - 受付番号入力画面に表示するheaderのinnerHTML
        msg1:'受付番号を入力してください', // {string} - 入力欄の前に表示するメッセージ
        button:'送信',  // {string} - 受付番号入力画面のボタンのラベル
        msg2:'',      // {string} - 入力欄の後に表示するメッセージ
        rex:/^[0-9]{1,4}$/, // {RegExp} - 受付番号チェック用正規表現
      },
      loading: {
        element: null,
        zIndex: 2147483647,  // z-indexの最大値
      },
      passCode:{
        element: null, // {HTMLElement} - パスコード入力画面の要素。setWindowsで設定。
        value: null,  // {string} - パスコード
        header:'',    // {string} - パスコード入力画面に表示するheaderのinnerHTML
        msg1:'確認のメールを送信しました。記載されているパスコード(数字6桁)を入力してください。<br>'
        + '※まれに迷惑メールと判定される場合があります。メールが来ない場合、そちらもご確認ください。',
                      // {string} - 入力欄の前に表示するメッセージ
        button:'送信',  // {string} - 受付番号入力画面のボタンのラベル
        msg2: '※パスコードの有効期限は1時間です',
        rex:/^[0-9]{1,4}$/, // {RegExp} - 受付番号チェック用正規表現
      },
    }};
    console.log('Auth.#setProperties start.');
    try {
      if( def !== null ){ // 2回目以降の呼出(再起呼出)
        // 再起呼出の場合、呼出元から渡された定義Objを使用
        v.def = def;
      }

      for( let key in v.def ){
        if( whichType(v.def[key]) !== 'Object' ){
          dest[key] = opt[key] || v.def[key]; // 配列はマージしない
        } else {
          if( !dest.hasOwnProperty(key) ) dest[key] = {};
          this.#setProperties(dest[key],v.def[key],opt[key]||{});
        }
      }

      if( def === null ){ // 初回呼出(非再帰)
        // 親画面のHTML要素を保存
        this.parentWindow = document.querySelector(this.parentSelector);
      }

      //console.log('this='+JSON.stringify(this));
      console.log('Auth.#setProperties end.');
      return v.rv;
    } catch(e){
      console.error('Auth.#setProperties abnormal end.',e);
      //if( typeof window !== 'undefined' ) alert(e.stack);
      v.rv.stack = e.stack; return v.rv;
    }
  }

  /** 秘密鍵・公開鍵を作成し、プロパティに格納する
   * @param {void}
   * @returns {void}
   */
  #setupKeys(){
    const v = {rv:null};
    console.log('Auth.#setupKeys start.');
    try {
      // パスワード未指定なら作成
      if( this.RSA.passWord === null ){
        this.RSA.passWord = createPassword(this.RSA.pwLength);
      }

      // 鍵ペアの生成
      this.RSA.sKey = cryptico.generateRSAKey(this.RSA.passWord, this.RSA.bits);
      this.RSA.pKey = cryptico.publicKeyString(this.RSA.sKey);
      console.log(this.RSA);

      // 秘密鍵の保存
      //Fs.writeFileSync('./private.json', JSON.stringify(key.toJSON()));

      //console.log('v.rv='+JSON.stringify(v.rv));
      console.log('Auth.#setupKeys end.');
      return v.rv;
    } catch(e){
      console.error('Auth.#setupKeys abnormal end.',e);
      // ブラウザで実行する場合はアラート表示
      if( typeof window !== 'undefined' ) alert(e.stack); 
      //throw e; //以降の処理を全て停止する場合
      v.rv.stack = e.stack; return v.rv; // 処理継続する場合
    }
  }

  /** Auth関係画面をセットする
   *
   */
  #setWindows(){
    const v = {rv:null};
    console.log('Auth.#setWindows start.');
    try {
      // Auth関係画面のwrapper
      this.AuthWindow.element = createElement({
        style:{
          // CSSで全画面オーバーレイを実装する方法＆コード例
          // https://pisuke-code.com/css-fullscreen-overlay/
          position: "absolute",
          left: 0, top: 0,
          width: "100%", height:"100%",
          background:"#fff",
          zIndex:this.AuthWindow.zIndex,
        },
      });

      // 受付番号入力画面
      this.entryNo.element = createElement({
        children:[
          {html:this.entryNo.header}, // タイトル
          {tag:'p',html:this.entryNo.msg1},  // 入力欄前メッセージ
          { // inputBox
            tag:'input',
            attr:{type:'text',name:'entryNo'},
            event:{'input':()=>{}},
          },
          { // 送信ボタン
            tag:'input',
            attr:{
              type:'button',
              name:'entryNoButton',
              value:this.entryNo.button,disabled:true
            },
          },
          {tag:'p',html:this.entryNo.msg2},  // 入力欄後メッセージ
        ],
      });

      // ローディング画面
      // ※ 受付番号・パスコード入力を隠蔽するため
      //   loading.zIndex > AuthWindow.zIndex とする。
      this.loading = {element:createElement({
        style:{
          position: "absolute",
          left: 0, top: 0,
          width: "100%", height:"100%",
          background:"#fff",
          zIndex:this.loading.zIndex,
        },
        children:[
          {
            style:{
              display:"flex",
              width:"100%",
              height:"100%",
              background:"#fff",
              justifyContent:"center",
              alignItems:"center",
            },
            children:[
              {
                attr:{class:'loading5'},
                style:{ // 点の軌道/大きさ/色
                  //"--dot-size":"4rem",
                  //"--m0:3.2rem",
                  "--R":0,
                  "--G":0,
                  "--B":0,
                },
                text:'loading...'
              },
            ],
          }
        ],
      })};

      // パスコード入力画面
      this.passCode.element = createElement({
        children:[
          {html:this.passCode.header}, // タイトル
          {tag:'p',html:this.passCode.msg1},  // 入力欄前メッセージ
          { // inputBox
            tag:'input',
            attr:{type:'text',name:'passCode'},
            event:{'input':()=>{}},
          },
          { // 送信ボタン
            tag:'input',
            attr:{
              type:'button',
              name:'passCodeButton',
              value:this.passCode.button,disabled:true
            },
          },
          {tag:'p',html:this.passCode.msg2},  // 入力欄後メッセージ
        ],
      });

      // 画面をセット
      this.parentWindow.appendChild(this.AuthWindow.element);
      this.AuthWindow.element.appendChild(this.entryNo.element);
      this.AuthWindow.element.appendChild(this.loading.element);
      this.AuthWindow.element.appendChild(this.passCode.element);

      //console.log('v.rv='+JSON.stringify(v.rv));
      console.log('Auth.#setWindows end.');
      return v.rv;
    } catch(e){
      console.error('Auth.#setWindows abnormal end.',e);
      // ブラウザで実行する場合はアラート表示
      //if( typeof window !== 'undefined' ) alert(e.stack);
      v.rv.stack = e.stack; return v.rv; // 処理継続する場合
    }

  }

  /** Auth関係画面の切り替え
   * @param {string} screenId - 画面ID
   * @returns {void}
   */
  #changeScreen(screenId){
    const v = {rv:true};
    console.log('Auth.#changeScreen start.');
    try {

      ['entryNo','loading','passCode'].forEach(x => {
        this[x].element.style.display = x === screenId ? '' : 'none';
      });

      console.log('Auth.#changeScreen end.');
      return v.rv;
    } catch(e){
      console.error('Auth.#changeScreen abnormal end.',e);
      // ブラウザで実行する場合はアラート表示
      //if( typeof window !== 'undefined' ) alert(e.stack);
      //throw e; //以降の処理を全て停止する場合
      v.rv.stack = e.stack; return v.rv; // 処理継続する場合
    }

  }

  /** entryNo(ID)を認証局に送信
   * @param {void}
   * @returns {void}
   */
  #getEntryNo(){
    const v = {rv:null,data:{cp:this.RSA.pKey}};
    console.log('Auth.#getEntryNo start.');
    try {

      if( this.entryNo.value !== null ){
        // 受付番号取得済の場合、すぐにGAS.auth1Aに送信
        v.data.entryNo = this.entryNo.value;

      } else {
        this.#changeScreen('entryNo');

      }
      
      //console.log('v.rv='+JSON.stringify(v.rv));
      console.log('Auth.#getEntryNo end.');
      return v.rv;
    } catch(e){
      console.error('Auth.#getEntryNo abnormal end.',e);
      // ブラウザで実行する場合はアラート表示
      if( typeof window !== 'undefined' ) alert(e.stack);
      //throw e; //以降の処理を全て停止する場合
      v.rv.stack = e.stack; return v.rv; // 処理継続する場合
    }

  }

  #fetchGAS(to,mode,data){
    const v = {rv:null};
    console.log('Auth.#fetchGAS start.');
    try {

      v.url = this[to].url;

      //console.log('v.rv='+JSON.stringify(v.rv));
      console.log('Auth.#fetchGAS end.');
      return v.rv;
    } catch(e){
      console.error('Auth.#fetchGAS abnormal end.',e);
      // ブラウザで実行する場合はアラート表示
      if( typeof window !== 'undefined' ) alert(e.stack); 
      //throw e; //以降の処理を全て停止する場合
      v.rv.stack = e.stack; return v.rv; // 処理継続する場合
    }




    fetch('https://ipinfo.io?callback')
    .then(res => res.json())
    .then(json => {
      config.handleName = json.ip;
      
      // 3.2.テスト対応
      console.log('Auth.constructor step.3.2 start.');
      if( config.debugMode === 0 ){
        // 本番時は認証画面を表示
        this.dom.style.display = '';
      } else {
        // デバッグ時はテスト用configセット後、後処理を実行
        this.setTestData(config.debugMode);
        this.callback();
      }

      // 4.終了処理
      console.log('Auth.constructor step.4 start.');
      this.changeArea('entryNo','受付番号入力');
      console.log('Auth.constructor end.');
    });

  }
}

</script>

<script type="text/javascript" class="gateway">/* 認証局用スクリプト */
function doPost(e){
  const v = {whois:'gateway.doPost',arg:JSON.parse(e.postData.contents)};
  try {
    console.log(v.whois+' start.\n'+JSON.stringify(v.arg));

    v.step = '1'; // 設定の読み込み
    lib.config = lib.setupConfig();

    /** clientからの最初の要求は署名・暗号化されていない以下のObj
     * @prop {string} fc - 'auth1B'固定
     * @prop {number} ts - client発信時刻(Date.now())
     * @prop {object} data
     * @prop {string} data.entryNo - 受付番号
     * @prop {string} data.publicKey - clientの公開鍵
     */
    if( v.arg.hasOwnProperty('fc') && v.arg.fc === 'auth1B' ){
      v.step = '2a'; // auth1Bの場合
      if( (Date.now() - v.arg.ts) > lib.config.system.validTime )
        throw new Error('timeover');
      v.r = v.arg.fc;
    } else {
      v.step = '2b'; // auth1B以外の場合、引数の正当性検証
      v.r = lib.isValidArg(v.arg);
      if( v.r instanceof Error ) throw v.r;  
    }

    v.step = '3'; // 処理分岐
    switch( v.r ){
      case 'auth1B':
        v.rv = lib.convResObj(lib.auth1B(v.arg.data));
        break;
      case 'auth2B':
        v.rv = lib.convResObj(lib.auth2B(v.arg.data));
        break;
      default:
        throw new Error('Invalid function.');
    }

    console.log(v.whois+' normal end.\n'+JSON.stringify(v.rv));
    return ContentService
    .createTextOutput(JSON.stringify(v.rv,null,2))
    .setMimeType(ContentService.MimeType.JSON);

  } catch(e) {
    console.error(v.whois+' abnormal end.\n'+e.stack+'\n'+JSON.stringify(v));
  }
}

/** auth1A: 参加者からのログイン情報を検証、auth1Bに問合せ
 * @param {object} arg - 引数オブジェクト
 * @param {string} arg.entryNo - 入力された受付番号
 * @param {string} arg.publicKey - 参加者公開鍵
 * @return {string} - gatewayの公開鍵
 */
function auth1A(arg){
  const v = {whois:'GASLib.auth.auth1A',rv:{}};
  try {
    console.log(v.whois+' start.\n',arg);

    // 参加者からの情報を検証
    v.step = '1';
    if( whichType(arg) !== 'Object' ) // 引数はオブジェクト
      throw new Error('Argument is not a Object.');
    if( Object.keys(arg).length !== 2 ) // メンバは2つ
      throw new Error('Invalid argument object.');
    if( !arg.hasOwnProperty('entryNo') || !arg.entryNo.match(/^[0-9]+$/) )
      throw new Error('Invalid entryNo.');
    if( !arg.hasOwnProperty('publicKey') || !arg.publicKey.match(/^[a-zA-Z0-9\+\/]+=*$/) )
      throw new Error('Invalid public key.');    

    v.step = '2'; // 配信局に検証とパスコード通知メール発行を依頼
    v.auth1B = {
      to: 'front',
      fc: 'auth1B',
      data: {
        entryNo: String(arg.entryNo),
        publicKey: arg.publicKey
      }
    };
    console.log(v.whois+' auth1B='+JSON.stringify(v.auth1B));
    v.step = '2.3'; // fetchの実行
    if((v.r = fetchGAS(v.auth1B)) instanceof Error ) throw v.r;

    v.step = '3'; // auth1Bの結果がOKなら認証局公開鍵を返す
    v.rv = config.gateway.publicKey;
    console.log(v.whois+' normal end.\n'+JSON.stringify(v.rv));
  } catch(e) {
    console.error(v.whois+' abnormal end.\n'+e.stack+'\n'+JSON.stringify(v));
    v.rv = e;
  } finally {
    return v.rv;
  }
}

/** auth2A: 参加者入力情報を検証、auth2Bに問合せ
 * @param {object} arg - 以下のメンバを持つオブジェクト
 * @param {string} arg.entryNo - 受付番号
 * @param {string} arg.passCode - パスコード
 * @return {object} 処理結果
 */
function auth2A(arg){
  const v = {whois:'GASLib.auth.auth2A',rv:null};
  try {
    console.log(v.whois+' start.\n',arg);
  
    v.step = '1'; // 参加者からの情報を検証
    if( whichType(arg) !== 'Object' ) // 引数はオブジェクト
      throw new Error('Argument is not a Object.');
    if( Object.keys(arg).length !== 2 ) // メンバは2つ
      throw new Error('Invalid argument object.');
    if( !arg.hasOwnProperty('entryNo') || !arg.entryNo.match(/^[0-9]+$/) )
      throw new Error('Invalid entryNo.');
    if( !arg.hasOwnProperty('passCode') || !arg.publicKey.match(/^[0-9]{6}$/) )
      throw new Error('Invalid passCode.');    

    v.step = '2'; // auth2Bに問合せ
    if((v.rv = fetchGAS({fc:'auth2B',data:{
      entryNo: String(arg.entryNo),
      passCode: arg.passCode
    }})) instanceof Error ) throw v.rv;

    v.step = '3'; // 終了処理
    console.log(v.whois+' normal end.\n'+JSON.stringify(v.rv));
  } catch(e) {
    console.error(v.whois+' abnormal end.\n'+e.stack+'\n'+JSON.stringify(v));
    v.rv = e;
  } finally {
    return v.rv;
  }
}
</script>

<script type="text/javascript" class="master">/* 管理局用スクリプト */
/** auth1B: 受付番号と参加者公開鍵を記録、パスコードをメールで送付
 * @param {object} arg - 引数オブジェクト
 * @param {string} arg.entryNo - 入力された受付番号
 * @param {string} arg.publicKey - 参加者公開鍵
 * @return {boolean} - 処理結果。OKならtrue
 * @desc 【処理概要】
 * <ol>
 * <li>試行NG日時に空欄あり(前回試行が通っていた場合) ⇒ 受付OK
 * <li>試行NG日時に空欄なし(前回試行回数上限を超えた結果、通っていなかった場合)
 *   <ol>
 *   <li>判定日時が空欄、または一定時間経過(再試行OK) ⇒ 受付OK
 *   <li>判定日時から一定時間経過していない(再試行NG) ⇒ 受付NG
 *   </ol>
 * </ol>
 * @desc 【受付OK時の処理】
 * <ol>
 * <li>パスコード、パスコード生成日時、参加者公開鍵を記録<br>
 * <li>判定日時と試行NG日時をクリア
 * <li>処理結果としてtrueを返す
 * </ol>
 * @desc 【受付NG時の処理】
 * <ol>
 * <li>処理結果としてfalseを返す
 * </ol>
 */
function auth1B(arg){
  const v = {whois:'GASLib.auth.auth1B',rv:null};
  try {
    console.log(v.whois+' start.\n',arg);
  
    v.step = '1.1'; // masterシートの読み込み
    v.sheetArg = {spreadId:config.master.spreadId,sheetName:'master'};
    v.master = szSheet(v.sheetArg);
    if( v.master instanceof Error ) throw v.master;
    v.step = '1.2'; // 該当者情報の検索
    v.private = v.master.lookup(arg.entryNo,'entryNo')
    if( v.private instanceof Error ) throw v.private;

    v.step = '2'; // 試行NG日時に空欄があるか判定
    v.rv = false;
    if( v.private.NG3 == '' // 試行NG日時に空欄あり(前回試行が通っていた)
    || v.private.certificate == '' // 試行したことがない
    || (Date.now() - new Date(v.private.certificate).getTime()) > config.system.retryInterval
    ) v.rv = true;

    v.step = '3'; // 試行OKだった場合の処理
    if( v.rv ){
      v.step = '3.1'; // パスコードの生成
      v.passCode = ('00000' + Math.floor(Math.random() * 1000000)).slice(-6);
      console.log(v.whois+' v='+JSON.stringify(v));
      v.step = '3.2'; // masterシートを更新
      v.r = v.master.update({
        publicKey: arg.publicKey,
        passCode: v.passCode,
        genPassCode: Date.now(),
        NG1:'',NG2:'',NG3:'',certificate:''
      },{key:'entryNo',value:arg.entryNo});
      if( v.r instanceof Error ) throw v.r;
      v.step = '3.3'; // パスコード通知メールを発信
      if((v.r = postMails({...config.template.passCode,to:{
        address: v.private['メールアドレス'],
        data: v.private
      }})) instanceof Error ) throw v.r;
    }

    console.log(v.whois+' normal end.\n'+JSON.stringify(v.rv));
  } catch(e) {
    console.error(v.whois+' abnormal end.\n'+e.stack+'\n'+JSON.stringify(v));
    v.rv = e;
  } finally {
    return v.rv;
  }
}

/** auth2B: パスコードを基にログイン可否を判断、OKなら参加者情報を返す
 * @param {object} arg - 以下のメンバを持つオブジェクト
 * @param {string} arg.entryNo - 受付番号
 * @param {string} arg.passCode - パスコード
 * @returns {object} 参加者情報を含むconfig
 * @desc 【処理概要】
 * <ol>
 * <li>試行NG日時に空欄あり(前回試行が通っていた場合) ⇒ 試行OK
 * <li>試行NG日時に空欄なし(前回試行回数上限を超えた結果、通っていなかった場合)
 *   <ol>
 *   <li>判定日時が空欄、または一定時間経過(再試行OK) ⇒ 試行OK
 *   <li>判定日時から一定時間経過していない(再試行NG) ⇒ 「一定時間後に再試行を」エラー
 *   </ol>
 * </ol>
 * 
 * @desc 【試行OK時の処理】
 * <ol>
 * <li>パスコードが一致 ⇒ 判定日時をセットしてconfig＋参加者情報を返す
 * <li>パスコードが不一致 ⇒ NG欄に処理日時を追加、パスコード不一致エラー
 * </ol>
 */
function auth2B(arg){
  const v = {whois:'GASLib.auth.auth2B',arg:arg,rv:null};
  try {
    console.log(v.whois+' start.\n',arg);

    v.step = '1.1'; // masterシートの読み込み
    v.sheetArg = {spreadId:config.master.spreadId,sheetName:'master'};
    v.master = szSheet(v.sheetArg);
    if( v.master instanceof Error ) throw v.master;
    v.step = '1.2'; // 該当者情報の検索
    v.private = v.master.lookup(arg.entryNo,'entryNo')
    if( v.private instanceof Error ) throw v.private;

    v.step = '2'; // 試行NG日時に空欄があるか判定
    v.rv = false;
    if( v.private.NG3 == '' // 試行NG日時に空欄あり(前回試行が通っていた)
    || v.private.certificate == '' // 試行したことがない
    || (Date.now() - new Date(v.private.certificate).getTime()) > config.system.retryInterval
    ) v.rv = true;

    if( v.rv ){
      v.step = '3a'; // 試行OKだった場合の処理
      // 参加者に渡す情報(private)を作成
      v.rv = {private:v.private};
      // config情報を追加
      Object.keys(config).forEach(x => {
        // lv02にauthority定義があり、かつ申請者のauthorityもあれば追加
        if( config[x].hasOwnProperty(authority)
        && (config[x].authority & v.private.authority) > 0 ){
          v.rv[x] = config[x];
        }
      });
    } else {
      v.step = '3b'; // 試行NGだった場合の処理
      throw new Error('前回ログイン失敗から規定時間経過していません');
    }

    v.step = '4'; // 終了処理
    console.log(v.whois+' normal end.\n'+JSON.stringify(v.rv));
  } catch(e) {
    console.error(v.whois+' abnormal end.\n'+e.stack+'\n'+JSON.stringify(v));
    v.rv = e;
  } finally {
    return v.rv;
  }
}
</script>

<script type="text/javascript" class="test">/* テスト用 */
function AuthTest(){
  const v = {data:[]};
  console.log('AuthTest start.');
  try {
    v.conf = new Auth('body',{
      entryNoWindow:{
        header:'<h1>受付番号入力</h1>',
      }
    });
    console.log('AuthTest end.');

  } catch(e){
    console.error('AuthTest abnormal end.',e);
  }
}
</script>

<script type="text/javascript">
window.addEventListener('DOMContentLoaded',() => {
  AuthTest();  // 開発者コンソール上でテスト
});
</script>
</body></html>