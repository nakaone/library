<!DOCTYPE html><html xml:lang="ja" lang="ja"><head>

  <title>ena.kaon 証憑</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <style type="text/css">
    /* =======================================================
    [report.css]
      提出用HTML(report.html)のCSS部分。
      build.shでreport.htmlに組み込み、「証憑yyyy」のGASにコピー
    ======================================================= */
    
    html {line-height: 1.5rem;}
    h1 {
      font-size: 1.6rem;
      color: #fff;
      background-color: #aaa;
      border: solid 3px #888;
      padding: 0.5rem;
    }
    h2 {font-size: 1.2rem;}
    div.navi {
      width: 800px;
      margin: 0 auto;
      background-color: #ccc;
      padding: 1rem;
    }
    div[data-type] {
      display: grid;
      gap: 1rem;
      margin: 1rem;
    }
    th, td {
      padding: 0.2rem 0.5rem;
      border-left: solid 1px #fff;
      border-right: solid 1px #888;
      border-top: solid 1px #fff;
      border-bottom: solid 1px #888;
      vertical-align: top;
    }
    th {background: #ddd;}
    td {background: #fff;}
    ul {list-style: none;}
    li {margin-bottom: 0.5rem;}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/alasql/4.6.4/alasql.min.js" integrity="sha512-/IeaoBeXScPD3EiZkaYKzjnqRnKJI73FM/18T8P+v2n11hKNCKQmko/n2ccvlDyH3AziR0oPEGShwsZEwO/Jjg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>const data = {"created":"2025/08/21","files":[{"id":"1ATSxdgmIT1ZxIoXQrPTdeMGPNeDBCEcx7UC29FF2FcM","name":"開発用"},{"id":"1j0Mabm7pMQMque4gT8Zr9xGku8FFWQbR","name":"20250808_健康保険・厚生年金保険被保険者標準報酬決定通知書.pdf"},{"id":"1ydJXUwV6bwA6SgMoy1rkalemzPhtj-G9","name":"20250605_固都税納税通知書.pdf"},{"id":"1sk5K2tTHlsoTCuxRCIEEstGJRWSqYbvD","name":"SMTLF202501.pdf"},{"id":"1KaaezOsQMobZORAwm9-73788r48tRASRECfmOfXvWxc","name":"証憑2024"},{"id":"1HU9QwTQksztT9wSTMT8nLtXsjqmOKqtD","name":"YFP202506.pdf"},{"id":"1SH_Dmi7sl-b3K0b6JyYacoF_X_shXFki","name":"YFP202409.pdf"},{"id":"1EqlDPWySpl0iJ1anZ2sPeLeTUA2Rw0_J","name":"YFP202410.pdf"},{"id":"1Ua8KL7FOFa5r6TcrYKcCYk6ZZL-XZeZm","name":"YFP202411.pdf"},{"id":"1K6ufCGu1AmnHFp9V1MKlo3yvwFgXCC5m","name":"YFP202412.pdf"},{"id":"1me0ohvGnI0lMPbcF9YbBV5g-DnXepWwd","name":"YFP202501.pdf"},{"id":"1b1GCWvPM2BKaaQkk2HFKkQVl4tvxoFN-","name":"YFP202502.pdf"},{"id":"1IibZSOEiOoH8Q2qBAKeTubMlcTxi7faH","name":"YFP202503.pdf"},{"id":"1QYfQ1Du2uec2OHJNSI8AvZ7RcfTzAyvJ","name":"YFP202504.pdf"},{"id":"1tzZ7Cp4a1zRPMW-xP0WfURsIyWAAR06J","name":"YFP202505.pdf"},{"id":"10Ol1bQYSW6yJ-BhJA_4KFoBo69Nj4jSi","name":"20250630_400_003.pdf"},{"id":"1v5uFTtTkeaDcH6mPbFUGxrtWAK5qZBvG","name":"20250630_400_000.pdf"},{"id":"1BZNOm2xdiPGM0p-Lhc527IM9hph1Ieqc","name":"20250531_400_003.pdf"},{"id":"1Qjtqp2ZeLh7pFEjrTemqIE9KQ4g9OYmc","name":"20250531_400_000.pdf"},{"id":"1bqN3KjAQiYslnm8kuSrf1OZWC7sltXBS","name":"MUFG10.pdf"},{"id":"1uvIX0nbDpNNTD3DAC5qlmqPOkpXjBAJU","name":"202509.pdf"},{"id":"1fbnOnZfXP8668DFDgYsmqMY3-Kzop4TP","name":"202508.pdf"},{"id":"1VfYA1UXAfWqVru40gsAdqNy---F9m7fw","name":"202507.pdf"},{"id":"1OnRJfOJZyx_H4OImAUk7n36ThfHYcvCP","name":"note202423.pdf"},{"id":"1PmiDSvK2mGQ--0ZWWBPXNkmkbW_AuR5j","name":"note202422.pdf"},{"id":"1Rl56ZxfylcbvqHbSQNiGX2xxNQGKE0hX","name":"SMBC07.pdf"},{"id":"1_5eI2oZoBA34F6Yze5NF26lzYv8UB2o3","name":"pension202507.pdf"},{"id":"1BCvfJw33ipCWRutWkInN6nEFkyni3BSJ","name":"pension202506.pdf"},{"id":"1jKJ_wkmKB_Rp5rY6hvS37O4TotVgnfZv","name":"HS202507.pdf"},{"id":"10UUj51tcETH5KErSTR1yS-8B8nE-o_79","name":"CK202508.pdf"},{"id":"1BoKOkNX_BMhOPSZLHBeZJShDMAPxtXCm","name":"EF202508.pdf"},{"id":"1Bun4eFNXtr7R_e9vz8yzoXfwLPDyNyyI","name":"レシート（発行_ アース西東京）.pdf"},{"id":"11zJApmPffEOonDyzbC376SMZOwW3KCvW","name":"EF202507.pdf"},{"id":"1lFHpR9YhLIgECcKe9VB49BqJ9u5e0uPd","name":"CK202507.pdf"},{"id":"1g3O_7tt7SBgD_-Ul2Yv9qEgndOWltMty","name":"カメラのキタムラ - 注文番号：6-25070337767.pdf"},{"id":"1ZInZcnJ85y9RE2QhBJ0uXa0kCx5cGcVy","name":"EF202505.pdf"},{"id":"11YcUIfTfdCYQyHZmvPvSEM2H5pG5w09P","name":"CK202505.pdf"},{"id":"1QYqUsfl3mLaOXXgtvuIFBq8voNOjp_T3","name":"note202420.pdf"},{"id":"1Wr_ZiVQuLzvldvstP2qKIVOgMnUIqtCB","name":"note202419.pdf"},{"id":"1dga4JN0wjyir1vKQWQMXyrTb8A2ttqrA","name":"note202418.pdf"},{"id":"1czqX_kp1hUc5MWjEMXWr52I4w0dwgyMa","name":"note202417.pdf"},{"id":"1qu15HlBEnuzPtSFHf79C_-2k1fqJIonk","name":"note202416.pdf"},{"id":"1Bh59Atuyu4W6RxcIKRRZVLdn9uH9-hN4","name":"note202415.pdf"},{"id":"1JBVGIvDZAOc9dRbGhPnGkUNaDLM2KvgN","name":"pension202505.pdf"},{"id":"1EHDwN80tJprY1F9H27WLE0Vw16m5jU4e","name":"pension202504.pdf"},{"id":"1HRuCoHLQUmZcoSYbpaghcQGnA9Og7EUk","name":"20250430_400_003.pdf"},{"id":"1h6TzhFR0CvRLYBHxIv_AUj5Pul5YEYT7","name":"20250430_400_000.pdf"},{"id":"1w9jnnzjK9h4-n1OTf4hhzCXCFib3YFoP","name":"20250331_400_000.pdf"},{"id":"1KRSOFGb4HqFElsWN7KC7I1ywD5VtWpqT","name":"20250331_400_003.pdf"},{"id":"1kMz65n4DP3Ozo5vYpTVSirucydEbMv2Q","name":"HS202506.pdf"},{"id":"1IbOhlwhETkLTpD2bcMPLIpJgpP9aTY9T","name":"HS202505.pdf"},{"id":"1CKUFUPi7eoLwwudlL8vGaEwjZX3dRr2u","name":"HS202504.pdf"},{"id":"17bOhRz5xn7PLpa3bIxrs5LXDmrzU3bFh","name":"note202421.pdf"},{"id":"1-jIEuChTyB7W3TX8jqUShy9jzH9E0_Qq","name":"202506.pdf"},{"id":"19MTD3X6tmQFwh3Wp2h2wCdyz0Njc-lHR","name":"202505.pdf"},{"id":"12tBvomHwrTWzj7W6cFMiBf8xnvNyUFo8","name":"CK202506.pdf"},{"id":"1Xh5cV-Z1zDUTXgiWKPuUvip9_NqEMbz1","name":"EF202506.pdf"},{"id":"1DgiN-KZkGljLdogLRstsUokQ-l_tObbj","name":"SMBC06.pdf"},{"id":"1wTr5Xz7_UaNS2dv4SJviR72x_JXXSlF7","name":"MUFG09.pdf"},{"id":"1uu_NH-iGsQYC21pVZS3vohIVfhYaJrn_","name":"2025年度給与所得等に係る税額決定通知書.pdf"},{"id":"1DaGH1LmErJ0Pc7gcz4uP8PHgP9xyorJC","name":"20250531_領収書 _ 無印良品.pdf"},{"id":"11pXYjxhKQIklRiAFQJNKQZ8JtpLUgKZC","name":"20241025_スマホスタンド領収書.pdf"},{"id":"1iLsevNUcaq9kp3rqCarZMwhG1HdFcgOL","name":"20241206_スマホフィルム領収書.pdf"},{"id":"1dEIdlcHtfkXresrJVvi7yqschZRA9N_W","name":"20250125_ワイヤレスマウス領収書.pdf"},{"id":"1A99DTWWEdXUq8KAFu-nq-hVuWer3T9WG","name":"RC182643190.pdf"},{"id":"1YamIvPbChf_wYt8lvs7wvWmQEQKdhL6D","name":"RC182643445.pdf"},{"id":"1kdiuk2zTVwL9BAKBocuyCj5HltUvKDF-","name":"RC182722417.pdf"},{"id":"1xXxbijwGf65A75_BV54jjEQWBzYf8uss","name":"20250421_SMBCローン返済明細書.pdf"},{"id":"1niqoqRwcbwxmKAJpXMTw8b9RquCm_1RJ","name":"CK202504.pdf"},{"id":"1RzMfno62JFt-1O6pzP3d4kP033qEEqiP","name":"EF202504.pdf"},{"id":"1Bc1ZAMHhib6spfk-bGnUhRamFZOzAXDx","name":"Amazon.co.jp - 注文番号 249-7275815-9909431.pdf"},{"id":"1yyrL-IT8GGBXOmq_p1tNZ8jSXw4JrlVs","name":"note202414.pdf"},{"id":"1Szu26rRcExiBzp9tYA01zM2qBqN6TPbb","name":"note202413.pdf"},{"id":"1GPAAeyG11pNQuxCrXkHzD1fhUXbGRinj","name":"note202412.pdf"},{"id":"1306vItumI12s6by6tz3tdtQoAkJ_yhhz","name":"note202411.pdf"},{"id":"1UFKtlLe18F8Bn4GsJYJXMF5IIbEGmErU","name":"note202410.pdf"},{"id":"1lmP0_Xm1QqJJGOEWd4uM4QIYa4ddLbpV","name":"pension202503.pdf"},{"id":"1x74FxGPSKP3_MU8endjZa_J1Kd7GBIUm","name":"pension202502.pdf"},{"id":"1bb2PxD3bAIfcMbnTSFoCCr_kGrfn_R5Y","name":"HS202503.pdf"},{"id":"1rj2By92TP6pjqFzeYVSy7B2kBW7lCTjc","name":"HS202502.pdf"},{"id":"1naSwYUsHJ3br91OqrrNiWUA7KwTB8zVS","name":"202504.pdf"},{"id":"1aV2AaO8cS7x0O732W7-fbCeotsVWb5vg","name":"202503.pdf"},{"id":"14-zEmyDeTq55ya3MTc9fCcpnLcA3497l","name":"202502.pdf"},{"id":"1dpS_E7PbJYv-FfVGHIMxlfnZzLw5lbLF","name":"20250228_400_000.pdf"},{"id":"1lkDFoTaOMbcjcFgv3gXOf8gYu4PnTqm0","name":"20250228_400_003.pdf"},{"id":"1Q0FrqOjnfjcl1bioBtydtdZZmoajRQXC","name":"20250131_400_000.pdf"},{"id":"1ewPi8zV-IKpmLpSYNQiyGkzN_yBoALBQ","name":"20250131_400_003.pdf"},{"id":"1EF-b61LzHlJo-33zNWLupLLxRGl7dHGB","name":"CK202503.pdf"},{"id":"16Dmq8oqUV4zzBN6GjFryKjdfH-9Q-9tg","name":"EF202503.pdf"},{"id":"1fNZ4pv2Xao-VYGXnCdpsseUrhfFnVZpq","name":"CK202502.pdf"},{"id":"1_dQYOWclrqs44JNF5KAJ40jsNnfpuBf4","name":"EF202502.pdf"},{"id":"1mHSAOycMALDi4RGbVtlbW1H-9zmNoyCZ","name":"note202407.pdf"},{"id":"16bpSXt1abglQdviYBQwlgrJbqAtAphWo","name":"note202406.pdf"},{"id":"1O_LONeEvOnHlBrmCeQ8EOShUyRmLQWQ9","name":"note202405.pdf"},{"id":"1sZl7XWWOxQINuhJe5oTQCf43ZA2UfjEH","name":"note202404.pdf"},{"id":"1odsw2M5DODSQ_B5jyK-1l4Mh57IhXPiY","name":"note202403.pdf"},{"id":"128bk842qaJY3qi27to8oDRvPATwUOcvy","name":"note202402.pdf"},{"id":"19BQJ1r14XeiP1IaPSoGk0_aLq8wXttXG","name":"note202401.pdf"},{"id":"1M83T8RtTzJ0pyYsGGbd8wy0R6EdjUYXr","name":"note202408.pdf"},{"id":"1_2yg32TpU70QBdCbT8v8Sr0PX3PNUDtO","name":"note202409.pdf"},{"id":"1vFdsfFrDghjn1YVo3gFHNyUGSwEVoou4","name":"pension202501.pdf"},{"id":"1s2et1wZc2kqW1c6CtCL79ZUUYEMEPmaj","name":"pension202412.pdf"},{"id":"1COWbHg_AG286AfAttNgrg3ZMjrWRwx1u","name":"pension202411.pdf"},{"id":"1-_XLb5MqiGnlBSj0hhV7q_oz0T2oVPW_","name":"pension202410.pdf"},{"id":"1XFImLh3oQJ5xAWTwUv0QtDn03SGUpqNS","name":"HS202501.pdf"},{"id":"18PRA45x0i4h7EBoKpwFMQpSJUJU_poc_","name":"HS202412.pdf"},{"id":"1Z0B0sjEAm3taT9XxWtWGErQKp8_EkP67","name":"HS202411.pdf"},{"id":"1DMXrens7X7ddj-uODheqXLuZ2IdKuOzg","name":"HS202410.pdf"},{"id":"1YwnwWEOHIrcVxrKACi_iZaD64ifnT9ei","name":"Amazon.co.jp - 注文番号 249-4845575-3719036.pdf"},{"id":"195AbJCoKG74szRbjbo-19CrL2YTjgk3E","name":"Amazon.co.jp - 注文番号 249-6593585-8211811.pdf"},{"id":"1Ca2sWeFGd7ZkWfnCw4K6NnYxYU8BYJKF","name":"Amazon.co.jp - 注文番号 249-2194427-8251059.pdf"},{"id":"1Q7x6RsI6UcQMuKRkgtA6O6xzmk359CSo","name":"Amazon.co.jp - 注文番号 249-8191798-9007841.pdf"},{"id":"1yQfuzlIZWhcP0RNOZU_qT6EeyOLEBd-N","name":"Amazon.co.jp - 注文番号 249-4204728-6112628.pdf"},{"id":"1WFRbAeaRy-9fkGkbaN4wzskEjHjC6DTr","name":"Amazon.co.jp - 注文番号 249-3858977-2955844.pdf"},{"id":"1wUYvRxTDWigLenGmOvb3FzOD1DAklilJ","name":"Amazon.co.jp - 注文番号 249-2647820-1244618.pdf"},{"id":"1DFKN2otaoWswY7-NcnbxLyYoyUYCuMCx","name":"202501.pdf"},{"id":"1yttzxFoy0zIw9AYRnIO248VSqMt8f9pB","name":"202412.pdf"},{"id":"1te4t3VlgpmamtirE6TXdRRPOF8QRaFCW","name":"202411.pdf"},{"id":"1YeL8afVQWWQ4kLbZy4SGpCiQFbRGdwN0","name":"202410.pdf"},{"id":"1L918Z3YTo2lfYaBoTVjSYIodV3ha8J3t","name":"20241231_400_003.pdf"},{"id":"1w7-YBX6Eg3cV489U8N4Rr_9XTKQYaKX8","name":"20241231_400_000.pdf"},{"id":"1GLN4kWtVPiD2AQgjUn_s3rlYN30V49bS","name":"20241130_400_003.pdf"},{"id":"13YqXmS_WQXxUC0Hb1phNtbBqvQ-Pw16p","name":"20241130_400_000.pdf"},{"id":"1Z8-FRUHfHIzuFZPzvRAjXZOmg3gmfrnZ","name":"20241031_400_000.pdf"},{"id":"1aRcrF5P2Jf2doBWW5th5BuJu0YCzhwon","name":"20241031_400_003.pdf"},{"id":"16OnYUqZY3GNAZpPkvXiymN7leB2JDVo-","name":"20240930_400_003.pdf"},{"id":"1hb-AJG_fU9uXoZTIEV93-FvYwWaL2ROZ","name":"20240930_400_000.pdf"},{"id":"1pavHX7kCuq5vo2w1SKjkHHo99ujBCQKV","name":"EF202501.pdf"},{"id":"1uI1F3dE_cy2KZ-O_URWZscRFaQXqyKNQ","name":"CK202501.pdf"},{"id":"19jlv3d8sbcE7EDJnasyM5HQIgZjg1mu0","name":"20250109_SMBCローン返済明細書.pdf"},{"id":"18exrmCa45gXffolZO9vdU5GD0B2EAK1N","name":"20241211_司法書士請求書.pdf"},{"id":"1ZSCRhUWPCdeZJldHgbFQgZTQKVAP2Bsc","name":"CK202412.pdf"},{"id":"1VnSjX38DoLGxfCzIg-tl8tDRRT3IVh4g","name":"EF202412.pdf"},{"id":"1aJlK0Gk2IFQ1B_-Uph6ahGpU9RXDaG4L","name":"CK202411.pdf"},{"id":"1gHimOtXHVvzUCJwv4YA4R8DTKwPQTTH-","name":"EF202411.pdf"},{"id":"1u5n77hzw84eTeMAkqTsr5v-ccarY62cK","name":"CK202410.pdf"},{"id":"1_01-0Z7dfKT18_gPzxUlPnfTqTTbnQwY","name":"EF202410.pdf"}],"記入用":[{"id":"1uu_NH-iGsQYC21pVZS3vohIVfhYaJrn_","type":"参考資料","date":"2025/05/16","label":"2025年度給与所得等に係る特別徴収税額の決定通知書","price":"","payby":"","note":""},{"id":"1ydJXUwV6bwA6SgMoy1rkalemzPhtj-G9","type":"参考資料","date":"2025/06/05","label":"固都税納税通知書","price":"","payby":"","note":""},{"id":"1j0Mabm7pMQMque4gT8Zr9xGku8FFWQbR","type":"参考資料","date":"2025/08/08","label":"健康保険・厚生年金保険被保険者標準報酬決定通知書","price":"","payby":"","note":""},{"id":"","type":"特記事項","date":"2024/12/02","label":"通信キャリア変更","price":"","payby":"","note":"プロバイダ・キャリアをKDDI/UQ Mobile/Biglobeに変更"},{"id":"","type":"特記事項","date":"2025/04/01","label":"アルバイト採用","price":"","payby":"","note":"2025/04/01よりアルバイトとして嶋津史奈を雇用。条件は以下の通り。\n- 作業内容：書類整理、会計業務補助\n- 時給1,200円、月25時間"},{"id":"1sk5K2tTHlsoTCuxRCIEEstGJRWSqYbvD","type":"返済明細","date":"2024/10/01","label":"SMTLFローン返済明細","price":"","payby":"","note":""},{"id":"19jlv3d8sbcE7EDJnasyM5HQIgZjg1mu0","type":"返済明細","date":"2024/12/30","label":"SMBCローン返済明細","price":"","payby":"","note":""},{"id":"1xXxbijwGf65A75_BV54jjEQWBzYf8uss","type":"返済明細","date":"2025/04/21","label":"SMBCローン返済明細","price":"","payby":"","note":""},{"id":"11pXYjxhKQIklRiAFQJNKQZ8JtpLUgKZC","type":"電子証憑","date":"2024/10/28","label":"スマホスタンド","price":"1850","payby":"役員借入金","note":""},{"id":"1WFRbAeaRy-9fkGkbaN4wzskEjHjC6DTr","type":"電子証憑","date":"2024/11/16","label":"ボールペン替芯","price":"545","payby":"AMEX","note":""},{"id":"1wUYvRxTDWigLenGmOvb3FzOD1DAklilJ","type":"電子証憑","date":"2024/11/16","label":"文具","price":"3524","payby":"AMEX","note":""},{"id":"1iLsevNUcaq9kp3rqCarZMwhG1HdFcgOL","type":"電子証憑","date":"2024/12/05","label":"スマホフィルム","price":"2520","payby":"役員借入金","note":""},{"id":"1yQfuzlIZWhcP0RNOZU_qT6EeyOLEBd-N","type":"電子証憑","date":"2024/12/07","label":"スマホ消耗品、書籍","price":"3899","payby":"AMEX","note":""},{"id":"1YwnwWEOHIrcVxrKACi_iZaD64ifnT9ei","type":"電子証憑","date":"2024/12/09","label":"書籍","price":"3080","payby":"AMEX","note":""},{"id":"1Ca2sWeFGd7ZkWfnCw4K6NnYxYU8BYJKF","type":"電子証憑","date":"2024/12/09","label":"プリンタインク","price":"1180","payby":"AMEX","note":""},{"id":"1Q7x6RsI6UcQMuKRkgtA6O6xzmk359CSo","type":"電子証憑","date":"2024/12/09","label":"USB充電器","price":"3919","payby":"AMEX","note":""},{"id":"195AbJCoKG74szRbjbo-19CrL2YTjgk3E","type":"電子証憑","date":"2024/12/11","label":"クリヤーブック","price":"2220","payby":"AMEX","note":""},{"id":"18exrmCa45gXffolZO9vdU5GD0B2EAK1N","type":"電子証憑","date":"2024/12/11","label":"司法書士(登記変更、他)","price":"93500","payby":"役員借入金","note":"p.2のみ"},{"id":"1dEIdlcHtfkXresrJVvi7yqschZRA9N_W","type":"電子証憑","date":"2025/01/28","label":"PC周辺機器","price":"1310","payby":"役員借入金","note":""},{"id":"1Bc1ZAMHhib6spfk-bGnUhRamFZOzAXDx","type":"電子証憑","date":"2025/03/13","label":"養生テープ","price":"1369","payby":"AMEX","note":""},{"id":"1A99DTWWEdXUq8KAFu-nq-hVuWer3T9WG","type":"電子証憑","date":"2025/05/07","label":"営繕・補修用資材","price":"4747","payby":"役員借入金","note":""},{"id":"1YamIvPbChf_wYt8lvs7wvWmQEQKdhL6D","type":"電子証憑","date":"2025/05/07","label":"営繕・補修用資材","price":"123","payby":"役員借入金","note":""},{"id":"1kdiuk2zTVwL9BAKBocuyCj5HltUvKDF-","type":"電子証憑","date":"2025/05/08","label":"営繕・補修用資材","price":"2813","payby":"役員借入金","note":""},{"id":"1DaGH1LmErJ0Pc7gcz4uP8PHgP9xyorJC","type":"電子証憑","date":"2025/05/22","label":"備品(バスケット)","price":"5279","payby":"役員借入金","note":""},{"id":"1g3O_7tt7SBgD_-Ul2Yv9qEgndOWltMty","type":"電子証憑","date":"2025/07/03","label":"カメラ(本体)","price":"136170","payby":"役員借入金","note":""},{"id":"1Bun4eFNXtr7R_e9vz8yzoXfwLPDyNyyI","type":"電子証憑","date":"2025/08/06","label":"若宮宅残置物撤去","price":"330000","payby":"役員借入金","note":""}],"交通費":[{"date":"2024/10/08","destination":"羽沢","label":"現状確認","route":"笹塚 - 市ヶ谷 - 新桜台","number":"1","price":"1240","note":""},{"date":"2024/11/08","destination":"上池袋","label":"現状確認","route":"笹塚 - 新宿 - 板橋","number":"1","price":"640","note":""},{"date":"2024/12/09","destination":"恵比寿","label":"現状確認","route":"笹塚 - 新宿 - 恵比寿","number":"1","price":"620","note":""},{"date":"2024/12/10","destination":"オーシャン","label":"打合せ(登記変更依頼)","route":"代々木上原 - 表参道","number":"1","price":"360","note":""},{"date":"2025/01/08","destination":"羽沢","label":"現状確認","route":"笹塚 - 市ヶ谷 - 新桜台","number":"1","price":"1240","note":""},{"date":"2024/11/10","destination":"ふじやまビレジ","label":"打合せ(方針論議)","route":"笹塚 - 上界戸","number":"2","price":"14800","note":"〜11/12"},{"date":"2025/02/08","destination":"上池袋","label":"現状確認","route":"笹塚 - 新宿 - 板橋","number":"1","price":"640","note":""},{"date":"2025/03/01","destination":"上池袋","label":"SB現調","route":"笹塚 - 新宿 - 板橋","number":"2","price":"1280","note":""},{"date":"2025/03/09","destination":"恵比寿","label":"現状確認","route":"笹塚 - 新宿 - 恵比寿","number":"1","price":"620","note":""},{"date":"2025/03/26","destination":"上池袋","label":"SB現調","route":"笹塚 - 新宿 - 板橋","number":"1","price":"640","note":""},{"date":"2025/04/08","destination":"羽沢","label":"現状確認","route":"笹塚 - 市ヶ谷 - 新桜台","number":"1","price":"1240","note":""},{"date":"2025/05/08","destination":"上池袋","label":"現状確認","route":"笹塚 - 新宿 - 板橋","number":"1","price":"640","note":""},{"date":"2025/05/24","destination":"野方","label":"現地調査","route":"笹塚 - 新宿 - 高田馬場 - 野方","number":"2","price":"1880","note":""},{"date":"2025/06/08","destination":"恵比寿","label":"現状確認","route":"笹塚 - 新宿 - 恵比寿","number":"1","price":"620","note":""},{"date":"2025/07/04","destination":"野方","label":"現状確認、清掃","route":"笹塚 - 新宿 - 高田馬場 - 野方","number":"1","price":"940","note":""},{"date":"2025/07/08","destination":"羽沢","label":"現状確認","route":"笹塚 - 市ヶ谷 - 新桜台","number":"1","price":"1240","note":""},{"date":"2025/07/23","destination":"野方","label":"現状確認、整理","route":"笹塚 - 新宿 - 高田馬場 - 野方","number":"2","price":"1880","note":""},{"date":"2025/08/06","destination":"野方","label":"残置物搬出","route":"笹塚 - 新宿 - 高田馬場 - 野方","number":"2","price":"1880","note":""},{"date":"2025/08/08","destination":"上池袋","label":"現状確認","route":"笹塚 - 新宿 - 板橋","number":"1","price":"640","note":""}]};</script>
  <script type="text/javascript">
    /** HTMLElementを生成する
     * @param {CEDefObj|CEDefObj[]} arg - 生成するHTMLElementの定義
     * @param {HTMLElement|string} [parent=null] - 本関数内部で親要素への追加まで行う場合に指定
     * @returns {HTMLElement|Error}
     */
    function createElement(arg,parent=null){
      const v = {whois:'BasePage.createElement',rv:[],step:0};
      //console.log(v.whois+' start.',arg);
      try {
        v.step = 1.1; // 引数を強制的に配列化
        v.isArr = Array.isArray(arg); // 引数が配列ならtrue。戻り値にも使用するので保存
        if( !v.isArr ) arg = [arg];
        v.step = 1.2; // 親要素の特定
        if( parent !== null ){
          v.parent = typeof parent === 'string' ? document.querySelector(parent) : parent;
        }
    
    
        for( v.i = 0 ; v.i<arg.length ; v.i++ ){
          v.step = 2; // 既定値の設定
          v.def = {tag: 'div',attr: {},style:{},event:{},text: '',html:'',children:[],name:''};
          Object.assign(v.def,(typeof arg[v.i] === 'string' ? {tag:arg} : arg[v.i]))
    
          v.step = 3; // HTMLElementを生成、v.objとする
          v.obj = document.createElement(v.def.tag);
    
          v.step = 4; // HTMLElementの属性を定義
          for( v.j in v.def.attr ){
            v.obj.setAttribute(v.j,v.x = v.def.attr[v.j]);
          }
    
          v.step = 5; // 論理属性を定義(ex.checked)
          for( v.j in v.def.logical ){
            if( v.def.logical[v.j] ){
              v.obj.setAttribute(v.j,v.def.logical[v.j]);
            }
          }
    
          v.step = 6; // style属性の定義
          for( v.j in v.def.style ){
            if( v.j.match(/^\-\-/) ){ // CSS変数
              v.obj.style.setProperty(v.j,v.def.style[v.j]);
            } else {
              v.obj.style[v.j] = v.def.style[v.j];
            }
          }
    
          v.step = 7; // イベントの定義
          for( v.j in v.def.event ){
            v.obj.addEventListener(v.j,v.def.event[v.j],false);
          }
    
          v.step = 8; // 内部文字列(html or text)
          if( v.def.html.length > 0 ){
            v.obj.innerHTML = v.def.html;
          } else {
            // textareaの場合はvalueに、それ以外はinnerTextに内部文字列(text)をセット
            v.obj[v.def.tag.toLowerCase()==='textarea'?'value':'innerText'] = v.def.text;
          }
    
          v.step = 9; // 子要素の追加(parentは指定しない)
          for( v.j=0 ; v.j<v.def.children.length ; v.j++ ){
            v.obj.appendChild(this.createElement(v.def.children[v.j]));
          }
    
          v.step = 10; // 戻り値への登録
          v.rv.push(v.obj);
    
          v.step = 11; // 親要素への追加
          if( parent !== null ){
            v.parent.appendChild(v.obj);
          }
    
          v.step = 12; // メンバとして、また切替画面として登録
          if( v.def.name.length > 0 ){
            this[v.def.name] = v.obj;
            this.screenList[v.def.name] = v.obj;
          }
        }
    
        v.step = 12; // 配列で渡されたら配列で、オブジェクトならオブジェクトを返す
        v.rv = v.isArr ? v.rv : v.rv[0];
        //console.log(v.whois+' normal end.\n',v.rv);
        return v.rv;
    
      } catch(e){
        console.error(v.whois+' abnormal end(step.'+v.step+').',e,v);
        return e;
      }
    }
    /** createTable : オブジェクトの配列からHTMLテーブルを生成
     * @param {tableDef} table - テーブル構造定義オブジェクト。tableDefについてはSpreadDB.js の typedef "schemaDef" 参照
     * @param {Object} opt - オプション
     * @param {HTMLElement|string} [opt.parent=null] - 本関数で親要素へ追加する場合に指定。文字列ならCSSセレクタと解釈
     * @returns {HTMLElement|Error}
     */
    function createTable(table,opt={}) {
      const v = { whois: 'createTable', rv: null};
      dev.start(v.whois, [...arguments]);
      try {
    
        // -------------------------------------------------------------
        dev.step(1);  // 事前準備
        // -------------------------------------------------------------
        dev.step(1.1); // オプション既定値設定
        opt = Object.assign({
          parent: null,
        },opt);
        dev.dump(opt);
    
        dev.step(1.2); // 項目未定義ならオブジェクトのメンバ名で代用
        if( !table.cols ){
          table.cols = [...new Set(table.data.flatMap(Object.keys))]
          .map(x => {return {'name':x,'type':'string'}});
        }
        dev.dump(table.cols);
    
        // -------------------------------------------------------------
        dev.step(2); // thead部の作成
        // -------------------------------------------------------------
        v.thead = [];
        table.cols.forEach(col => {
          v.thead.push({
            tag: 'th',
            text: col.label || col.name,
          });
        });
        v.thead = [{tag:'tr', children:v.thead}];
    
        // -------------------------------------------------------------
        dev.step(3); // tbody部の作成
        // -------------------------------------------------------------
        v.tbody = [];
        table.data.forEach(row => {
          v.tr = [];
          table.cols.forEach(col => {
            v.o = {
              tag: 'td',
              html: row[col.name] === undefined ? ''
              : (col.hasOwnProperty('func')
              ? col.printf(row)
              : String(row[col.name])),
            };
            if( col.type === "number" ){
              v.o.style = {"text-align": "right" };
            }
            v.tr.push(v.o);
          });
          v.tbody.push({tag:'tr',children:v.tr});
        });
    
        dev.end(); // 終了処理
        return createElement({
          tag:'table', children: [
            {tag:'thead', children:v.thead},
            {tag:'tbody', children:v.tbody},
          ],
        },(opt.parent || null));
    
      } catch (e) { dev.error(e); return e; }
    }
    /** devTools: 開発支援関係メソッド集
     * @param {Object} option
     * @param {boolean} option.start=true - 開始・終了メッセージの表示
     * @param {boolean} option.arg=true - 開始時に引数を表示
     * @param {boolean} option.step=false - step毎の進捗ログの出力
     */
    function devTools(option) {
      let opt = Object.assign({ start: true, arg: true, step: false }, option);
      let seq = 0;  // 関数の呼出順
      let stack = []; // 呼出元関数情報のスタック
      return { changeOption: changeOption, check: check, dump: dump, end: end, error: error, start: start, step: step };
    
      /** オプションの変更 */
      function changeOption(option) {
        opt = Object.assign(opt, option);
        console.log(`devTools.changeOption result: ${JSON.stringify(opt)}`);
      }
      /** 実行結果の確認
       * - JSON文字列の場合、オブジェクト化した上でオブジェクトとして比較する
       * @param {Object} arg
       * @param {any} arg.asis - 実行結果
       * @param {any} arg.tobe - 確認すべきポイント(Check Point)。エラーの場合、エラーオブジェクトを渡す
       * @param {string} arg.title='' - テストのタイトル(ex. SpreadDbTest.delete.4)
       * @param {Object} [arg.opt] - isEqualに渡すオプション
       * @returns {boolean} - チェック結果OK:true, NG:false
       */
      function check(arg = {}) {
        /** recursive: 変数の内容を再帰的にチェック
         * @param {any} asis - 結果の値
         * @param {any} tobe - 有るべき値
         * @param {Object} opt - isEqualに渡すオプション
         * @param {number} depth=0 - 階層の深さ
         * @param {string} label - メンバ名または添字
         */
        const recursive = (asis, tobe, opt, depth = 0, label = '') => {
          let rv;
          // JSON文字列はオブジェクト化
          asis = (arg => { try { return JSON.parse(arg) } catch { return arg } })(asis);
          // データ型の判定
          let type = String(Object.prototype.toString.call(tobe).slice(8, -1));
          switch (type) {
            case 'Number': if (Number.isNaN(tobe)) type = 'NaN'; break;
            case 'Function': if (!('prototype' in tobe)) type = 'Arrow'; break;
          }
          let indent = '  '.repeat(depth);
          switch (type) {
            case 'Object':
              msg.push(`${indent}${label.length > 0 ? label + ': ' : ''}{`);
              for (let mn in tobe) {
                rv = !Object.hasOwn(asis, mn) ? false // 該当要素が不在
                  : recursive(asis[mn], tobe[mn], opt, depth + 1, mn);
              }
              msg.push(`${indent}}`);
              break;
            case 'Array':
              msg.push(`${indent}${label.length > 0 ? label + ': ' : ''}[`);
              for (let i = 0; i < tobe.length; i++) {
                rv = (asis[i] === undefined && tobe[i] !== undefined) ? false // 該当要素が不在
                  : recursive(asis[i], tobe[i], opt, depth + 1, String(i));
              }
              msg.push(`${indent}]`);
              break;
            case 'Function': case 'Arrow':
              rv = tobe(asis);  // 合格ならtrue, 不合格ならfalseを返す関数を定義
              msg.push(
                indent + (label.length > 0 ? (label + ': ') : '')
                + (rv ? asis : `[NG] (${tobe.toString()})(${asis}) -> false`)
              );
              break;
            default:
              if (tobe === undefined) {
                rv = true;
              } else {
                rv = isEqual(asis, tobe, opt);
                msg.push(
                  indent + (label.length > 0 ? (label + ': ') : '')
                  + (rv ? asis : `[NG] ToBe=${tobe}, AsIs=${asis}`)
                );
              }
          }
          return rv;
        }
    
        // 主処理
        let msg = [];
        let isOK = true;  // チェックOKならtrue
    
        arg = Object.assign({ msg: '', opt: {} }, arg);
        if (arg.tobe === undefined) {
          // check未指定の場合、チェック省略、結果表示のみ
          msg.push(`===== ${arg.title} Check Result : Not checked`);
        } else {
          // arg.asisとarg.tobeのデータ型が異なる場合、またはrecursiveで不一致が有った場合はエラーと判断
          if (String(Object.prototype.toString.call(arg.asis).slice(8, -1))
            !== String(Object.prototype.toString.call(arg.tobe).slice(8, -1))
            || recursive(arg.asis, arg.tobe, arg.opt) === false
          ) {
            isOK = false;
            msg.unshift(`===== ${arg.title} Check Result : Error`);
          } else {
            msg.unshift(`===== ${arg.title} Check Result : OK`);
          }
        }
    
        // 引数として渡されたmsgおよび結果(JSON)を先頭に追加後、コンソールに表示
        msg = `::::: Verified by devTools.check\n`
          + `===== ${arg.title} Returned Value\n`
          + JSON.stringify(arg.asis, (k, v) => typeof v === 'function' ? v.toString() : v, 2)
          + `\n\n\n${msg.join('\n')}`;
        if (isOK) console.log(msg); else console.error(msg);
        return isOK;
      }
      /** dump: 渡された変数の内容をコンソールに表示
       * - 引数には対象変数を列記。最後の引数が数値だった場合、行番号と看做す
       * @param {any|any[]} arg - 表示する変数および行番号
       * @returns {void}
       */
      function dump() {
        let arg = [...arguments];
        let line = typeof arg[arg.length - 1] === 'number' ? arg.pop() : null;
        const o = stack[stack.length - 1];
        let msg = (line === null ? '' : `l.${line} `) + `${o.label} step.${o.step}`;
        for (let i = 0; i < arg.length; i++) {
          // 対象変数が複数有る場合、Noを追記
          msg += '\n' + (arg.length > 0 ? `${i}: ` : '') + stringify(arg[i]);
        }
        console.log(msg);
      }
      /** end: 正常終了時の呼出元関数情報の抹消＋終了メッセージの表示
       * @param {Object} rt - end実行時に全体に優先させるオプション指定(run time option)
       */
      function end(rt={}) {
        const localOpt = Object.assign(opt,rt);
        const o = stack.pop();
        if (localOpt.start) console.log(`${o.label} normal end.`);
      }
      /** error: 異常終了時の呼出元関数情報の抹消＋終了メッセージの表示 */
      function error(e) {
        const o = stack.pop();
        // 参考 : e.lineNumber, e.columnNumber, e.causeを試したが、いずれもundefined
        e.message = `${o.label} abnormal end at step.${o.step}\n${e.message}`;
        console.error(e.message
          + `\n-- footprint\n${o.footprint}`
          + `\n-- arguments\n${o.arg}`
        );
      }
      /** start: 呼出元関数情報の登録＋開始メッセージの表示
       * @param {string} name - 関数名
       * @param {any[]} arg - start呼出元関数に渡された引数([...arguments]固定)
       * @param {Object} rt - start実行時に全体に優先させるオプション指定(run time option)
       */
      function start(name, arg = [], rt={}) {
        const localOpt = Object.assign(opt,rt);
        const o = {
          class: '',  // nameがクラス名.メソッド名だった場合のクラス名
          name: name,
          seq: seq++,
          step: 0,
          footprint: [],
          arg: [],
        };
        o.sSeq = ('000' + o.seq).slice(-4);
        const caller = stack.length === 0 ? null : stack[stack.length - 1]; // 呼出元
        // nameがクラス名.メソッド名だった場合、クラス名をセット
        if (name.includes('.')) [o.class, o.name] = name.split('.');
        // ラベル作成。呼出元と同じクラスならクラス名は省略
        o.label = `[${o.sSeq}]` + (o.class && (!caller || caller.class !== o.class) ? o.class+'.' : '') + o.name;
        // footprintの作成
        stack.forEach(x => o.footprint.push(`${x.label}.${x.step}`));
        o.footprint = o.footprint.length === 0 ? '(root)' : o.footprint.join(' > ');
        // 引数情報の作成
        if (arg.length === 0) {
          o.arg = '(void)';
        } else {
          for (let i = 0; i < arg.length; i++) o.arg[i] = stringify(arg[i]);
          o.arg = o.arg.join('\n');
        }
        // 作成した呼出元関数情報を保存
        stack.push(o);
    
        if (localOpt.start) {  // 開始メッセージの表示指定が有った場合
          console.log(`${o.label} start.\n-- footprint\n${o.footprint}`
            + (localOpt.arg ? `\n-- arguments\n${o.arg}` : ''));
        }
      }
      /** step: 呼出元関数の進捗状況の登録＋メッセージの表示 */
      function step(step, msg = '') {
        const o = stack[stack.length - 1];
        o.step = step;
        if (opt.step) console.log(`${o.label} step.${o.step} ${msg}`);
      }
      /** stringify: 変数の内容をラベル＋データ型＋値の文字列として出力
       * @param {any} arg - 文字列化する変数
       * @returns {string}
       */
      function stringify(arg) {
        /** recursive: 変数の内容を再帰的にメッセージ化
         * @param {any} arg - 内容を表示する変数
         * @param {number} depth=0 - 階層の深さ
         * @param {string} label - メンバ名または添字
         */
        const recursive = (arg, depth = 0, label = '') => {
          // データ型の判定
          let type = String(Object.prototype.toString.call(arg).slice(8, -1));
          switch (type) {
            case 'Number': if (Number.isNaN(arg)) type = 'NaN'; break;
            case 'Function': if (!('prototype' in arg)) type = 'Arrow'; break;
          }
          // ラベル＋データ型＋値の出力
          let indent = '  '.repeat(depth);
          switch (type) {
            case 'Object':
              msg.push(`${indent}${label.length > 0 ? label + ': ' : ''}{`);
              for (let mn in arg) recursive(arg[mn], depth + 1, mn);
              msg.push(`${indent}}`);
              break;
            case 'Array':
              msg.push(`${indent}${label.length > 0 ? label + ': ' : ''}[`);
              for (let i = 0; i < arg.length; i++) recursive(arg[i], depth + 1, String(i));
              msg.push(`${indent}]`);
              break;
            default:
              let val = typeof arg === 'function' ? `"${arg.toString()}"` : (typeof arg === 'string' ? `"${arg}"` : arg);
              // Class Sheetのメソッドのように、toStringが効かないnative codeは出力しない
              if (typeof val !== 'string' || val.indexOf('[native code]') < 0) {
                msg.push(`${indent}${label.length > 0 ? label + ': ' : ''}${val}(${type})`);
              }
          }
        }
        const msg = [];
        recursive(arg);
        return msg.join('\n');
      }
    }
    /** LocalDb: IndexedDBを保存先とするブラウザ内RDB
     * @param {Object} arg
     * @param {schemaDef} arg.schema={} - DB構造定義オブジェクト
     * @returns {Object} 使用可能なメソッドのオブジェクト
     */
    function LocalDb(arg) {
      const pv = { whois: 'LocalDb', rv: null,
        schema: arg.schema,
        idb: null,          // IndexedDB
        dbName: 'LocalDb',  // IndexedDBの名称
        storeName: 'JSON',  // IndexedDBのストア名
        rdb: new alasql.Database(), // alasql
      };
    
      /** execSQL: alasqlでSQLを実行
       * @param {string} sql
       * @param {Array[]} arg - alasqlの第二引数
       * @returns {Object[]}
       */
      function execSQL(sql,arg=null) {
        return arg === null ? pv.rdb.exec(sql) : pv.rdb.exec(sql,arg);
      }
    
      /** hasTable: RDB(alasql)内にテーブルを持っているか確認
       * @param {string} tableName
       * @returns {boolean}
       */
      function hasTable(tableName) {
        return tableName in pv.rdb.tables;
      }
    
      dev.start(pv.whois, [...arguments]);
      try {
    
        dev.step(3);  // AlaSQLカスタム関数の用意
        if( pv.schema.hasOwnProperty('custom') ){
          Object.keys(pv.schema.custom).forEach(x => alasql.fn[x] = pv.schema.custom[x]);
        }
    
        dev.end(); // 終了処理
        return {
          'exec': execSQL,
          //'load': loadRDB,
          //'save': saveRDB,
          //'import': importJSON,
          //'export': exportJSON,
          'hasTable': hasTable,
        };
    
      } catch (e) { dev.error(e); return e; }
    }
    /** 日時を指定形式の文字列にして返す
     * @param {string|Date} arg - 変換元の日時
     * @param {string} [format='yyyy-MM-ddThh:mm:ss.nnnZ'] - 日時を指定する文字列。年:y,月:M,日:d,時:h,分:m,秒:s,ミリ秒:n,タイムゾーン:Z
     * @returns {string} 指定形式に変換された文字列。無効な日付なら長さ0の文字列
     *
     * @example
     * ```
     * "1965/9/5"[yy/MM/dd hh:mm:ss.nnn] ⇒ "65/09/05 00:00:00.000"
     * "1965/9/5"[yyyy-MM-dd] ⇒ "1965-09-05"
     * "1965/9/5"[hh:mm] ⇒ "00:00"
     * "1977-03-04"[yy/MM/dd hh:mm:ss.nnn] ⇒ "77/03/04 09:00:00.000"
     * "1977-03-04"[yyyy-MM-dd] ⇒ "1977-03-04"
     * "1977-03-04"[hh:mm] ⇒ "09:00"
     * 1688189258262[yy/MM/dd hh:mm:ss.nnn] ⇒ "23/07/01 14:27:38.262"
     * 1688189258262[yyyy-MM-dd] ⇒ "2023-07-01"
     * 1688189258262[hh:mm] ⇒ "14:27"
     * "Sat Jul 01 2023 14:16:30 GMT+0900"[yy/MM/dd hh:mm:ss.nnn] ⇒ "23/07/01 14:16:30.000"
     * "Sat Jul 01 2023 14:16:30 GMT+0900"[yyyy-MM-dd] ⇒ "2023-07-01"
     * "Sat Jul 01 2023 14:16:30 GMT+0900"[hh:mm] ⇒ "14:16"
     * "12:34"[yy/MM/dd hh:mm:ss.nnn] ⇒ ""
     * "12:34"[yyyy-MM-dd] ⇒ ""
     * "12:34"[hh:mm] ⇒ ""
     * ```
     */
    function toLocale(arg,format='yyyy-MM-ddThh:mm:ss.nnnZ'){
      const v = {rv:format};
      try {
    
        let dObj = whichType(arg,'Date') ? arg : new Date(arg);
        //dObj = String(Object.prototype.toString.call(arg).slice(8,-1)) !== 'Date' ? arg : new Date(arg);
    
        v.step = 1; // 無効な日付なら空文字列を返して終了
        if( isNaN(dObj.getTime()) ) return '';
    
        v.local = { // 地方時ベース
          y: dObj.getFullYear(),
          M: dObj.getMonth()+1,
          d: dObj.getDate(),
          h: dObj.getHours(),
          m: dObj.getMinutes(),
          s: dObj.getSeconds(),
          n: dObj.getMilliseconds(),
          Z: Math.abs(dObj.getTimezoneOffset())
        }
        // タイムゾーン文字列の作成
        v.local.Z = v.local.Z === 0 ? 'Z'
        : ((dObj.getTimezoneOffset() < 0 ? '+' : '-')
        + ('0' + Math.floor(v.local.Z / 60)).slice(-2)
        + ':' + ('0' + (v.local.Z % 60)).slice(-2));
    
        v.step = 2; // 日付文字列作成
        for( v.x in v.local ){
          v.m = v.rv.match(new RegExp(v.x+'+'));
          if( v.m ){
            v.str = v.m[0].length > 1
              ? ('000'+v.local[v.x]).slice(-v.m[0].length)
              : String(v.local[v.x]);
            v.rv = v.rv.replace(v.m[0],v.str);
          }
        }
    
        v.step = 3; // 終了処理
        return v.rv;
    
      } catch(e){
        console.error(e,v);
        return e;
      }
    }
    /** 変数の型を判定
     *
     * - 引数"is"が指定された場合、判定対象が"is"と等しいかの真偽値を返す。
     *
     * @param {any} arg - 判定対象の変数
     * @param {string} [is] - 想定される型(型名の大文字小文字は意識不要)
     * @returns {string|boolean} - 型の名前。is指定有りなら判定対象が想定型かの真偽値
     *
     * @example
     * ```
     * let a = 10;
     * whichType(a);  // 'Number'
     * whichType(a,'string'); // false
     * ```
     *
     * <b>確認済戻り値一覧</b>
     *
     * オブジェクトは型名が返るので、限定列挙は困難。以下は確認済みの戻り値のみ記載。
     *
     * | 型名 | 戻り値 | 備考 |
     * | :-- | :-- | :-- |
     * | 文字列 | String |  |
     * | 数値 | Number |  |
     * | NaN | NaN |  |
     * | 長整数 | BigInt |  |
     * | 論理値 | Boolean |  |
     * | シンボル | Symbol |  |
     * | undefined | Undefined | 先頭大文字 |
     * | Null | Null |  |
     * | オブジェクト | Object |  |
     * | 配列 | Array |  |
     * | 関数 | Function |  |
     * | アロー関数 | Arrow |  |
     * | エラー | Error | RangeError等も'Error' |
     * | Date型 | Date |  |
     * | Promise型 | Promise |  |
     *
     * - Qiita [JavaScriptの型などの判定いろいろ](https://qiita.com/amamamaou/items/ef0b797156b324bb4ef3)
     *
     */
    function whichType(arg,is){
      let rv = String(Object.prototype.toString.call(arg).slice(8,-1));
      switch(rv){
        case 'Number': if(Number.isNaN(arg)) rv = 'NaN'; break;
        case 'Function': if(!('prototype' in arg)) rv = 'Arrow'; break;
      }
      if( typeof is === 'string' ){
        return rv.toLowerCase() === is.toLowerCase();
      } else {
        return rv;
      }
    }
    const cf = {
      schema: { // データ構造については SpreadDB.js の typedef "schemaDef" 参照
        dbName: 'taxation',
        tables: [{  // files: Google Driveのカレントフォルダに存在するファイル一覧
          // 移動したファイルはリストアップ対象外(リストに残っていたら削除)
          name: 'files',
          primaryKey: 'id',
          cols: [
            {name:'id',type:'string',note:'ファイルのID'},
            {name:'name',type:'string',note:'ファイル(フォルダ)名'},
            {name:'mime',type:'string',note:'MIMEタイプ。例:"application/pdf","application/vnd.google-apps.spreadsheet"'},
            {name:'desc',type:'string',note:'ファイルの説明。「詳細を表示>詳細タグ>ファイルの詳細>説明」に設定された文字列'},
            {name:'url',type:'string',note:'ファイルのURL。File.getDownloadUrl()ではなくFile.getUrl()'},
            {name:'viewers',type:'string',note:'閲覧権限を持つアカウント'},
            {name:'editors',type:'string',note:'編集権限を持つアカウント'},
            {name:'created',type:'string',note:'作成日時。ISO8601拡張形式'},
            {name:'updated',type:'string',note:'更新日時。ISO8601拡張形式'},
          ],
          initial: () => getFileList(), // ファイル一覧作成
          /*{  // YFP関係の結合処理実行後、ファイル一覧を返す
            concatYFP().then(()=>{return getFileList()});
          },*/
        },{ // 記入用
          name: '記入用',
          primaryKey: 'id',
          cols: [
            {name:'id',type:'string',note:'ファイルのID'},
            {name:'name',type:'string',note:'ファイル(フォルダ)名'},  // シート上はファイルへのリンクを張る
            {name:'link',type:'string',note:'プレビュー用URL'},
            {name:'isExist',type:'boolean',note:'GD上の状態(存否)'},
            {name:'type',type:'string',note:'証憑としての分類。report.html上の掲載するdiv[data-type]'},
            {name:'date',type:'string',note:'取引日。電子証憑・参考等、report.html上取引日の表示が必要な場合設定'},
            {name:'label',type:'string',note:'摘要(電子証憑)、行き先(交通費)、資料名(参考)'},
            {name:'price',label:'価格',type:'string',printf:o=>Number(o.price).toLocaleString()},
            {name:'payby',label:'支払方法',type:'string',note:'役員借入金 or AMEX'},
            {name:'note',label:'備考',type:'string',note:'特記事項の本文(MD)、他はpdf上の頁指定等'},
          ],
          initial: () => [],
        },{ // 交通費
          name: '交通費',
          cols: [
            {name:'date',label:'日付',type:'string'},
            {name:'destination',label:'行先',type:'string'},
            {name:'label',label:'目的',type:'string'},
            {name:'route',label:'経路',type:'string'},
            {name:'number',label:'人数',type:'number'},
            {name:'price',label:'金額',type:'number',printf:o=>Number(o.price).toLocaleString()},
            {name:'note',label:'備考',type:'string'},
          ],
          initial: () => [],
        }],
        custom: { // AlaSQLのカスタム関数(以下は使用例)
          // alasql.fn.exclude = cf.custom.exclude;
          // alasql('select * from `files` where exclude(`name`)');
    
          // exclude: ファイル一覧で処理か判定。引数：ファイル名、戻り値：trueなら処理対象外
          exclude: fn => /^(20\d{2})(\d{2})(\d{2})_400_00[0|3]\.pdf$/.test(fn),
          // identifyType: ファイルの自動判別可否または処理対象外かを判定
          identifyType: fileName => {
            if( !fileName ) return '不明';
            // 処理対象外のファイル
            for( let rex of cf.ignore ) if( rex.test(fileName) ) return '対象外';
            // 自動判別可能なら該当するメンバ名を、判別不可能なら「不明」を返す
            for (const [key, value] of Object.entries(cf.classDef))
              if (value.rex && value.rex.test(fileName)) return key;
            return '不明';
          },
        },
      },
      YFPrex: { // YFP関係PDFファイル名の正規表現
        '顧問報酬': /^(20\d{2})(\d{2})(\d{2})_400_000\.pdf$/,
        '記帳代行': /^(20\d{2})(\d{2})(\d{2})_400_003\.pdf$/,
        '結合済': /^YFP(\d{4})(\d{2})\.pdf$/,
      },
      /**
       * @typedef {Object} classDef - report.html上の証憑分類に関する定義(classify Definition)
       * @param {number} colnum - 一行当たりの項目数。0:テーブル、>=1:箇条書き。数字は項目数/行
       * @param {RegExp} rex - ファイル名を基にdata-typeを判定する正規表現。特定不能型はnull
       * -- 以下、箇条書きの場合のみ設定される項目
       * @param {Arrow} printf - 箇条書きの場合、aタグを含むラベルHTML文字列を作成する関数。
       *   o:行オブジェクト、m:o.name.match(rex)の結果。戻り値はHTML文字列。
       * -- 以下、テーブルの場合のみ設定される項目
       * @param {Object[]} cols - 項目定義
       * @param {string} cols.name - 行オブジェクト内のメンバ名
       * @param {string} [cols.label] - テーブルに表示する項目名。省略時はnameを流用
       * @param {string} cols.type='string' - データ型。string/number/boolean
       * @param {Function} [cols.printf] - 桁区切りやリンク等のlabel生成関数
       *   引数はo:「記入用」行オブジェクト・m:rexの結果、戻り値はHTML文字列
       * @param {Function} cols.orderBy - ソートキー生成関数
       */
      classDef: {
        // ----- 金融関係 ----------
        '通帳': {
          colnum: 4,  // 箇条書き型(4列/行)
          rex: /^([A-Z]{4})(\d{2})\.pdf$/,
          printf: (o,m) => `${m[1]} No.${cf.getA(o.id,m[2])}`,
          orderBy: (o,m) => m[1] + m[2],  // 銀行名＋通帳番号
        },
        '返済明細': { // 記入項目：①資料名(label),②入手日(date)
          colnum: 1,  // 箇条書き型(1件1行)
          rex: null,  // 特定不能型はマニュアルで型を特定、必要事項を記入するようにする
          printf: o => cf.getA(o.id,o.label) + (o.date?`(${o.date})`:''),
          orderBy: o => o.date,
        },
        'AMEX': {
          colnum: 6,  // 箇条書き型(月次型)
          rex: /^(20\d{2})(\d{2})\.pdf$/,
          printf: (o,m) => cf.getA(o.id,`${m[1]}/${m[2]}`),
          orderBy: (o,m) => m[1] + m[2],  // 年＋月
        },
        // ----- レントロール ----------
        '恵比寿': {
          colnum: 6,  // 箇条書き型(月次型)
          rex: /^EF(20\d{2})(\d{2})\.pdf$/,
          printf: (o,m) => cf.getA(o.id,`${m[1]}/${m[2]}`),
          orderBy: (o,m) => m[1] + m[2],  // 年＋月
        },
        '上池袋': {
          colnum: 6,  // 箇条書き型(月次型)
          rex: /^CK(20\d{2})(\d{2})\.pdf$/,
          printf: (o,m) => cf.getA(o.id,`${m[1]}/${m[2]}`),
          orderBy: (o,m) => m[1] + m[2],  // 年＋月
        },
        '羽沢': {
          colnum: 6,  // 箇条書き型(月次型)
          rex: /^HS(20\d{2})(\d{2})\.pdf$/,
          printf: (o,m) => cf.getA(o.id,`${m[1]}/${m[2]}`),
          orderBy: (o,m) => m[1] + m[2],  // 年＋月
        },
        // ----- 証憑類 ----------
        '健保・年金': {
          colnum: 6,  // 箇条書き型(月次型)
          rex: /^pension(20\d{2})(\d{2})\.pdf$/,
          printf: (o,m) => cf.getA(o.id,`${m[1]}/${m[2]}`),
          orderBy: (o,m) => m[1] + m[2],  // 年＋月
        },
        '確証貼付ノート': {
          colnum: 10,  // 箇条書き型(10列/行)
          rex: /^note(20\d{2})(\d{2})\.pdf$/,
          printf: (o,m) => 'p.' + cf.getA(o.id,m[2]),
          orderBy: (o,m) => m[1] + m[2],  // 年＋月
        },
        'YFP': {
          colnum: 6,  // 箇条書き型(月次型)
          rex: /^YFP(20\d{2})(\d{2})\.pdf$/,
          printf: (o,m) => cf.getA(o.id,`${m[1]}/${m[2]}`),
          orderBy: (o,m) => m[1] + m[2],  // 年＋月
        },
        '電子証憑': {
          colnum: 0,  // テーブル型
          rex: null,  // 特定不能型はマニュアルで型を特定、必要事項を記入するようにする
          cols: [
            {name:'date',label:'取引日',type:'string'},
            {name:'label',label:'摘要',type:'string',printf:o=>cf.getA(o.id,o.label)},
            {name:'price',label:'価格',type:'number',printf:o=>Number(o.price).toLocaleString()},
            {name:'payby',label:'支払',type:'string'},
            {name:'note',label:'備考',type:'string'},
          ],
          orderBy: o => o.date,
        },
        // ----- その他 ----------
        '交通費': {
          colnum: 0,  // テーブル型
          rex: null,  // 特定不能型はマニュアルで型を特定、必要事項を記入するようにする
          cols: [
            {name:'date',label:'日付',type:'string'},
            {name:'label',label:'行先',type:'string'},
            {name:'route',label:'経路',type:'string'},
            {name:'number',label:'人数',type:'number'},
            {name:'price',label:'金額',type:'number',printf:o=>Number(o.price).toLocaleString()},
            {name:'payby',label:'支払',type:'string',default:'役員借入金'},
            {name:'note',label:'備考',type:'string'},
          ],
          orderBy: o => o.date,
        },
        '参考資料': { // 記入項目：①資料名(label),②入手日(date)
          colnum: 1,  // 箇条書き型(1件1行)
          rex: null,  // 特定不能型はマニュアルで型を特定、必要事項を記入するようにする
          printf: o => (o.date?`${o.date} : `:'') + cf.getA(o.id,o.label),
          orderBy: o => o.date,
        },
        '特記事項': { // 記入項目：①タイトル(label),②内容(note),③記入日(date)
          colnum: 1,  // 箇条書き型(1件1行)
          rex: null,  // 特定不能型はマニュアルで型を特定、必要事項を記入するようにする
          printf: o => `<div>
            <span style="font-size: 0.8rem;font-weight: normal;">${o.date+' : '}</span>
            <span>${o.label}</span><br>
            <pre style="font-size: 0.8rem;font-weight: normal;margin-left:2rem;">${o.note}</pre>
          </div>`,
          //printf: o => (o.date?`<li>${o.date}`:'<li>')  // 記入日
          //+ `<span style="margin-left:1rem;font-size:1.4rem">${o.label}</span><br>${o.note}</li>`,
          orderBy: o => o.date,
        },
        '不明': {
          colnum: 1,  // 箇条書き型(1件1行)
          rex: null,
          printf: o => cf.getA(o.id,o.name),
          orderBy: o => o.name,
        },
      },
      ignore: [ // {RegExp[]} 存在しても処理対象外となるファイル名の正規表現集
        /^(?!.*\.pdf$).*/,  // 末尾が".pdf"ではない
        /^(20\d{2})(\d{2})(\d{2})_400_00[0|3]\.pdf$/, // 結合前のYFP顧問報酬(0),記帳代行(3)
      ],
      // ファイルプレビュー用のURL
      previewURL: "https://drive.google.com/file/d/$1/preview",
      // getA: ファイルIDとラベルからpreviewモードで当該ファイルを開くURLを返す
      getA: (id,label) => `<a href="https://drive.google.com/file/d/${id}/preview" target="_blank">${label}</a>`,
    }
  </script>
</head>
<body>
  <p id="today" style="text-align: right;padding-right: 2rem;"></p>

  <div class="navi">

    <div id="notFilled"><h1>未分類証憑</h1>
      <p>以下の証憑は「記入用」シートのtype欄が未記入です。<br>
      記入後、改めて「提出用HTML出力」を行ってください。</p>
      <div data-type="不明"></div>
    </div>

    <div><h1>金融関係</h1>
      <div><h2>銀行通帳</h2>
        <div data-type="通帳"></div>
      </div>
      <div><h2>ローン関係</h2>
        <div data-type="返済明細"></div>
      </div>
      <div><h2>クレジットカード利用明細</h2>
        <div data-type="AMEX"></div>
      </div>
    </div>

    <div><h1>レントロール</h1>
      <div><h2>恵比寿フェリシタ</h2>
        <div data-type="恵比寿"></div>
      </div>
      <div><h2>クレセント上池袋</h2>
        <div data-type="上池袋"></div>
      </div>
      <div><h2>羽沢眞和マンション</h2>
        <div data-type="羽沢"></div>
      </div>
    </div>

    <div><h1>証憑類</h1>
      <div><h2>健保・年金、確定拠出年金</h2>
        <div data-type="健保・年金"></div>
      </div>
      <div><h2>確証貼付ノート</h2>
        <div data-type="確証貼付ノート"></div>
      </div>
      <div><h2>税理士(YFP)</h2>
        <div data-type="YFP"></div>
      </div>
      <div><h2>電子証憑</h2>
        <div data-type="電子証憑"></div>
      </div>
    </div>

    <div><h1>その他</h1>
      <div><h2>交通費</h2>
        <div data-type="交通費"></div>
      </div>
      <div><h2>参考資料</h2>
        <div data-type="参考資料"></div>
      </div>
      <div><h2>特記事項</h2>
        <ol data-type="特記事項"></ol>
      </div>
    </div>
  </div>

</body>
<script type="text/javascript">
  /* =======================================================
  [report.js]
    提出用HTML(report.html)のJavaScript部分。
    build.shでreport.htmlに組み込み、「証憑yyyy」のGASにコピー
  ======================================================= */
  
  const dev = devTools();
  const db = LocalDb(cf);
  
  const ctrlList = element => {
    // 現在の表示/非表示を保存
    const d = element.target.parentElement.querySelector('[data-type]').style.display;
    // ナビ領域のリストは隠蔽
    document.querySelectorAll('[data-type]').forEach(o => o.style.display = 'none');
    // クリックされたナビメニューの下の明細を表示
    element.target.parentElement.querySelector('[data-type]').style.display = d === 'none' ? '' : 'none';
  }
  
  window.addEventListener('DOMContentLoaded', () => {
    const v = { whois: 'DOMContentLoaded', rv: null};
    dev.start(v.whois);
    try {
  
      // -------------------------------------------------------------
      dev.step(1); // 前準備
      // -------------------------------------------------------------
      dev.step(1.1);  // 作業日日付の設定
      document.getElementById('today').innerText = toLocale(data.created,'yyyy/MM/dd現在');
      dev.step(1.2);  // シートから出力されたdataのRDBへの保存
      data.tables.forEach(table => {
        v.sql = `drop table if exists \`${table.name}\`;`
        + `create table \`${table.name}\`;`
        + `insert into \`${table.name}\` select * from ?;`;
        v.r = db.exec(v.sql,[table.data]);
      });
      // ナビ領域のリストは隠蔽
      document.querySelectorAll('[data-type]').forEach(o => o.style.display = 'none');
  
      // -------------------------------------------------------------
      dev.step(2);  // masterテーブル作成
      // -------------------------------------------------------------
      v.sql =
      // PDFファイルの存在を前提とする電子証憑・参考・返済明細でisExist=falseは予め削除。
      // 但し特記事項は元々ファイルの存在を前提としないので、削除しない。
      'delete from `記入用`'
      + ' where `type`<>"特記事項" and `isExist`<>"TRUE";'
      // masterテーブルを初期化
      + 'drop table if exists `master`;'
      + 'create table `master`;'
      // files,記入用テーブルからmasterを作成
      + 'insert into `master` select'
      + ' `files`.`id` as `id`'
      + ', `files`.`name` as `name`'
      + ', case'  // 「記入用」シート未記載(=自動判別可能PDF)にtypeを設定
      +   ' when `記入用`.`type` is null'
      +   ' then identifyType(`files`.`name`)'
      +   ' else `記入用`.`type`'
      + ' end as `type`'
      + ', `記入用`.`date` as `date`'
      + ', `記入用`.`label` as `label`'
      + ', `記入用`.`price` as `price`'
      + ', `記入用`.`payby` as `payby`'
      + ', `記入用`.`note` as `note`'
      + ' from `files` full outer join `記入用`'
      + ' on `files`.`id`=`記入用`.`id`;'
      // typeが空欄(=記入用シートでの記入漏れ)の場合「不明」を設定
      + 'update `master` set `type`="不明" where `type`="";'
      // type=対象外はmasterから削除
      + 'delete from `master` where `type`="対象外";'
      // 交通費をmasterテーブルに追加
      + 'insert into `master` select "交通費" as type, * from `交通費` order by date;';
      v.r = db.exec(v.sql);
      if( v.r instanceof Error ) throw v.r;
  
      // -------------------------------------------------------------
      dev.step(3);  // リンク(a href)文字列作成用関数pfMapの定義
      // リンクはcf.classDef(証憑分類に関する定義)のprintf関数に基づき生成。
      // printfにmasterの行オブジェクトを渡し、{項目名:リンク用HTML文字列}を取得、
      // これをmasterの行オブジェクトに上書きする。
      // -------------------------------------------------------------
      dev.step(3.1);  // pfMap {Object.<string,Function>}
      // リンクを含む表示用HTML文字列生成関数。メンバ名は記事(data-type)名。
      // 引数：{Object} o - masterテーブルの行オブジェクト
      // 戻り値：{
      //   項目名 : HTML文字列,
      //   sortKey : 記事の内容作成時、並び順の基準となる文字列
      // }
      v.pfMap = {}; // {type名:当該typeに適用する関数}
      for( [v.key, v.obj] of Object.entries(cf.classDef) ){
        v.pfMap[v.key] = new Function('o',(
          v.obj.colnum === 0 ? /* テーブル型の記事 */ `
            const rv = {};
            cf.classDef['${v.key}'].cols.forEach(col => {
              if(col.printf) rv[col.name]=col.printf(o);
            });
            rv.sortKey = cf.classDef['${v.key}'].orderBy(o);
            return rv;
          ` : /* 箇条書き型の記事 */ (
            cf.classDef[v.key].rex instanceof RegExp
            ? /* ファイル名からtypeを自動判別可能な場合 */ `
              const m = o.name.match(cf.classDef['${v.key}'].rex);
              return {
                label: cf.classDef['${v.key}'].printf(o,m),
                sortKey: cf.classDef['${v.key}'].orderBy(o,m),
              };
            ` : /* ファイル名からtypeを自動判別不能な場合 */ `
              return {
                label:cf.classDef['${v.key}'].printf(o),
                sortKey:cf.classDef['${v.key}'].orderBy(o),
              };
            `
          )
        ));
      }
      dev.dump(v.pfMap);
  
      dev.step(3.2);  // master上にリンク文字列セット＋sortKey設定
      v.master = db.exec('select * from `master`;')
      if( v.master instanceof Error ) throw v.master;
      v.master.forEach(o => {
        dev.dump(o);
        o = Object.assign(o,v.pfMap[o.type](o));
      });
      v.sql = 'delete from `master`;insert into `master` select * from ?;';
      v.r = db.exec(v.sql,[v.master]);
      if( v.r instanceof Error ) throw v.r;
  
  
      // -------------------------------------------------------------
      dev.step(4);  // 記事(data-type)毎に内容を作成
      // -------------------------------------------------------------
      document.querySelectorAll('[data-type]').forEach(node => {
  
        dev.step(4.1);  // データの抽出
        v.type = node.getAttribute('data-type');
        v.sql = 'select * from `master`'
        + ` where \`type\`="${v.type}"`
        + ` order by \`sortKey\`;`;
        v.list = db.exec(v.sql);
        if( v.list instanceof Error ) throw v.list;
        dev.dump(v.type,v.list);
  
        dev.step(4.2);  // 内容の追加
        if( cf.classDef[v.type].colnum > 0 ){ // 箇条書き型
          dev.step(4.2);  // styleの指定
          node.style.gridTemplateColumns = `repeat(${cf.classDef[v.type].colnum}, 1fr)`;
          v.list.forEach(item => {
            node.appendChild(createElement({html:item.label}));
          });
        } else {  // テーブル型
          v.r = createTable({
            name: v.type,
            cols: cf.classDef[v.type].cols,
            data: v.list,
          },{parent:node});
          if( v.r instanceof Error ) throw v.r;
        }
  
        dev.step(4.3);  // 開閉制御
        node.parentElement.addEventListener('click',ctrlList);
      });
  
      // -------------------------------------------------------------
      dev.step(5);  // 未分類証憑が無ければ記事を隠蔽
      // -------------------------------------------------------------
      if( db.exec('select count(*) as num from `master` where `type`="不明"')[0].num === 0 ){
        document.getElementById('notFilled').style.display = 'none';
      }
  
    } catch (e) { dev.error(e); return e; }
  });
</script>
</html>