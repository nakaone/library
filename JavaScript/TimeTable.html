<!DOCTYPE html><html lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <meta http-equiv="Content-Script-Type" content="text/javascript">
  <title>timetable</title>
  <link rel="stylesheet" href="../CSS/szDefault.css" />
  <style type="text/css" class="core">
    .right {text-align: right;}
    .image, .timetable {
      max-width: 100%;
      overflow-x: scroll;
    }
    .timetable, .timetable div {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      display: grid;
      --color: #ccc;
      --boldLine : solid 2px var(--color);
      --thinLine : dotted 1px var(--color);
    }
    .timetable span {
      padding-left: 0.3rem;
      white-space: nowrap;
    }
    /*.timetable .controller {}*/
    .timetable .main {
      grid-template-rows: 2rem 1fr;
      grid-template-columns: 1fr;
    }
    .timetable .main .header {
      grid-row: 1/2;
      grid-column: 1/2;
      grid-template-columns: repeat(3, 1fr);
      border: var(--boldLine);
    }
    .timetable .main .header div:nth-child(2n) {
      background-color: var(--color);
    }
    .timetable .main .timeline {
      grid-row: 2/3;
      grid-column: 1/2;
      grid-template-columns: repeat(12, 1fr);
      border-bottom: var(--boldLine);
    }
    .timetable .main .timeline div {
      min-width: 1rem;
      min-height: 1rem;
    }
    .timetable .main .timeline div:nth-child(2n+1) {
      border-left: var(--boldLine);
    }
    .timetable .main .timeline div:nth-child(2n) {
      border-left: var(--thinLine);
    }
    .timetable .main .timeline div:last-child {
      border-right: var(--boldLine);
    }
    .timetable .main .tasks {
      grid-row: 2/3;
      grid-column: 1/2;
      z-index: 1;
    }
    .timetable .main .tasks > div {
      max-height: 1.6rem;
      grid-column: 1/37;
      margin-bottom: 0.5rem;
    }
    .timetable .main .tasks > div:first-child {
      margin-top: 0.5rem;
    }
    .timetable .main .tasks .bar {
      grid-template-columns: repeat(36, 1fr);
    }
    .timetable .main .tasks .bar [name="1.1"]{
      grid-column: 4/12;
      background-color: var(--color);
    }
    .timetable .main .tasks .bar [name="1.2"]{
      grid-column: 15/20;
      background-color: var(--color);
    }

    .timetable .dialog {
      margin-top: 1rem;
      display: none;
    }
    .timetable .dialog div {
      padding: 0.5rem;
    }
    .timetable .dialog .button {
      grid-template-columns: 1fr 1fr 1fr;
    }
    .timetable .dialog .button button {
      width: auto;
    }
    .timetable .dialog input[type="text"] {
      width: 10rem;
    }
    .timetable .dialog > div {
      grid-template-columns: 5rem 1fr;
    }
  </style>
</head>
<body>
  <div><h1>タイムテーブル</h1>
    <div class="timetable" name="tt01">
      <div class="controller"></div>
      <div class="main">
        <div class="header"></div>
        <div class="timeline"></div>
        <div class="tasks"></div>
      </div>
      <div class="dialog">
        <div class="button">
          <button name="appendChild">子タスクの追加</button>
          <button name="deleteTask">タスクの削除</button>
          <button name="closeDialog">閉じる</button>
        </div>
        <div name="id">
          <div>ID</div>
          <div class="val"></div>
        </div>
        <div name="name">
          <div>タスク名</div>
          <input type="text" class="val" />
        </div>
        <div name="summary">
          <div>作業概要</div>
          <textarea class="val"></textarea>
        </div>
        <div name="pending">
          <div>要検討事項</div>
          <textarea class="val"></textarea>
        </div>
        <div name="note">
          <div>備考</div>
          <textarea class="val"></textarea>
        </div>

        <div name="start">
          <div>開始日時</div>
          <input type="text" class="val" />
        </div>
        <div name="end">
          <div>終了日時</div>
          <input type="text" class="val" />
        </div>
        <div name="ideal">
          <div>所要人数</div>
          <input type="text" class="val" />
        </div>
        <div name="fixed">
          <div>担当者<br><sub>(','区切り)</sub></div>
          <textarea class="val"></textarea>
        </div>
        <div name="resources">
          <div>所要資材</div>
          <table>
            <thead>
              <tr>
                <th>名称</th>
                <th>数量</th>
                <th>単位</th>
                <th>調達方法</th>
                <th>予算</th>
                <th>備考</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div name="location">
          <div>作業場所</div>
          <input type="text" class="val" />
        </div>
        <div name="output">
          <div>成果物</div>
          <input type="text" class="val" />
        </div>
      </div>
    </div>

    <!--div class="timetable" name="tt02">
      <div class="controller">コントローラ</div>
      <div class="main">
        <div class="header">
          <div><span>8:00</span></div>
          <div><span>9:00</span></div>
          <div><span>10:00</span></div>
        </div>
        <div class="timeline">
          <div></div><div></div><div></div><div></div>
          <div></div><div></div><div></div><div></div>
          <div></div><div></div><div></div><div></div>
        </div>
        <div class="tasks">
          <div class="label"><span>午前の部</span></div>
          <div class="bar"><span name="1.1">受付</span></div>
          <div class="bar"><span name="1.2">挨拶</span></div>
        </div>
      </div>
      <div class="dialog">ダイアログ</div>
    </div-->

  </div>

<!--================================================
  外部スクリプト
<script src="../lib/jsLib.js"></script>
================================================-->

<!--================================================
  timetable コアスクリプト
================================================-->
<script type="text/javascript" class="core">

/**
 * @typedef {Object} Member - タスクの達成に必要な人的資源
 * @prop {number} ideal - 理想的な担当者数
 * @prop {string[]} fixed - 担当者名の配列
 * 
 * @typedef {Object} Resource - タスク達成に必要な資源
 * @prop {string} name - 資源の名前。ビニール紐、等
 * @prop {number} quantity - 必要な数量
 * @prop {string} unit - 単位名。円、個、等
 * @prop {string} procurement - 調達方法。学校、○○さん持参、購入、等
 * @prop {number} budget - 必要な予算額(見込)
 * @prop {string} note - 備考
 * 
 * 
 * @typedef {Object} Task - タスクの定義
 * @prop {string} id - 親ID＋自No。プログラム内部で自動採番
 * @prop {string} name - セクションまたはタスクの名称
 * @prop {string} [summary] - タスクの概要
 * @prop {string} [pending] - 要検討事項
 * @prop {string} [note] - 備考
 * @prop {Task[]} [children] - 子タスクの配列。指定した場合、以下は指定不可
 * 
 * @prop {Date} start - 開始日時
 * @prop {Date} end - 終了日時
 * @prop {string} location - 集合場所、作業場所
 * @prop {Member} members - タスクの担当者(人的資源)
 * @prop {Resource[]} resources - タスクの達成に必要な物的資源
 * @prop {string} output - タスクの成果物
 * @prop {string} style - タスクをバー表示する時の表示スタイル
 * 
 * 
 * @typedef {Object.<string>:<string>} CSSDef - 要素のデザインのオブジェクト。JavaScriptでのプロパティ名：値となるオブジェクト
 * 
 * @typedef {Object} Project
 * @prop {Task[]} tasks - 目標達成に必要なタスクの配列
 * @prop {Object.<string>:<CSSDef>} design - タスクをバー表示する時のスタイル定義
 * @prop {number} unit=5 - バーを表示する際の精度(単位：分)
 * @prop {string[]} period - タスクを追加する際の開始/終了日時の既定値
 * @prop {Object.<string>:<Task>} map - task.idをキーにタスクを検索するマップ。自動生成
 * 
 */

/**
 * @classdesc HTMLにタイムテーブルを描画する
 */

class TimeTable {

  /**
   * @constructor
   */
  constructor(id){
    console.log('----- TimeTable.constructor start. id='+id);
    const v = {};
    this.id = id;
    v.data = localStorage.getItem(id);
    this.data = v.data ? JSON.parse(v.data) : {};
    this.rootElement = document.querySelector('.timetable[name="'+id+'"]');
    this.rootElement.querySelector('.dialog button[name="closeDialog"]')
    .addEventListener('click',() => {
      this.rootElement.querySelector('.dialog').style.display = 'none';
    });
    this.draw();
    this.template = {
      section: {name:'(未定義)',children:[]},
      task: {
        name:'(未定義)',members:{},resources:[],
        start:new Date(this.data.period[0]).getTime(),
        end  :new Date(this.data.period[1]).getTime(),
      },
      member:{ideal:0,fixed:[]},
      resource:{name:'(未定義)'},
    };
  }

  /** 子要素を追加 */
  appendChild(id){
    const v = {self:this.data.map[id]};
    if( 'children' in v.self ){
      // childrenがある -> childrenにテンプレートを追加
      v.self.children.push(JSON.parse(JSON.stringify(this.template.task)));
    } else {
      // childrenがない -> 自要素の中身を退避して初期化、childrenに自要素を展開
      v.json = JSON.stringify(v.self);
      for( v.x in v.self ){
        delete v.self[v.x];
      }
      for( v.x in this.template.section ){
        v.self[v.x] = this.template.section[v.x];
      }
      v.self.children.push(JSON.parse(v.json));

    }
    localStorage.setItem(this.id,JSON.stringify(this.data));
    this.draw();
  }

  /** div.tasks領域にタスク(単体)を追加する
   * (本関数はdrawから呼ばれるプライベート関数)
   */
  appendTask(task,pId,seq){ // ガントチャートの作成
    const v = {
      tasksElement: this.rootElement.querySelector('.main .tasks'),
    };
    // taskのIDを採番、マップに追加
    task.id = pId + (seq+1) + '.';
    this.data.map[task.id] = task;

    if( 'children' in task ){
      // ラベル行：labelをtasksに追加
      v.labelElement = this.createElement({class:'label'});
      v.labelSpan = this.createElement({tag:'span',text:task.id+task.name});
      v.labelSpan.onclick = () => this.showDetail(task.id);
      v.labelElement.appendChild(v.labelSpan);
      v.tasksElement.appendChild(v.labelElement);
      for( let i=0 ; i<task.children.length ; i++ ){
        this.appendTask(task.children[i],task.id,i);
      }
    } else {
      // タスク：barをtasksに追加
      v.barElement = this.createElement({class:'bar'});
      v.barElement.style.gridTemplateColumns = 'repeat('+(this.numHour*12)+', 1fr)';
      // barSpan: 棒状の部分
      v.barSpan = this.createElement({tag:'span',name:task.id,text:task.name});
      v.barStart = ((new Date(task.start).getTime()) - this.startHour) / (this.data.unit*60000) + 1;
      v.barEnd = ((new Date(task.end).getTime()) - this.startHour) / (this.data.unit*60000) + 1;
      this.applyStyle({
        element: v.barSpan,
        apply: task.style,
        addition: {gridColumn:v.barStart + '/' + v.barEnd},
      });
      v.barSpan.onclick = () => this.showDetail(task.id);
      v.barElement.appendChild(v.barSpan);
      v.tasksElement.appendChild(v.barElement);
    }
  }

  /** 要素にスタイルを設定する
   * @param {Object} arg
   * @param {string} arg.apply - 適用するスタイル名
   * @param {Object.<string>:<string>} arg.addition - 追加適用する属性名：属性値
   * @returns {void}
   */
  applyStyle(arg){
    // apply,additionの既定値設定
    const v = Object.assign({apply:'default',addition:{}},arg);
    // 適用するスタイルのオブジェクトを作成
    v.style = Object.assign(this.data.design[v.apply],v.addition);
    for( let a in v.style ){
      arg.element.style[a] = v.style[a];
    }
  }

  /** DIV要素を生成、属性を指定する
   * @param {string} tag='div' - タグ名
   * @param {string} [text] - 生成された要素のinnerHTML
   * @param {Object.<string>:<string>} xxx - 生成された要素に設定するスタイルシート属性名：属性値
   */
  createElement(arg={}){
    let rv = document.createElement(('tag' in arg) ? arg.tag : 'div');
    for( let x in arg ){
      switch(x) {
        case 'tag': break;
        case 'text': rv.innerHTML = arg.text; break;
        default: rv.setAttribute(x,arg[x]);
      }
    }
    return rv;
  }
  
  /** タイムテーブルを(再)描画する */
  draw(){
    const v = {};
    this.minTime = Infinity; // task.startの最小値。UNIX時刻
    this.maxTime = -Infinity;
    this.startHour = Infinity; // minTime以下の正時となるUNIX時刻。表示領域の左端
    this.endHour = -Infinity;  // maxTime以上の正時となるUNIX時刻。表示領域の右端
    this.numHour = 0;          // startHour〜endHourまでの時間数    console.log(this.data);

    // 描画範囲を計算
    this.timeRange(this.data.tasks);  // minTime, v.maxTimeの取得
    this.startHour = Math.floor(this.minTime / 3600000) * 3600000;
    this.endHour = Math.ceil(this.maxTime / 3600000) * 3600000;

    // 1.controllerの要素を作成

    // 2.mainの要素を作成

    // 2.1.main.headerの要素を作成
    v.headerElement = this.rootElement.querySelector('.main .header');
    v.headerElement.innerHTML = '';
    for( v.i=this.startHour ; v.i<=this.endHour ; v.i+=3600000 ){
      v.o = this.createElement();
      v.o.innerText = new Date(v.i).getHours() + ':00';
      v.headerElement.appendChild(v.o);
      this.numHour++;
    }
    v.headerElement.style.gridTemplateColumns = 'repeat('+this.numHour+', 1fr)';
    
    // 2.2.main.timelineの要素を作成
    v.timelineElement = this.rootElement.querySelector('.main .timeline');
    v.timelineElement.innerHTML = '';
    v.timelineElement.innerHTML = '<div></div>'.repeat(this.numHour*4);
    v.timelineElement.style.gridTemplateColumns = 'repeat('+(this.numHour*4)+', 1fr)';

    // 2.2.main.tasksの要素を作成
    v.tasksElement = this.rootElement.querySelector('.main .tasks');
    v.tasksElement.innerHTML = '';
    for( let i=0 ; i<this.data.tasks.length ; i++ ){
      this.appendTask(this.data.tasks[i],'',i);
    }

    // 3.dialogの要素を作成

  }

  /** ダイアログで値が変更されたら反映 */
  editItem(taskObj,prop){
    const v = {
      element: this.rootElement.querySelector('.dialog [name="'+prop+'"] .val'),
      old: taskObj[prop],
    };
    switch(prop){
      case 'start':
      case 'end':
        v.new = new Date(v.element.value).getTime();
        taskObj[prop] = v.new;
        break;
      case 'ideal':
        v.new = Number(v.element.value);
        taskObj.members[prop] = v.new;
        break;
      case 'fixed':
        v.new = v.element.value.split(',');
        taskObj.members[prop] = v.new;
        break;
      default:
        v.new = v.element.value;
        taskObj[prop] = v.new;
    }
    localStorage.setItem(this.id,JSON.stringify(this.data));
    console.log(this.data);
    this.draw();
    //console.log('editItem: prop='+prop+'\n',taskObj);    
  }

  /** ダイアログに詳細情報を表示 */
  showDetail(id){
    const v = {
      dialogElement: this.rootElement.querySelector('.dialog'),
      task: this.data.map[id],
    }
    console.log('showDetail: '+id);
    console.log(v.task);

    // タスクの追加・削除
    v.dialogElement.querySelector('button[name="appendChild"]')
    .onclick = () => this.appendChild(id);

    // 表示項目の設定
    ['id'].forEach(x => {
      v.dialogElement.querySelector('[name="'+x+'"] .val')
      .innerText = v.task[x];
    });
    // 編集項目の設定
    ['name','summary','pending','note'].forEach(x => {
      v.o = v.dialogElement.querySelector('[name="'+x+'"] .val');
      v.o.value = v.task[x];
      v.o.onchange = (a) => this.editItem(v.task,x,v.o);
    });

    // タスク・セクションで異なる項目表示
    ['start','end','location','output','ideal','fixed'].forEach(x => {
      v.p = v.dialogElement.querySelector('[name="'+x+'"]');
      console.log(v.p)
      if( 'children' in v.task ){
        v.p.style.display = 'none';
      } else {
        v.p.style.display = 'grid';
        v.o = v.dialogElement.querySelector('[name="'+x+'"] .val');
        switch(x){
          case 'start':
          case 'end':
            v.o.value = new Date(v.task[x]).toLocaleString();
            break;
          case 'ideal':
          case 'fixed':
            v.o.value = v.task.members[x];
            break;
          default:
            v.o.value = v.task[x];
        }
        v.o.onchange = (a) => this.editItem(v.task,x,v.o);
      }
    });

    // 物的資源(不定繰返)
    v.resourcesElement = v.dialogElement.querySelector('[name="resources"]');
    if( !('children' in v.task) && ('resources' in v.task) ){
      v.str = '';
      v.task.resources.forEach(x => {
        v.str += '<tr>'
          + '<td>' + x.name + '</td>'
          + '<td class="right">' + x.quantity + '</td>'
          + '<td>' + x.unit + '</td>'
          + '<td>' + x.procurement + '</td>'
          + '<td class="right">' + x.budget + '</td>'
          + '<td>' + x.note + '</td>'
          + '</tr>';
      });
      v.resourcesElement.querySelector('tbody').innerHTML = v.str;
      v.resourcesElement.style.display = 'grid';
    } else {
      v.resourcesElement.style.display = 'none';
    }
    // ダイアログを表示
    v.dialogElement.style.display = 'grid';
  }

  /** v.minTime, v.maxTimeの取得 */
  timeRange(tasks){
    const v = {};
    for( let task of tasks ){
      if( 'children' in task ){
        this.timeRange(task.children);
      } else {
        v.st = new Date(task.start).getTime();
        v.ed = new Date(task.end).getTime();
        if( this.minTime > v.st ) this.minTime = v.st;
        if( this.maxTime < v.ed ) this.maxTime = v.ed;
      }
    }
  }
}

</script>

<!--================================================
  テスト
================================================-->
<script type="text/javascript" class="test">
const ttData = {
  unit: 5,
  map: {},
  design: {
    default: {
      color: "#000",
      backgroundColor: "rgba(196,196,196,0.6)",
      border: "solid 1px #aaa",
    },
    critical: {
      color: "#fff",
      backgroundColor: "rgba(255,96,96,0.6)",
      border: "solid 1px #f00",
    },
  },
  period: ['2023/09/30 09:00','2023/09/30 18:00'],
  tasks: [{
    name: "受付",
    summary: "参加者の受付",
    note: "正門近辺の駐輪に注意",
    start: "2023-09-30T14:00:00",
    end: "2023-09-30T15:30:00",
    location: "正門",
    members: {
      ideal: 10,
      fixed: ['嶋津','織田','羽柴','徳川'],
    },
    resources: [
      {name:"参加者名簿",quantity:2,unit:"冊",procurement:"嶋津が持参",budget:0,note:""},
      {name:"文鎮",quantity:4,unit:"個",procurement:"担当者が持参",budget:0,note:""},
      {name:"カラーコーン",quantity:12,unit:"本",procurement:"遊び場",budget:0,note:""},
    ],
    output: "記入済み名簿",
    pending: `
1. 受領した参加費の管理方法
1. 名簿(紙)で受付した人の名寄せ
    `,
    style: "default",
  },{
    name: "カレー作成",
    summary: "",
    note: "中高生ボランティア参加の可能性あり",
    children: [
      {
        name: "材料買い出し",
        summary: "青果・肉・ルーを買い出し",
        note: "事前発注は不要(例年してない)",
        start: "2023-09-30T09:30:00",
        end: "2023-09-30T10:50:00",
        location: "正門",
        members: {
          ideal: 4,
          fixed: ['国生','河合','高井'],
        },
        resources: [
          {name:"牛スネ肉",quantity:10,unit:"kg",procurement:"購入",budget:30000,note:"@250/100g以内"},
          {name:"玉ねぎ",quantity:4,unit:"kg",procurement:"購入",budget:50000,note:""},
        ],
        output: "特になし",
        style: "critical",
      },
    ]
  }]
};

// テストデータのセット
if( !localStorage.getItem('tt01') ){
  localStorage.setItem('tt01',JSON.stringify(ttData));
}
</script>

<!--================================================
  メイン処理
================================================-->
<script type="text/javascript" class="main">

async function download(arg){ // 文字列をファイルにしてダウンロード
  console.log("download start.",arg);
  let v = {};

  // base name
  v.fn = typeof arg.f === 'undefined'
    ? new DateEx().toLocale('yyyyMMdd')
    : arg.f;

  // mime, suffix
  if( typeof arg.m === 'undefined' ){
    v.mime = 'text/csv';
    v.fn += '.csv';
  } else {
    if( arg.m === 'json' ){
      v.mime = 'application/json';
      v.fn += '.json';
    } else {
      v.mime = 'text/csv';
      v.fn += '.csv';
    }
  }

  // ファイルの生成、ダウンロード
  const blob = new Blob([arg.d], {type: v.mime});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  document.body.appendChild(a);
  a.download = v.fn;
  a.href = url;
  a.click();
  a.remove();
  URL.revokeObjectURL(url);

}  // function download end.


window.addEventListener('DOMContentLoaded',() => {
  console.log('timetable test start.');
  const tt01 = new TimeTable('tt01');
});
</script>
</body>
</html>